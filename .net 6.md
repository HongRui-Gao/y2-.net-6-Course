# 1. C# 10 & .Net 6 

## 一 . C#简介

C#(CSharp)是一种新式编程语言,不仅面向对象,还类型安全.开发人员利用C#能够生成在.NET中运行的多种安全可靠的应用程序.C#源于C语言系列,C,C++,Java和JavaScript程序员很快就可以上手使用.

C#是面向对象的,面向组件的编程语言.C#提供了语言构造来直接支持这些概念,让C#成为一种非常自然的语言,可用于创建和使用软件组件.**C#语言的最新版本是C#10**

## 二. .Net 简介

.Net是一种用于构建多种应用的免费开源开发平台,我们可以通过.Net平台进行下图中内容的开发

![](imgs/1.jfif)

* 桌面应用
  * Windows WPF
  * Windows 窗体
  * 通用的Windows平台(UWP)
*  Web应用,Web Api和微服务
* 云中的无服务器函数,云原生应用
* 移动应用
* 游戏
* 物联网(IoT)
* 机器学习

我们可以使用类库在不同应用和应用类型中共享功能.

**跨平台**

我们现在可以为许多操作系统创建.Net应用,包括:

* Windows
* Linux
* macOS
* Android
* iOS
* tvOS
* watchOS

支持的处理器体系结构包括:

* X64
* X86
* ARM32
* ARM64

**SDK和运行时**

.Net SDK是一组用于开发和运行.Net应用程序的库和工具.

下载.NET的时候,我们可以选择SDK或者运行时,例如.Net运行时或ASP.NET Core运行时.在要准备运行.Net应用的计算机上安装运行时.在要用于开发的计算机上安装SDK.(**一般我们服务器上安装的是运行时,自己的开发电脑会安装SDK**)

> 如果自己的电脑已安装vs2019或者vs2022,则该ide工具自带安装了,不需要我们再去手动安装SDK

SDK下载地址: [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download)

SDK下载包括以下组件:

* .Net Cli . 用于本地开发和持续集成脚本的命令行工具
* `dotnet` 驱动程序. 用于运行依赖于框架的应用的CLI命令
* Roslyn和F#编程语言编译器
* MSBuild生成引擎
* .NET运行时. 提供类型系统,程序集加载,垃圾回收器,本机互操作和其他基本服务
* 运行时库. 提供基元数据类型和基本实用程序
* ASP.NET Core运行时. 为连接Internet的应用(如Web应用,IoT应用和移动后端)提供基本服务
* 桌面运行时.为Windows桌面应用(包括Windows窗体和WPF)提供基本服务

运行时下载包括以下组件:

* (可选) 桌面或ASP.NET Core 运行时
* .Net 运行时. 提供类型系统,程序集加载,垃圾回收器,本机互操作和其他基本服务
* 运行时库. 提供基元数据类型和基本实用程序
* `dotnet` 驱动程序. 用于运行依赖于框架的应用的CLI命令

## 三. .NET CLI技术

.NET 命令行接口(CLI)工具是用于开发,生成,运行和发布.NET应用程序的跨平台工具链

> 主要针对于的是在macOS环境下或者Linux环境下做.net开发的人员,windows环境下使用的vs开发工具底层也是通过这些指令进行操作的

### 1.  CLI命令

CLI命令共包含四种命令: 基本命令,项目修改命令,高级命令,工具管理命令

#### a. 基本命令

| 命令    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| new     | 创建命令,用于创建项目                                        |
| restore | 恢复项目的依赖项和工具                                       |
| build   | 生成项目及其所有依赖项                                       |
| publish | 将应用程序及其依赖项发布到文件夹以部署到托管系统             |
| run     | 无需任何显示编译或启动命令即可运行源代码                     |
| test    | 用于执行单元测试的.NET测试驱动程序.                          |
| vstest  | 从指定的程序集运行测试                                       |
| pack    | 将代码打包到 NuGet 包                                        |
| migrate | 将预览版 2 .NET Core 项目迁移到 .NET Core SDK 样式的项目中   |
| clean   | 清除项目输出。                                               |
| sln     | 在 .NET 解决方案文件中列出或修改项目                         |
| help    | 命令打开 docs.microsoft.com 参考页，以提供指定命令的更多详细信息。 |
| store   | 将指定的程序集存储到[运行时包存储区](https://docs.microsoft.com/zh-cn/dotnet/core/deploying/runtime-store)。 |

#### b. 项目修改命令

| 命令             | 说明                        |
| ---------------- | --------------------------- |
| add package      | 向项目文件添加包引用        |
| add reference    | 添加项目到项目 (P2P) 引用。 |
| remove package   | 从项目文件删除包引用。      |
| remove reference | 删除项目到项目 (P2P) 引用。 |
| list reference   | 列出项目到项目引用          |

#### c. 高级命令

| 命令                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| nuget delete          | 从服务器删除或取消列出包。                                   |
| nuget locals          | 清除或列出本地 NuGet 资源。                                  |
| nuget push            | 将包推送到服务器，并将其发布                                 |
| msbuild               | 生成项目及其所有依赖项。 注意：如果有多个解决方案或项目文件，可能需要指定一个。 |
| dotnet install script | 用于安装 .NET SDK 和共享运行时的脚本。                       |

#### d. 工具管理命令

| 命令           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| tool install   | 在计算机上安装指定的 [.NET 工具](https://docs.microsoft.com/zh-cn/dotnet/core/tools/global-tools) |
| tool list      | 列出计算机上当前安装的所有指定类型的 [.NET 工具](https://docs.microsoft.com/zh-cn/dotnet/core/tools/global-tools) |
| tool update    | 在计算机上更新指定的 [.NET 工具](https://docs.microsoft.com/zh-cn/dotnet/core/tools/global-tools)。 |
| tool restore   | 通常将本地工具添加到存储库的根目录。 将清单文件签入到存储库后，从存储库中签出代码的开发人员会获得最新的清单文件。我们可以通过这个命令安装清单文件中列出的所有工具 |
| tool run       | 用于调试本地工具                                             |
| tool uninstall | 从计算机上卸载指定的 [.NET 工具](https://docs.microsoft.com/zh-cn/dotnet/core/tools/global-tools)。 |

**命令结构**

CLI命令结构包含驱动程序(dotnet)和命令,还可能包含命令参数和选项.在大部分CLI操作中可看到此模式,例如:创建新控制台应用并从命令行运行该应用

``` shell
dotnet new console #console是控制台的短命称
```

## 四. C# 基础语法

### 1. C#语言发展

微软公司于2002年发布的C#1.0语法，到现在已经有20年了，今年正好是.net20周年。微软公司基本每隔几年就会发布一个新的版本C#，每次发布的内容更改具体内容如下

C# 1.0 其中包含了静态类型的面向对象编程语言的所有重要特性

C# 2.0 是在2005年发布的，重点内容是使用泛型实现强数据类型，提高代码的性能，减少类型错误

C# 3.0 是在2007年发布的，重点内容是使用语言集成查询（Linq）以及匿名类型和Lambda表达式的支持，并且在这一年微软发布了一种新的开发模式 --- MVC模式

C# 4.0 是在2010年发布的，重点内容是利用F#和Python等动态语言改进互操作性，其中包括 动态类型，命名可选参数

C# 5.0 是在2012年发布的，这个也是我们学校主要学习的内容，重点知识是简化异步操作支持，从而在编写类似于同步语句的语句时自动实现复杂的状态机

C# 6.0 是在2015年发布的，并且这一年也是.net core出现的一年，这一年C#语法没有发生太大的改变，只是在原有的基础上新增了静态导入，内插字符串，表达式体成员等

C# 7.0 是在2017年发布的，重点是添加功能语言特性，如：元组和模式匹配，还对语言做了细微的改变，具体如下：

| 功能                     | 主题                       |
| ------------------------ | -------------------------- |
| 二进制字面量和数字分隔符 | 存储整数                   |
| 模式匹配                 | 利用if语句进行模式匹配     |
| out变量                  | 控制参数的传递方式         |
| 元组                     | 将多个值与元组组合在一起   |
| 局部函数                 | 定义局部函数               |
| 默认字面量表达式         | 使用默认字面量设置字段     |
| 推断元组元素的名称       | 推断元组的名称             |
| async Main               | 改进对控制台应用程序的响应 |
| 数字字面量中的前导下画线 | 存储整数                   |
| 非追踪的命名参数         | 可选参数和命名参数         |

C# 8.0 是2019年发布的，主要关注与空处理相关的语言的重大变化，主要内容如下：

| 功能           | 主题                           |
| -------------- | ------------------------------ |
| 可空引用类型   | 使引用类型可空                 |
| switch表达式   | 使用switch表达式简化switch语句 |
| 默认的接口方法 | 了解默认接口方法               |

C# 9.0 是2020年发布，关注于记录类型，模式匹配的细化以及极简代码（Minimal-Code）控制台应用程序，主要内容如下：

| 功能                   | 主题             |
| ---------------------- | ---------------- |
| 极简代码控制台应用程序 | 顶级程序         |
| 改进的模式匹配         | 与对象的模式匹配 |
| 记录                   | 操作记录         |

### 2. 使用变量

#### 2.1 命名

|  命名约定  |       示例        |                  使用场合                  |
| :--------: | :---------------: | :----------------------------------------: |
|  驼峰命名  | cost,orderDetails |             局部变量，私有字段             |
| pascal命名 | Cost,OrderDetails | 类型，非私有字段，以及其他成员（如：方法） |

#### 2.2 常用的数据类型

C#当中常用的数据类型一共有2种，分别是 值类型和引用类型，他们分别包含了多种的内容，具体如下：

| 类型名   | 包含内容                                        |
| -------- | ----------------------------------------------- |
| 值类型   | int, double,float ,demial,bool,char,enum,struct |
| 引用类型 | string, class , object , array                  |

> 面试题： 
>
> 1. double 与 decimal 的区别：
>
>    double类型并不能保证值是精确的，因为有些数字不能表示为浮点型，decimal类型是精确的，因为这种数据类型可以将数字存储为大整数并移动小数点。
>
>    除此之外我们还需要注意double数据类型的值不能使用==来进行判断相等，历史上第一次海湾战争期间，美国爱国者导弹系统在计算的时候就是使用了double值，这种不精确性导致导弹无法跟踪和拦截来袭的伊拉克飞毛腿导弹。

**微软公司强烈推荐创建变量的时候使用var弱类型进行创建**

#### 2.3 控制流程和转换类型

##### 2.3.1 运算符

首先我们现需要去了解一下运算符，之前我们学习的时候也是学习了运算符的，运算符可将简单的操作应用于操作数，他们通常会返回一个新值，作为分配给变量的操作结果。

大多数的运算符都是二元的，这意味着他们可以处理两个操作数，例如：

``` C#
var resultOfOperation = firstOperand operator secondOperand
```

> 注： operator这个是c#当中的关键字是操作符的意思

###### 2.3.1.1 一元运算符

我们日常开发当中有2个常用的一元运算符，++ 和 --,我们常用这两个运算符进行值的递增和递减，我们需要注意这两个符号操作时值的变化，这个是重点

###### 2.3.1.2 二元运算符

二元运算符其实就是我们在学校学习的这些运算符了，包括： 算数运算符，赋值运算符，逻辑运算符，关系运算符，除此之外我们还有其他运算符，例如：

nameof 与 sizeof 这两个也是我们比较常用的运算符，他们属于其他运算符。

nameof 它会以字符串格式的形式返回变量、类型或成员的短名称（没有命名空间），这在输出异常消息的时候非常有用

sizeof 它会返回简单类型的字节大小，这对于数据存储的效率很有用。

##### 2.3.2 选择语句

 选择语句当中我们比较常用的是if语句和switch语句，if语句可以适用于所有的选择情况，但是在一些常见的场景种使用switch语句会简化代码，例如：当一个变量有多个值，而每个值都需要进行不同的处理时

###### 2.3.2.1 if语句

if语句的几种模式就不介绍了，在这里我们主要还是需要讲解一下C# 7.0新增的模式匹配

在C# 7.0之后的语法当中，if语句可以将is 关键字与局部变量声明结合起来进行使用，从而使代码更加安全。例如下面的代码：

``` C#
object o = 3;
int j = 4;
if(o is int i)
{
    Console.WriteLine($"{i} x {j} = {i*j}");
}
else
{
    Console.WriteLine("o is not an int , so it cannot multiply!");
}
```

运行上面的代码，控制台会输出

3 x 4 = 12

###### 2.3.2.2 switch语句

与上面的if语句一样，在C# 7.0之后模式匹配也可以与switch语句连用。case后面的值不再必须是字面值，还可以是模式。

下面看一个使用文件夹路径与switch语句匹配的模式示例。

``` C#
using System;
using System.IO;

static void Main(string[] args)
{
	string path = @"c:\Code\Demo1";
    Console.Write("Press r for readonly or w for write");
    ConsoleKeyInfo key = Console.ReadKey();
    
    Stream s = null;
 	if(key.Key == ConsoleKey.R)
    {
        s = File.Open(
        	Path.Combine(path,"file.text"),
            FileMode.OpenOrCreate,
            FileAccess.Read);
    }
    else
    {
        s = File.Open(
        	Path.Combine(path,"file.text"),
            FileMode.OpenOrCreate,
            FileAccess.Write); 
    }
    string message = string.Empty;
    switch(s)
    {
        case FileStream writeableFile when s.canWrite:
            message = "the stream is a file that I can write to.";
            break;
        case FileStream readOnlyFile:
            message = "the stream is a read-only file.";
            break;
        case MemoryStream ms:
            message = "the stream is a memory address.";
            break;
        default:
            message = "the stream is some other type.";
            break;
        case null:
            message = "the stream is null.";
            break;
    }
    Console.Write(message);
}
```

运行控制台程序，我们会发现，名为s的变量被声明为Stream类型，因而可以是流的任何子类型，比如内存流或文件流。在上面这段代码种，流是使用File.Open方法创建的文件流。由于使用了FileMode,而文件流是可写的或只读的，因此我们会得到一条描述情况的消息，如下：

> the stream is a file that I can write to.

看了上面的代码我们发现在case语句后面是可以包含when关键字以执行更具体的模式匹配的，观察上面的代码。在第一个子句case中，只有当流是FileStream且CanWrite属性为true时，s变量才是匹配的。

在C#8.0及更高的版本中，可以使用switch表达式简化switch语句。

大多数的switch语句都非常简单，但是他们需要大量的输入。switch表达式的设计目的是简化需要输入的代码，同时仍然表达相同的意图。所有的case子句都将返回一个值以设置单个变量。switch表达式使用 => 来表示返回值。

下面我们通过这种简化写法把上面代码中的switch语句简化一下：

``` C#
message = s switch
{
    FileStream writeableFile where s.CanWrite
        => "the stream is a file that I can write to.",
    FileStream readOnlyFile
        => "the stream is a read-only file.",
    MemoryStream ms 
        => "the stream is a memory address.",
    null
        => "the stream is null.",
    _
        => "the stream is some other type."    
};
Console.Write(message);
```

区别主要是去掉了case和break关键字，下划线字符用于表示默认的返回值。

##### 2.3.3 迭代语句

C#当中的迭代语句一共有4种，分别是while，do-while,for,foreach 这些也是我们在S1,S2阶段比较常用的语法，没有什么改变还是当条件为真的时候就进入迭代，语法不在赘述。

##### 2.3.4 转换

C#当中数据类型的转换一共有2种方式，分别是隐式转换和显示转换，隐式转换只存在于低等数据类型转换高等数据类型当中，例如： int 转换为double

``` C#
int a = 10;
double b = a;
```

数据类型的显示转换有2种语法可以进行转换:

第一种：

> 数据类型.Parse(要转换的变量);

这种转换要求：要进行转换的变量必须是string类型的值

第二种：

> Convert.To数据类型(要转换的变量);

这种转换对要进行转换的值没有任何要求，可以转换为任意数据类型

注： 在C#中，所有的数据类型转换为string类型的值时候，我们只需要用这个变量名调用对应的ToString方法即可。



## 五. C# 高级语法

### 5.1 依赖注入

在维基百科当中对依赖注入是这样解释的:"依赖注入是一种软件设计模式,指一个或者多个依赖(或服务)被注入,或通过引用传递,传入一个依赖对象(或客户端)并成为客户状态的一部分.该模式通过自身的行为分离了客户依赖的创建,这允许程序设计是松耦合的,同时遵循依赖倒置和单一职责原则.与服务定位器模式直接进行对比,它允许用户了解他们用来查找依赖的机制."

由于依赖注入的概念难免有些晦涩,因此我们通过下面的这例子详细的了解一下依赖注入.

以前我们的做法是直接实例化类,代码如下.这种方式是不推荐的,因为它无法将系统解耦.

``` C#
public IActionResult Index()
{
    IStudentManager _stuMgr = new StudentManager();
    return View();
}
```

下面的是推荐的写法:

``` C#
public class HomeController : Controller
{
    private IStudentManager _stuMgr;
    public HomeController(IStudentManager stuMgr)
    {
        _stuMgr = stuMgr;
    }
    
}
```

这种是通过构造函数的方式注入IStudentManager到HomeController中,而不是HomeController对IStudentManager接口创建新的实例化. 这成为构造函数注入,因为我们使用构造函数来注入依赖项.如果我们在此时运行项目,则会收到以下错误

> InvalidOperationException:Unable to resolve service for type"xxxxx.IStudentManager" while attempting to activate "xxxx.HomeController".

这个是因为如果有人请求实现IStudentManager的对象,Asp.Net Core依赖注入容器不知道要提供哪个对象实例,原因如下:

IStudentManager可能有多个实现.在我们的项目中只有一个实现,那就是StudentManager

**使用依赖注入注册服务**

Asp.Net Core提供以下3种方法来使用依赖注入注册服务.我们使用的方法决定了注册服务的声明周期.

**(1) AddSingleton() 方法**

AddSingleton()方法创建一个Singleton服务.首次请求时会创建Singleton服务,然后所有后续请求都使用相同的实例.因此通常每个应用程序只创建一次Singleton服务,并且在整个应用程序生命周期种使用该单个实例.

**(2) AddTransient()方法**

AddTransient()方法可以称作暂时性模式,它会创建一个Transient服务.每次请求时,都会创建也给新的Transient服务实例

**(3) AddScoped()方法**

AddScoped()方法创建一个Scoped服务.在范围内的每个请求中创建一个新的Scoped服务实例.比如,在Web应用程序中,它为每个HTTP请求创建一个实例,但在同一HTTP请求的其他调用中使用相同的实例;在一个客户端请求中是相同的,而在多个客户端请求中是不同的.

我们需要在Startup类中的ConfigureServices方法中添加如下代码:

``` C#
services.AddSingleton<接口名,实现类名>();
services.AddTransient<接口名,实现类名>();
services.AddScoped<接口名,实现类名>();
```



### 5.2 异步编程

在.Net Framework 4.5的时候,微软公司把任务并行库(Task Para uel Library,TPL)添加到.Net中,,以使并行编程更加容易. C#5.0的时候添加了async和await两个关键字来简化异步编程.

使用异步编程,方法调用时在后台运行(通常在线程或任务的帮助下),并且不会阻塞调用线程.

我们想要使用异步编程需要在想要设定异步的方法上添加async修饰符,并且我们需要把返回值通过Task来进行约束

当我们的方法是没有返回值的,那么我们可以按照下面的示例进行声明

``` C#
public async Task Show(){
   
}
```

但是当我们的方法是带有返回值的时候,我们需要把返回值类型设定为Task的泛型,用于约束返回值的类型,代码如下:

``` C#
public async Task<int> Show(){
    return 0;
}
```

当我们调用异步的方法时,需要在这个方法的前面加上await关键字(**使用await关键字的时候,需要书写的这个方法必须被async关键字进行修饰**)

``` C#
public async Task Haha()
{
    await Show();
}
```



### 5.3 委托

委托是C#当中类型安全的类,它定义了返回类型和参数类型.委托类不仅包含对方法的引用,也可以包含对多个方法的引用.

当我们要把方法传送给其他方法的时候(指当作参数传送),我们据需要使用委托了.

#### 5.3.1 声明委托

在C#当中使用一个类的时候,我们首先需要去先定义这个类,告诉编译器我们的这个类当中都包含哪些内容,然后去实例化这个类,调用其中的内容.我们在使用委托的时候与上面的步骤一致,我们也需要前去声明,之后再去使用.

声明委托的语法如下:

``` C#
权限修饰符 delegate 返回值 委托名称([参数列表]);
```

例如:

``` C#
public delegate void MyDelegate(int x);
```

上面声明了一个无返回值,带有一个参数的委托.理解委托的一个要点是他们的类型安全性非常的高.在定义委托时,必须给出它所示的方法的签名和返回类型等全部细节.

#### 5.3.2 使用委托

观察下面代码我们现在需要得到一个全新的字符串内容,

``` C#
public delegate int GetAString(string a); //声明一个带有参数,带有返回值的委托

public static void Main(String[] args){
    string str = "abcd";
    GetAString gas = new GetAString(GetStringLength); //实例化上面的委托对象,并且把我们要使用的方法当作参数进行传递
    Console.WriteLine($"字符串的长度是{gas(str)}"); //这个是使用我们的委托对象,在使用时需要传递对应方法的参数值
}

public static int GetStringLength(string s) //声明一个静态的方法,得到字符串的长度
{
    return s.length;
} 
```

我们在使用委托的时候需要注意: **我们在传递方法的时候,要求这个方法必须与我们声明的委托返回值类型相同,参数列表完全相同**

#### 5.3.3 Action\<T> 和 Func\<T>

我们除了使用上面的声明委托方式进行声明以外,还可以使用.Net给我们封装好的委托类型Action和Func委托.

泛型Action\<T>委托表示引用一个void返回类型的方法,泛型T是对参数的修饰,这种委托存在不同的变体,可以传递至多16种不同的参数类型.如果我们创建一个不带有泛型的Action委托,则代表我们要调用的方法没有参数.

Func\<T>可以使用类似的方式进行使用.Func\<T> 允许我们调用带有返回值类型的方法.与Action\<T>类似,Func\<T>也定义了不同的变体,至多可以传递16个参数类型和一个返回值类型.当我们书写多个泛型的时候,最后一个泛型**一定**是对返回值类型的约束

#### 5.3.4 Lambda表达式

使用Lambda表达式的一个场合是把lambda表达式赋予委托类型:在线实现代码.只要有委托参数类型的地方,就可以使用lambda表达式.

例如:

``` C#
class Program
{
    static void Main()
    {
       		 string mid = ", middle part ,";  //声明一个string变量

            Func<string, string> func = parma =>
            {
                parma += mid;
                parma += "and this was added to the string.";
                return parma;
            }; //创建一个Func委托,要求带有一个string类型参数和string类型的返回值, 委托调用的方法是把传递进来的参数进行拼接
            //把上面的变量和里面带有的一个string与string类型的参数拼接到一起,并且返回.

            Console.WriteLine(func("Start of string"));
        
    }
    
}
```

 当我们运行上面的代码的时候得到的返回值是

``` cmd
Start of string , middle part , and this was added to the string.
```

lambda运算符"=>"的左边列出了需要的参数,而其右边定义了赋予lambda变量的方法的实现代码.

### 5.4 QuartZ

QuartZ 是一个用于定时的语法,我们管它叫做调动服务

#### 5.4.1 什么是调度服务

调度服务: 就是在指定的时间点去做什么事,循环往复

**QuartZ核心概念**

**任务 Job**

任务就是我们想要实现的任务类

**触发器 Trigger**

Trigger 是执行任务的触发器,比如我们每天晚上5点要发送当天的工作日报,我们就可以使用Trigger设置在5点钟的时候执行该任务.

**调度器 Scheduler**

Scheduler 为任务的调度器,它会将任务 Job 及 触发器 Trigger整合起来, 负责基于Trigger设定的时间来执行Job

#### 5.4.2 QuartZ使用

步骤:

(1)  在Nuget当中安装 QuartZ

(2)  创建三大核心对象

​      ISchedule :  时间轴   单元  盒子  在这里进行任务配置

​      IJobDetail :  描述具体做什么事情, 定时任务执行的动作

​      ITrigger : 时间策略, 按照什么频率来执行



``` c#
public static class DispatcherManager
{
    public async Task Init(){
        // 创建一个调度器
        StdSchedulerFactory factory = new StdSchedulerFactory();
        IScheduler scheduler =await  factory.GetScheduler();
        await scheduler.Start();


        //创建一个工作描述
        IJobDetail jobDetail = JobBuilder.Create<SendMessage>()
                                         .WithIdentity("要做的工作描述","分组名称")
                                         .WithDescription("")
                                         .Build();		
        //创建触发器,明确多少时间执行一次
        ITrigger trigger = TriggerBuilder.Create()
                                        .WithIdentity("我们Trigger名称","要进行分组的名称").StartNow()
                                        .WithCronSchedule("5/10****?")
                                        .WithDescription("").Build();

        await scheduler.ScheduleJob(jobDetail,trigger);

   }
    
}
```

``` C#
public class SendMsg : IJob //IJob接口是 我们要做的内容
{
    public async Task Execute(IJobExecutionContext context) //这个方法是我们要执行的内容
    {
        await Task.Run(() => {
           Console.WriteLine("1234"); 
        });
    }
    
}
```

``` C#
public class Program
{
    static void main(string[] args)
    {
    	    DispatcherManager.Init().GetAwaiter().GetResult();
    }
    
}
```

11



## 六. .Net MVC

### 6.1 什么是MVC

Asp.Net Core MVC是使用“模型-视图-控制器”设计模式构建的Web应用和API的丰富框架。

MVC体系结构模式将应用分成3个主要部分：模型、视图和控制器。此模式有助于实现**关注点分离**。使用此模式，用户请求被路由到控制器，后者负责使用模型来执行用户操作或检索用户查询结果。控制器选择要显示给用户的视图，并提供所需要的任何模型数据。

![](imgs/5.png)

### 6.2 项目结构

我们通过Visual Studio 2022(或者Visual Studio 2019)创建 Asp.Net Core Web应用程序（模型-视图-控制器）项目这个就是我们要用的mvc项目。

![](imgs/6.png)

创建完成之后，项目结构如下：

![](imgs/7.png)

我们在这个结构中需要知道：

1. wwwroot 这个文件夹是让我们存放静态资源的，里面包含css,js,图片等等内容
2. 依赖项就是我们之前.net framework项目当中的引用
3. Controllers文件夹当中存放我们的控制器内容
4. Models文件夹当中存放的我们的模型内容
5. Views文件夹当中存放视图文件
6. appsettings.json文件用于配置项目，与原.net framework 项目当中的web.config一致
7. Program.cs文件是我们当前项目的运行主文件，里面带有主方法
8. Startup.cs 文件是我们配置中间件的文件



我们通过查看各个文件知道了appsetting.json文件当中的所有配置内容都是json格式的内容，我们以后要对当前项目进行配置例如：创建一个与数据库连接的语句等等这些操作时，需要书写一个类似的json字符串

我们现在需要把重点放到Startup类当中，具体代码如下：

![](imgs/8.png)

Startup类用于配置服务和应用的请求管道。

服务是应用使用的组件。例如：日志记录组件就是一项服务。配置（或注册）服务的代码应添加到Startup.ConfigureServices方法中。

请求管道由一系列中间件组件组成。例如：中间件可能处理对静态文件的请求或将HTTP请求重定向到HTTPS。每个中间件在HttpContext上执行异步操作，然后调用管道中的下一个中间件或者终止请求，配置请求处理管道的代码应添加到Startuo.Configure方法当中。

### 6.3中间件

通常我们通过在Startup.Configure方法中调用其Use...扩展方法，向管道添加中间件组件。例如：我们想要启用静态文件，我们就需要添加调用UseStaticFiles方法。

我们常见的中间件有：

| 中间件方法       | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| UseStaticFiles   | 启用静态文件的中间件                                         |
| UseRouting       | 启用路由的中间件                                             |
| app.UseEndpoints | 启用终点的中间件，这个中间件主要的作用就是给路由进行配置规则 |



### 6.4创建控制器

我们在Controllers文件夹上鼠标右键选择添加控制器，在添加控制器的时候我们一定要注意：

1. 所有的控制器命名时必须时以Controller为结尾
2. 必须创建在Controllers文件夹当中
3. 控制器的真正的名字是Controller前面的内容。例如：我们创建一个关于我们的控制器，则起名应该是AboutController，其中About是名字，Controller是必带的后缀

创建完成之后我们在创建的控制器内可以看到一个默认带有的Index方法,代码如下：

``` C#
public IActionResult Index()
{
    return View();
}
```

我们需要知道的是这个方法就是让我们创建视图的方法，其中IActionResult这个就是我们返回视图界面时的返回值类型，这个类型当中包含了视图内容与Json结果。 return 后面的View()方法则代表了我们返回的视图方法。

### 6.5 创建视图

创建视图我们一共有2种方法：

第一种是我们在要创建视图的方法名上鼠标右键，就会看到添加视图，点击添加视图即可去创建该方法对应的视图内容。

第二种创建方式是我们完全去手动创建。

假如我们有如下的控制器代码：

``` C#
public class AboutController : Controller
{
    public IActionResult Index()
	{
    	return View();
	}
    
}
```

我们只需要去项目当中的Views文件夹下，创建一个与控制器同名的文件夹，这个里面就是About文件夹，之后在这个文件夹下创建一个名字为Index的Razor视图即可，这个视图文件就是我们About控制器下Index方法对应的视图文件。

### 6.6 控制器给视图传值

控制器给视图传值一共有4种方式：

（1） ViewData方式

这种方式是以类似于Session对象的方式进行传递值，语法如下：

``` C#
ViewData["key"] = value;
```

这种传递方式会进行装箱和拆箱操作，所以安全性较高，但是每次使用时都需要进行强制转换，所以效率较低。

(2)  ViewBag方式

这种方式是让我们设定一个ViewBag的属性，然后通过这个属性进行传递至，语法如下：

``` C#
ViewBag.Key = value;
```

这种传递方式不需要进行装箱和拆箱操作，所有安全性较低，但是效率比ViewData高

(3) TempData方式

这种方式使用时的语法与ViewData相同,但是这种方式在使用的时候只能用一次,用过一次之后就会消失

``` C#
TempData["key"] = value;
```

这种方式我们一般用于存储验证码等等只能使用一次的技术

(4) 强类型视图传值

这种方式是我们最常见的一种,也是MVC当中比较主要的一种.

在我们控制器返回视图的同时把值传递到视图当中

控制器的语法如下:

``` C#
public IActionResult Index()
{
    return View(值);
}
```

在视图当中,我们需要在首行进行设定强类型视图的值和类型

视图当中语法如下

``` C#
@model 传过来值的类型
@{
    Layout = null;
}    
<!doctype html>
<html>
    <head></head>
    <body></body>
</html>    
```

在接收值之后我们需要在页面使用时,可以通过@Model来进行使用,这个Model就是我们传递过来的值在页面里面存储到的变量,通过这个变量我们就能够使用传递过来的值了,需要注意的是传递过来的值是什么类型的这个Model就是什么类型

### 6.7 Razor视图语法

#### 6.7.1 Razor基本语法

我们Razor试图语法，暂时只需要记住两种，

第一种是@{  } 这个花括号当中需要存放C#的带有变量赋值的语法

第二种是@后面直接加上C#基本语法例如：if,while,for等等基础语法

#### 6.7.2 Html Helper标签

Html Helper是为了方便View开发而产生的。

在MVC中，普通首页超级链接为\<a href="/home/index">首页\</a>,当路由改变时可能需要修改为\<a href="/home_bdqn/index">首页\</a>，如果项目里面有很多超链接就需要改动很多地方。

我们需要的时路由改变也不受影响：\<a href="<%=Url.Action("Index","Home")%>">首页\</a>。因为没有智能感知，调试不方便，所以应运而生了Html.Action("Home","Index").

##### HtmlHelper的Action、表单标签

###### (1) ActionLink( )

 ``` C#
 @Html.ActionLink("超链接文本信息","方法名"[,"控制器名",路由值,html属性])
 ```

动态生成超链接，根据路由规则，生成对应的HTML代码,语法当中中括号当中的内容是可省略的.

案例:

``` C#
@Html.ActionLink("关于我们","Info","About",new{ id = 1},new{ @class="txt"})
```

需要注意的是因为class是C#当中的关键字,所以我们在html属性当中要书写class属性的时候需要在前面加上一个@符

###### (2) Form

``` C#
@using(Html.BeginForm("方法名","控制器名"[,FormMethod提交方式,路由值)){}
```

我们强烈推荐上面的这种写法通过C#代码当中using语句自动实现结束的form标签,只要出了后面的花括号,就代表结束了form标签

案例:

``` C#
@using(Html.BeginForm("Add","Grades",FormMethod.Post,new{ enctype="multipart/form-data"})){ }
```

###### (3) 文本框

``` C#
@Html.TextBox("name属性值")
```

上面的写法是文本框的弱类型写法,只会生产一个input标签,并不会带有对应的值

案例:

``` C#
@Html.TextBox("Title")
```

当我们页面上存在这强类型视图传值的时候,并且需要把这个值在文本框当中显示时,我们需要用到下面的强类型视图的写法 

``` C#
@Html.TextBoxFor(自己起一个名字 => 用自己的名字.你要放入到这个地方的属性名)
```

我们在小括号当中自己的名字是创建一个用于接收强类型视图传值的对象名,通过这对象名来进行调用

案例:

``` C#
@Html.TextBoxFor(m => m.Id)
```

###### (4) 密码框

弱类型

``` C#
@Html.Password("name属性值")
```

强类型

``` C#
@Html.PasswordFor(自己起一个名字 => 用自己的名字.你要放入到这个地方的属性名)
```

使用方式与文本框相同

###### (5) 隐藏域

弱类型

``` C#
@Html.Hidden("name属性值")
```

强类型

``` C#
@Html.HiddenFor(自己起一个名字 => 用自己的名字.你要放入到这个地方的属性名)
```

使用方式与文本框相同

###### (6) 单选按钮

``` C#
@Html.RadioButton("name属性名","返回的值",是否选中)
```

是否选中的位置上只能输入true或者false

案例:

``` C#
@Html.RadioButton("Gender","男",true)男</br>
@Html.RadioButton("Gender","女",false)女
```

当name属性值相同时,代表这几个标签为同一组的标签

###### (7) 复选框按钮

``` C#
@Html.CheckBox("name属性名","返回的值",是否选中)
```

使用方式与单选按钮相同

###### (8) 下拉列表

``` C#
@Html.DropDownList("name属性值",集合值[,html属性])
```

需要注意的时集合值的泛型必须是SelectListItem类型的集合,或者数组



#### 6.7.3 TagHelper

#### 6.7.4 Model模型验证

这个是微软公司提供的通过在封装的时候给属性添加特性进行验证的一种方式,里面的内容能够让我们更加直观的看到每个属性都带有那些数据验证.这种验证方式属于服务器验证.

我们在使用这种验证的时候,需要根据所使用的验证内容不同添加下面的2个引用,他们分为是

``` C#
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
```

##### (1) Required

``` C#
[Required(ErrorMessage="")]
public string Name{get;set;}
```

上面属性上的内容就是非空验证的写法,其中Required代表非空,小括号当中代表对这个验证属性的设定,ErrorMessage是让我们设定错误信息,只要触发了这个异常就会提示的信息.

##### (2) StringLength

``` C#
[StringLength(""[,ErrorMessage="",MinimumLength=""])]
public string Name{get;set;}
```

这个是让我们设定字符串的长度的,如果我们只写一个参数则代表这个字符串最大的长度值是这个值,后面中括号里面的内容是可选的,如果我们要进行设定则如下:

``` C#
[StringLength("50",MinimumLength="10")]
public string Name{get;set;}
```

这个代表最小长度为10,最大的长度为50.其中最小长度需要我们指明进行设定

##### (3) Column

``` C#
[Column(TypeName = "")]
public string Name{get;set;}
```

这个是让我们设定当前属性在数据库当中具体是哪个类型的,例如:string在数据库当中对应的是varchar或者nvarchar,具体使用的是哪个需要我们通过这个来进行指明.,字符串在指明用哪个的时候还需要写清长度的值

``` C#
[Column(TypeName = "varchar(50)")]
public string Name{get;set;}
[Column(TypeName = "date")]
public DateTime Birthday{get;set;}
```

##### (4) Display

这个是让我们设定当前属性的含义的,我们通过这个可以给错误信息传递当前属性的含义,不需要每个报错信息都写上含义了.

``` C#
[Required(ErrorMessage="{0}不能为空")]
[StringLength("50",MinimumLength="10",ErrorMessage="字符串{0}的长度必须在10~50之间")]
[Display(Name = "姓名")]
public string Name{get;set;}
```

##### (5) Key

这个是让我们把当前修饰的属性在数据库当中对应的列设定为主键的,如果这个属性是int类型,则这个主键会自动增长.

``` C#
[Key]
public int Id{get;set;}
```



#### 6.7.5 EF Core

EF Core(全称EntityFramework Core) 这个是微软公司开发的一个轻量级ORM(Object Relational Mapper)框架,主要是针对我们现在写的项目中与数据库映射和数据库操作的.

我们如果在现在的项目当中想要使用这个框架,首先我们需要对这个框架进行安装.

##### 1. 框架安装

这个框架安装方式我们共有2种,分别是通过Nuget包管理器安装和Nuget包管理器控制台进行安装.

###### a. Nuget包管理器

我们只要选中项目,鼠标右键之后点击管理Nuget程序包就可以进入Nuget包管理界面

<img src="imgs/9.png" style="zoom:60%;" />

<img src="imgs/10.png" zoom="50%" />

之后我们只要点击浏览的选项卡,进行搜索下面三个包进行添加即可.

Microsoft.EntityFrameworkCore

Microsoft.EntityFrameworkCore.SqlServer

Microsoft.EntityFrameworkCore.Tools

**安装时需要注意要与自己当前创建的.net core版本兼容**

###### b. Nuget包管理器控制台

我们在vs上找到并点击工具,之后鼠标停在Nuget包管理器上,又会弹出一个新的界面,在这个新的界面里选择程序包管理器控制台即可打开Nuget包管理器的控制台界面

<img src="imgs/11.png" zoom="50%" />

我们只需要在控制台当中输入如下代码即可安装内容

``` shell
install-package 包名 -v 版本号
```

##### 2. 项目配置

###### 2.1 配置连接语句

我们打开项目里面的appsettings.json文件,在原有的代码上进行添加连接语句的代码,效果如下:

<img src="imgs/12.png" /> 

###### 2.2 创建项目基础配置

我们只需要安装原有的方式在startup文件当中配置mvc所需的基础配置,并且创建对应的文件夹即可.

###### 2.3 封装

我们在Models文件夹当中对对应的类进行封装,在封装时需要对各个属性添加特性进行约束

###### 2.4 添加数据库上下文

我们需要在Models文件夹当中创建一个类,类名要求以数据库名为开头后面加上Context后缀,这个类就是我们的数据库上下文配置文件.

例如: StudentDbContext

创建好这个类之后我们需要继承DbContext这个父类,并且在这个类当中创建一个带参的构造函数,这个参数需要传递到父类当中,让其实现与数据库的连接操作.这个参数的类型为DbContextOptions.这个参数还需要我们传递一个泛型,这个泛型就是当前的这个数据库上下文的名字,这个类的具体效果如下:

``` C#
public class StudentDbContext : DbContext
{
    public StudentDbContext(DbContextOptions<StudentDbContext> options)
        :base(options)
    {
        
    }
    
    //下面开始设定我们数据库当中的表
    public DbSet<封装类的名字> 封装类的名字{get;set;}
    //我们以后有几个表就需要按照上面的方式封装几个
}
```

###### 2.5 配置数据库连接服务

我们需要回到startup文件,在ConfigureServices这个方法内,我们需要配置数据库上下文的服务.具体代码如下

``` C#
services.AddDbContext<我们自己创建的数据库上下文名字>(自己起一个名字 => 自己起的名字.UseSqlServer(我们导入json文件的连接语句));
```

我们导入json文件的连接语句方式为:

a. 在startup类当中封装一个 IConfiguration类型的字段,之后通过依赖注入进行存值.

``` C#
public class Startup
{
    private IConfiguration _config;
    public Startup(IConfiguration config)
    {
        _config = config;
    }
}
```

b. 之后在UseSqlServer小括号当中填入下面的代码

``` C#
_config.GetConnectionString("连接语句的名字")
```

###### 2.6 数据迁移

当我们完成了上面的步骤之后,只需要在下面的程序包管理器控制台当中输入下面的两个代码指令即可

a. add-migration 这次迁移的简单描述

例如:

``` shell
add-migration initial
```

b. update-database 更新数据库

###### 2.7 EF Core 执行增删改产操作

我们现在使用EF Core进行增删改查的时候,与原来不同的是不再需要我们去写SQL Server语句,该框架把我们要进行操作的所有内容全部封装到对应的方法当中了.

1.  新增

``` C#
数据库上下文.Entry<要存入的类型>(要存入的值).State = EntityState.Added;
```

这个段代码是把我们要存储的值保存到数据缓冲区,并不是保存到数据中,所以光写上面的语句我们在数据库里并不能看到数据的改变,如果要把数据缓冲区的内容更新到数据库当中我们还需要执行下面的语句

``` C#
数据上下文的名字.SaveChanges(); 或
数据上下文的名字.SaveChangesAsync();    
```

上面的方法执行后会返回受影响行数

2. 修改

``` C#
数据库上下文.Entry<要存入的类型>(要存入的值).State = EntityState.Modified;
```

使用方法与上面的代码相同

3. 删除

``` C#
数据库上下文.Entry<要存入的类型>(要存入的值).State = EntityState.Deleted;
```

4. 查询

``` C#
数据上下文.Set<对应的类型>(); 
```

上面的内容会把我们对应的表中数据返回,并且存储到IEnumberable集合当中,

如果我们想要List集合的值,我们只需要在后面通过Linq的方法(ToList)进行转换即可

###### 2.8 EF Core 事务

可以让我们同时执行多条数据操作，当其中如果有失败的内容允许我们所有的操作同时回滚的技术。

> 数据库的事务
>
> SqlServer:
>
> begin transaction   开启事务
>
> commit tran  提交事务
>
> rollback tran  回滚事务
>
> MySql:
>
> 设定开启/关闭自动提交
>
> set autocommit = 1/0
>
> start transaction  开启事务
>
> commit                  提交
>
> rollback                 回滚

EF当中的事务与数据的内容类似，我们这个内容需要在DAL/Repository层设定，带有外键的删除，删除主键内容

使用的步骤：

(1) 添加引用： using Microsoft.EntityFrameworkCore.Storage;

(2) 在想要使用事务的方法里，先去开启事务

``` c#
using(IDbContextTransaction idct = 数据库上下文.DataBase.BeginTransaction())
{
    
    
}
```

（3）我们在这个作用域下进行代码书写，当我们代码出错了，或者不满足我们的逻辑关系时，执行回滚事务

```  C#
idct.RollBack();
```

满足要求，则进行提交事务

``` C#
idct.Commit();
```





##### 6.7.6 Session的使用

 Session是.Net内置对象之一,主要是让我们在做用户登入时我们存储用户信息的.在之前我们学习的.Net framework的项目当中,Session的使用并不需要做任何配置,我们拿过来直接使用即可,,例如:

``` C#
Session["Key"] = value;
```

但是在.Net Core当中的项目里.不行,.net Core 并没有内置Session,想要使用我们必须手动配置.,我们需要在Startup类的ConfigureServices方法和Configure方法里分别进行注册服务和中间件.

ConfigureServices方法里添加:

``` C#
services.AddSession();
```

Configure方法里添加:

``` C#
app.UseSession();
```

> 注意: 上面Configure方法添加的语句必须放在静态文件的中间件语句的下面,否则报错.

上面的两条语句是配置Session,允许我们在.Net Core项目当中使用Session,

下面的内容是Session的使用方式(Session只能在控制器里面进行使用)

``` C#
HttpContext.Session.SetString(key,value); 
```

上面的语句是进行设定Session,要求key和value的值必须是String类型的值

``` C#
HttpContext.Session.GetString(key);
```

这条语句是用于获取 Session的

##### 6.7.7 搭建基架项目

我们在实际项目开发当中因为功能较多,如果都存放在一个控制器下会比较混乱,所以我们一般会把每个模块单独的创建出来一个基架(或者称为域)来存储.

我们选择展示层鼠标右键,点击添加,选择其中的新搭建基架的项目,创建对应的域内容.

<img src="imgs/15.png" style="zoom:60%;" />

之后选择MVC区域

![](imgs/16.png)

之后在新弹出的界面里输入一个域的名称,注意这个名称不要与项目,控制器等内容重名.

![](imgs/17.png)

选择添加之后就会创建出对应的区域,这个区域就是让我们添加对应模块代码的,我们在其他的控制器下想要跳转进这个区域下的控制器中,需要额外进行配置.

在我们创建成功之后,在项目里会自动添加一个.txt文件,这个文件当中记录了该区域的路由配置信息,我们需要把这个信息复制到startup类当中原有的路由配置信息的下面

<img src="imgs/18.png" style="zoom:60%;" />

之后我们需要注意的是,在区域当中创建的任意一个控制器的上面都需要添加一个特性,用于标明该控制器属于这个区域

![](imgs/19.png)

我们以后再去访问区域当中的页面时,一定要符合区域的路由配置,例如我们在上图的控制器当中添加一个Index视图,如果要访问我们需要输入下面的路径

https://localhost:5000/StudentArea/WelcomeStudent/Index

其中StudentArea为区域名,WelcomeStudent为控制器名,Index为方法名(视图名)

##### 6.7.8 Autofac

**什么是Autofac**

Autofac是一个非常优秀的.Net IOC框架,主要是让我们实现依赖注入功能,现在我们的.Net Core项目里面自带了一套依赖注入,但是这个依赖注入的功能并不是特别的强大,所以我们在外面真正的开发的时候大部分我们需要去额外安装这种框架来替换掉原有的.

**Autofac的使用**

步骤一: 我们需要去Nuget当中进行安装

我们一共需要安装两个包

(1) Autofac

(2) Autofac.Extensions.DependencyInjection

![](imgs/26.png)

步骤二: 我们去Program.cs文件当中进行书写配置信息,要求需要写在 **var app = builder.Build(); 语句的上面.**

具体配置信息如下:

``` C#
using Autofac;
using Autofac.Extensions.DependencyInjection;
using System.Reflection; //这个是引入反射

var builder = WebApplication.CreateBuilder(args);
builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory()); //把Autofac服务信息进行引入

builder.Host.ConfigureContainer<ContainerBuilder>(
   container => {
   Assembly assembly = Assembly.Load("实现类的命名空间名"); //通过反射找到这个命名空间
    container.RegisterAssemblyTypes(assembly).AsImplementedInterfaces().InstancePerDependency();
 //这个是注册我们通过依赖注入找到的命名空间里面所包含的所有类名,并且自己对应上这个类实现的接口,起到批量注册的功能  
   }      
); //开始进行依赖注入的注册(批量注入)
```

实战项目当中因为我们的项目当中有仓储层和服务层这两个都需要通过依赖注入来进行解耦,所以我们需要进行两次的批量注入,案例代码如下:

![](imgs/27.png)

步骤三: 我们还需要去实现层当中添加一个返回程序集名字的类和方法

例如,我们在仓储层下创建一个ResopitoryCore的类,并且在里面添加如下的方法内容进行返回

``` C#
 public static string GetAssemblyName() 
        {
            return Assembly.GetExecutingAssembly().GetName().Name;  
        }
```

我们通过反射得到当前程序集信息,并且返回它的名字

只要书写上面的三步,我们就可以通过构造函数进行注入了

##### 6.7.9 AutoMapper

###### 1. 什么是AutoMapper

AutoMapper是一种对象映射器。对象-对象映射通过将一种类型的输入对象转换为另一种类型的输出对象来工作。使AutoMapper有趣的是，它提供了一些有趣的约定，以解决如果将类型A映射到类型B的繁琐工作。只要类型B遵循AutoMapper的既定约定，映射两种类型几乎需要零配置。

###### 2. 为什么使用AutoMapper

映射代码很无聊。测试映射代码甚至更无聊。AutoMapper提供了简单的类型配置，已经简单的映射测试。真正的问题可能是“为什么使用对象映射？”映射可以发生在应用程序中的许多地方，但大多发生在层之间的边界上，例如：UI/Domain层或服务/Domain层之间。一个层的关注点通常与另一个层的关注点冲突，因此对象-对象映射导致分离模型，其中每个层的关注点智能影响该层中的类型。

###### 3. 如何使用AutoMapper

首先，您需要同时使用源和目标类型。目标类型的设计可能受到其所在层的影响，但只要成员的名称与源类型的成员匹配，AutoMapper的效果最好。如果您有一个名为“FirstName”的目标成员。AutoMapper还支持展平。

将源映射到目标时，AutoMapper将忽略空引用异常。这是故意的。如果不喜欢这种方法，如果需要的话，可以将AutoMapper的方法与自定义解析器结合起来。

一旦有了类型，就可以使用MapperConfiguration和CreateMap为这两种类型创建一个映射。通常每个AppDomain只需要一个MapperConfiguration实例，应在启动期间实例化。在setup可以看到更多初始设置的示例。

例如：

``` c#
var config = new MapperConfiguration(cfg => cfg.CreateMap<Order,OrderDto>());
```

上面代码当中Order代表的是源类型，OrderDto是目标类型。要执行映射，请调用其中一个映射重载:

``` c#
var mapper = config.CreateMapper();
//或者下面的
//var mapper = new Mapper(config);
OrderDto dto = mapper.Map<OrderDto>(order);
```

大多数应用程序可以使用依赖注入来注入创建的IMapper实例。

对于编译时可能不知道类型的情况，AutoMapper也有这些方法的非泛型版本。

###### 4. .net 6中的automapper的使用步骤



(1) 在我们原来项目结构的基础上新增一个Common的类库，主要存放我们的一些工具类文件，例如：Md5Helper等,和我们要配置的Autofac

![](imgs/51.png)

(2) 我们需要先去Nuget当中进行安装AutoMapper的包

![](imgs/50.png)

之后，我们在这个类库下创建一个StudentsProfile的类，用于匹配所有的映射对象关系，在这个类当中我们首先就需要去继承一下Profile这个

> 因为这个里面要进行配置映射关系，别忘记了添加Dtos与Models的引用。

之后我们按照下面的示例代码进行配置即可

![](imgs/52.png)

(3) 我们在Web层当中引入Commons这层的内容，之后在Program.cs文件当中进行配置服务。

![](imgs/53.png)

##### 6.7.10 单元测试与集成测试

测试的编写在构建项目的时候就显得尤为重要，设计合理的测试代码不仅有助于发现及避免Bug，更可以为我们后续重构代码的工作提供便利，以免破坏现有功能或要引入新的问题。

###### 1. 单元测试

单元测试是短小的测试，也是检查单个方法或类的行为。当你测试的代码以来其他方法或类时，单元测试依赖于虚构(mocking)出来的其他类，以便在某一时刻把注意力专注在特定的一个点上。

当我们在写单元测试的时候，需要自己处理这个依赖图的场景，把测试的场景和逻辑同正式的接口代码逻辑隔离开来，这是很重要的！因为我们不能为了测试而一个不小心把测试数据顺带写到数据库里去。这里的做法一般是把数据放到内存中即可，毕竟测试的是代码和逻辑的正确性，连接数据库单独测试即可。

###### 2. 集成测试

集成测试的含义非常简单——将单元测试模块逐个集成/组合，并将行为测试为组合单元。

该测试的主要功能或目标是测试单元/模块之间的接口，是一个整体的模块，我们通常在"单元测试"之后进行集成测试。一旦创建并测试了所有单个单元，我们就开始组合这些"单元测试"模块并进行集成测试。

集成测试是很复杂的一件事，相对于单元测试，更需要一些开发和逻辑技能。那么我们为什么还需要做集成测试呢？

举例来说：我们在平时的开发中，一个庞大的应用程序被分解为更小的模块，并且为每个开发人员分配一个相对独立的模块，所以各自的逻辑和业务可能是完全不同的，那么开发好以后，这样保证别人开发的模块能应对自己的模块呢？换句话说，是否能保证项目可以正常地对接并运行成功呢。

另一方面，软件开发需求肯定不是一锤定音的，需要来来回回多次调整才能达到满意的效果，当数据从一个模块移动到另一个模块时，数据对象的结构和逻辑处理肯定会发生变化，这时候单元测试是没有问题的，但就更需要做集成测试了。

##### 6.7.11 SqlSugar

SqlSugar 自己官网上写的现在世界最好ORM框架(.Net)

SqlSugar 与我们之前所学的EF Core , Dapper相比区别在哪?

(1) SqlSugar当中是没有上下文的

(2) SqlSugar 当中也是不需要写Sql语句的

(3) SqlSugar它的效率基本与Dapper效率相同.

###### 使用步骤

(1) 创建SqlSugar的连接对象

``` c#
SqlSugarClient client = new SqlSugarClient(new ConnectionConfig
{
     ConnectionString = "连接数据库语句",
     DbType = DbType.对应要操作的数据库名字
     IsAutoCloseConnection = true //是否自动关闭连接    
});
```

(2) 编写CURD方法

``` C#
 public int AddAsync(T model) 
{
     return   client.Insertable<T>(model).ExecuteCommand();
}

public int EditAsync(T model) 
{
     return  client.Updateable<T>(model).ExecuteCommand();
}

public int DeleteAsync(T model) 
{
     return  client.Deleteable<T>(model).ExecuteCommand();
}

public List<T> QueryAsync() 
{
    return  client.Queryable<T>().ToList();
}

public  List<T> QueryAsync(Expression<Func<T, bool>> whereLambda) 
{
     return  client.Queryable<T>().Where(whereLambda).ToList();
}

public T QueryByIdAsync(Expression<Func<T, bool>> whereLambda) 
{
    return  client.Queryable<T>().Where(whereLambda).Single();
}
```

**上面的实用内容是在Wpf这种没有Program.cs需要配置的.net 6项目中**

###### Code First

步骤:

(1) Nuget 当中安装对应的包

​	 a. SqlSugarCore

​     b. System.Data.SqlClient 

(2) 去Models文件夹封装实体类,我们需要对列进行设定

```C#
        [SugarColumn(IsIdentity = true, IsPrimaryKey = true)]
        public int Id { get; set; }
        [SugarColumn(ColumnDataType = "nvarchar(50)")]
        public string Title { get; set; }

        public string Author { get; set; }

        public decimal Price { get; set; }

        public string Press { get; set; }
```

(3) 书写数据库上下文

``` c#
 public class SqlSugarDbContext
    {
        private ISqlSugarClient _db; //这个是数据库连接客户端的对象

        public SqlSugarDbContext(ISqlSugarClient db)
        {
            _db = db;
        }

        //我们需要写一个方法,用于迁移的时候创建表
        public void CreateTable() 
        {
            _db.DbMaintenance.CreateDatabase(); //没有数据库则新建一个数据库
            _db.CodeFirst.SetStringDefaultLength(50).BackupTable().InitTables(
                new Type[] 
                {
                    typeof(Books),
                }    
            );
        }

    }
```

(4) 去appsettings.json当中书写连接语句

``` json
"ConnectionStrings": {
    "ConStr": "server=.;database=BooksDb;uid=sa;pwd=11"
  }
```

(5) 去Program.cs当中进行注册SqlSugar上下文服务

``` C#
//这个是我们现在配置SqlSugar上下文的内容
builder.Services.AddSingleton(sp => new SqlSugarDbContext(
        new SqlSugarClient(new ConnectionConfig 
        {
            ConnectionString = builder.Configuration.GetConnectionString("ConStr"),
            DbType = DbType.SqlServer,
            IsAutoCloseConnection = true
        })    
    )
);
```

(6) 在执行方法的地方我们去调用数据库上下文当中的CreateTable(),这个就实现了数据迁移效果

###### DataBase First

这个内容的书写步骤基本与上面的code first一致,只是我们需要额外安装一个NuGet包和在数据库下文当中写的方法不同.

我们需要安装的包是 Newtonsoft.Json

我们去在数据库上下文档中创建一个根据数据库当中的表生成类的方法

``` C#
public void CreateClassFile() 
{
     _db.DbFirst.IsCreateAttribute().CreateClassFile("", "");
            //第一个参数是我们要把类文件创建到的路径
            //第二个参数是我们类文件默认带有的命名空间是什么
}
```



## 七. WebApi

#### 1. 项目的创建(带有Swagger)

我们需要先去安装Swagger这个程序员的帮助文档,我们可以在NuGet当中进行搜索Swashbuckle.AspNetCore包,之后进行安装

还和我们之前创建的MVC项目一样,创建一个 Asp.Net Core 空项目,之后自己去进行添加要使用的配置,配置内容稍微有些改变 ,下面的内容是Program.cs类的代码

``` C#
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddController(); 
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.MapControllers();
```

之后，我们还需要在launchSetting里面Profile下的两个运行模式下添加如下内容

``` C#
"launchUrl":"swagger"
```

我们在去创建对应的控制器，控制器的实现方式如下

``` C#
[ApiController]
[Route("[controller]/[action]")]
public class XxxController : Controller{
    [HttpGet]
    public List<Xxx> GetStudent()
    {
    	return .... ;    
    }   
}
```

#### 

#### 2. 授权与认证

##### 2.1 JWT权限验证

JWT，即JSON Web Token，它是一种基于JSON的、用于在网络上声明某种主张的令牌（Token）。

JWT通常由三部分组成:头部信息（Header），消息体（Payload），和签名（Signature）。它是一种用于双方之间传递安全信息的表述性声明规范。JWT作为一个开放的标准（RFC 7519），定义了一种简洁的、自包含的方法，从而使通信双方实现以JSON对象的形式安全地传递信息。

请求流程如下：

（1）客户端向授权服务系统发起请求，申请获取“令牌”

（2） 授权服务器根据用户身份，生成一张专属“令牌”，并将改“令牌”以JWT规范返回给客户端。

（3）客户端将获取到的“令牌”放到HTTP请求的Headers中后，向主服务系统发起请求。主服务系统受到请求后，会从Headers中获取“令牌”，并从“令牌”中解析出该用户的身份权限，然后做出相应的处理（同意或拒绝返回资源）。

![](imgs/32.png)

##### 2.2 生成一个令牌

整个过程可以分成4个步骤：

（1）我们需要一个具有一定规则的Token令牌，也就是JWT令牌（比如公司门禁卡——登录）。

（2）再定义哪些地方需要什么样的角色（比如领导办公室是没办法进去的——授权机制）。 

（3）整个公司需要定一个规则，就是如何对这个Token进行验证，不能随便写个字条，这样容易被造假（比如公司门上的每一道刷卡机——JwtBearer认证方案）

（4）最后，就是安全部门，开启认证中间件服务（这个服务是可以关闭，比如电影里看到的黑客会把这个服务给关掉，这样整个公司的安保系统就形同虚设了——开启中间件） 

**服务注册与参数配置**

新建一个类库——Common，在类库下新建Helper文件夹并创建Appsettings类，该类用于帮助读取appsettings.json中的系统配置参数。

> 通过Nuget安装 ：
>
> Microsoft.Extensions.Configuration;
>
> Microsoft.Extensions.Configuration.Abstractions;
>
> Microsoft.Extensions.Configuration.Json;
>
> Microsoft.Extensions.Configuration.Binder;
>
> 之后完成下面的Appsettings类

``` C#
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.Json;

public class Appsettings
{
    static IConfiguration Configuration{ get; set; }
    static string contentPath{ get; set; }
    
    public Appsettings(string contentPath)
    {
        string Path ="appsettings.json";
        //如果配置文件是根据环境变量来区分的，可以这样配置
        //Path = $"appsettings.{Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT")}.json";
        Configuration = new ConfigurationBuilder()
            			.SetBasePath(contentPath)
            		    .Add(new JsonConfigurationSource{
                            Path = Path , Optional = false , ReloadOnChange = true
                        }) //这样的话，可以直接读取目录里的json文件，而不是bin文件夹下的，所以不用修改复制属性
            			.Build();
    }
    
    public Appsettings(IConfiguration configuration)
    {
    	Configuration = configuration;    
    }
    
    
    public static string app(params string[] sections)
    {
        try
        {
            if(sections.Any())
            {
                return Configuration[string.Join(":",sections)];
            }
        }
        catch(Exception){}
        return "";
    }
    
    public static List<T> app<T>(params string[] sections)
    {
        List<T> list = new List<T>();
        Configuration.Bind(string.Join(":",sections),list);
        return list;
    }
}
 //之后我们需要在Program.cs注入Appsettings
 builder.Services.AddSingleton(new Appsettings(builder.Configuration));
```

在Helper文件夹下继续新建JwtHelper类。

通过NuGet安装System.IdentityModel.Tokens.Jwt，并完成JwtHelper类，代码如下

``` C#
using System.Security.Claims;
using System.IdentityModel.Tokens.Jwt;
using Microsoft.IdentityModel.Tokens;

public class JwtHelper
{
    public static string IssueJwt(TokenModelJwt tokenModel)
    {
        string iss = Appsettings.app(new string[] { "Audience" , "Issuer"});
        string aud = Appsettings.app(new string[] { "Audience" , "Audience"});
        string secret = Appsettings.app(new string[] { "Audience" , "Secret"});
        
        var claims = new List<Claim>
        {
            /*
            	特别重要： 这里将用户的部分信息，比如uid存到了Claim中，如果想知道如何在其他地方将这个uid从Token中取出来，请看下边的SerializeJwt()方法，或者在整个解决方案搜索这个方法。
            	也可以研究一下HttpContext.User.Claims，具体可以看看Policys/PermissionHandler.cs类中是如何使用的
            */
            new Claim(JwtRegisteredClaimNames.Jti,tokenModel.Uid.ToString()),
            //这个就是过期时间，目前是过期1000秒，可以自定义，注意JWT有自己的缓冲过期时间
             new Claim(JwtRegisteredClaimNames.Exp,$"{new DateTimeOffset(DateTime.Now.AddSeconds(1000)).ToUnixTimeSeconds()}"),
             new Claim(ClaimTypes.Expiration,DateTime.Now.AddSeconds(1000).ToString()),
             new Claim(JwtRegisteredClaimNames.Iss,iss),
             new Claim(JwtRegisteredClaimNames.Aud,aud),
        };
        //可以将一个用户的多个角色全部赋予；
        claims.AddRange(tokenModel.Role.Split(',').Select(s => new Claim(ClaimTypes.Role,s)));
        //密钥(SymmetricSecurityKey对安全性的要求，密钥的长度太短会报出异常)
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret));
        var creds = new SigningCredentials(key,SecurityAlgorithms.HmacSha256);
        var jwt = new JwtSecurityToken(
        	issuer:iss,
            claims:claims,
            signingCredentials:creds
        );
        var jwtHandler = new JwtSecurityTokenHandler();
        var encodeJwt = jwtHandler.WriteToken(jwt);
        return encodeJwt;	
    }
    
    public static TokenModelJwt SerializeJwt(string jwtStr)
    {
        var jwtHandler = new JwtSecurityTokenHandler();
        TokenModelJwt tokenModelJwt = new TokenModelJwt();
        if(!string.IsNullOrEmpty(jwtStr) && jwtHandler.CanReadToken(jwtStr))
        {
            JwtSecurityToken jwtToken = jwtHandler.ReadJwtToken(jwtStr);
            object role;
            jwtToken.Payload.TryGetValue(ClaimTypes.Role,out role);
            tokenModelJwt = new TokenModelJwt
            {
                Uid = Convert.ToInt64(jwtToken.Id),
                Role = role == null ? "" : role.ToString()
            }；
        }
        return tokenModelJwt;
    }
    
    public class TokenModelJwt
    {
        public long Uid{ get; set; }
        public string Role{ get;set; }
        public string Work{ get;set;}
    }    
}
```

写完上面的内容之后，我们还需要去完善一下appsettings.json的配置

``` json
"Audience":{
    "Secret" : "sdfsdsfsdskfnjsngj1235576knfkdnja", //不要太短，16位+
    "Issuer": "", //发行人
    "Audience":"wr" //接受者
}
```

##### 2.3 设计登录接口

我们需要在WebApi项目中添加引用，把上面写的Common层填入，并且在Controllers新建API控制器LoginController，具体代码如下：

``` C#
[Route("api/[controller]")]
[ApiController]
public class LoginController : ControllerBase
{
    //获取Jwt令牌
    [HttpGet]
    public async Task<object> GetJwtStr(string name,string pass)
    {
        //将用户id和角色名作为单独的定义变量，封装进token字符串中。
        TokenModelJwt tokenModel = new TokenModelJwt{ Uid = 1,Role = "Admin"};
        var jwtStr = JwtHelper.IssueJwt(tokenModel); //登录，获取到一定规则的Token令牌
        var suc = true;
        return Ok(new {
           	success = suc,
            token = jwtStr;
        });
    }
        
}
```

##### 2.4 JWT授权认证操作

我们接下来要做的是JWT授权认证操作，要实现这个功能，我们必须要进行输入Token，按照原来的技术，我们需要通过Postman(一个提交工具)软件来进行控制输入，但是现在因为我们配置了Swagger，所以就不需要了，直接用Swagger来进行操作。

我们现在需要在Nuget中安装Swashbuckle.AspNetCore.Filters，Microsoft.AspNetCore.Authentication.JwtBearer ，这两个包，之后我们需要在Program.cs当中完成下列配置

``` C#
using Common.Helper;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.OpenApi.Models;
using Swashbuckle.AspNetCore.Filters;
using System.Text;
using Microsoft.IdentityModel.Tokens;

var builder = WebApplication.CreateBuilder(args);



builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
//这个是开启授权验证的服务
builder.Services.AddAuthentication(
    x => {
        x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    }
).AddJwtBearer(o => {
    //读取配置文件
    var audienceConfig = builder.Configuration.GetSection("Audience");
    var symmetricKeyAsBase64 = audienceConfig["Secret"];
    var keyByteArray = Encoding.ASCII.GetBytes(symmetricKeyAsBase64);
    var signingKey = new SymmetricSecurityKey(keyByteArray);

    o.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = signingKey,
        ValidIssuer = audienceConfig["Issuer"], //发行人
        ValidateAudience = true,
        ValidAudience = audienceConfig["Audience"], //订阅人
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero, //这个是缓冲过期时间，也就是说，即使我们配置了过期时间，这里也要考虑进去，过期时间+缓冲，默认好像是7分钟，你可以直接设置为0
        RequireExpirationTime = true
    };   
});

//下面的是注册验证登入权限角色的服务
builder.Services.AddAuthorization(
    options => 
    {
        options.AddPolicy("Client", policy => policy.RequireRole("Client").Build()); //单独角色
        options.AddPolicy("Admin", policy => policy.RequireRole("Admin").Build());
        options.AddPolicy("SystemOrAdmin", policy => policy.RequireRole("Admin","System")); //或者关系
        options.AddPolicy("SystemAndAdmin",policy => policy.RequireRole("Admin").RequireRole("System")); //并且关系

    }) ;
//下面的内容是给我们的控制添加登入约束的，只有符合验证身份的，才能使用，添加一个锁的机制
builder.Services.AddSwaggerGen(
        c =>
        {
            //开启小锁
            c.OperationFilter<AddResponseHeadersFilter>();
            c.OperationFilter<AppendAuthorizeToSummaryOperationFilter>();

            //在Headers中添加token，传递到后台
            c.OperationFilter<SecurityRequirementsOperationFilter>();
            c.AddSecurityDefinition("oauth2", new OpenApiSecurityScheme
            {
                Description = "JWT授权（数据将在请求头中进行传输）直接在下框中输入Bearer {token}（注意两者之间是一个空格）",
                Name = "Authorization",
                In = ParameterLocation.Header, //jwt默认存放Authorization信息的位置（请求头中）
                Type = SecuritySchemeType.ApiKey
            });

        });
//之后我们需要在Program.cs注入Appsettings
builder.Services.AddSingleton(new Appsettings(builder.Configuration));



var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseAuthentication(); //先开启认证
app.UseAuthorization(); //然后是授权中间件

app.MapControllers();

app.Run();

```

##### 2.5 核心知识梳理

###### 2.5.1 什么是Claim

Claim本身是要求，主张，应用的意思。

Asp.Net Core的验证模式是Claims Based Authentication。Claim是对被验证主体特征的一种表述，比如登录用户名是···，email是···，用户Id是····，其中的“登录用户名” “email” "用户Id" 就是 ClaimType。

对应现实中的事物，比如驾照，驾照中的“身份证号码：xxx”是一个claim，“姓名：xxx”是另一个claim。

一组Claims构成了一个Identity，具有这些Claims的Identity就是ClaimsIdentity,驾照就是一种ClaimsIdentity，可以把ClaimsIdentity理解为“证件”，驾照是一种证件，护照也是一种证件。

ClaimsIdentity的持有者就是ClaimsPrincipal，一个ClaimsPrincipal可以持有多个ClaimsIdentity，比如一个人既持有驾照，又持有护照。

理解了Claim、ClaimsIdentity、ClaimsPrincipal这三个概念，就能理解生产登录Cookie为什么要用下面的代码了。

``` C#
var claimsIdentity = new ClaimsIdentity(new Claim(ClaimTypes.Name,loginName),"Basic");
var claimsPrincipal = new ClaimsPrincipal(claimsIdentity);
await context.Authentication.SignInAsync(_cookieAuthOptions.AuthenticationScheme,claimsPrincipal);
```

要用Cookie代表一个通过的验证的主体，必须包含Claim、ClaimsIdentity、ClaimsPrincipal这三个信息，以一个持有合法驾照的人为例，ClaimsPrincipal就是持有证件的人，ClaimsIdentity就是证件，“Basic”就是证件类型(这里假设是驾照)，Claim就是驾照中的信息。

###### 2.5.2 了解Bearer认证

HTTP提供了一套标准的身份验证框架。服务器可以用来针对客户端的请求发送质询(Challenge)，客户端根据质询提供身份验证凭证。质询与应答的工作流程如下：服务器端向客户端返回401(Unauthorized,未授权)状态码，并在WWW-Authenticate中添加如何进行验证的信息，其中至少包含有一种质询方式。然后客户端可以在请求中添加Authorization头进行验证，其Value为身份验证的凭证信息。

在HTTP标准验证方案中，我们比较熟悉的是“Basic”和“Digest”,前者将用户名，密码使用BASE64编码后作为验证凭证，后者是Basic的升级版，更加安全，因为Basic是明文传输密码信息，而Digest是加密后传输。在前面介绍的Cookie认证属于Form认证，并不属于HTTP标准验证。

Bearer验证也属于HTTP协议标准验证，它随着OAuth协议而开始流行。

Bearer验证中的凭证称为BEARER_TOKEN，或者是access_token，它的颁发和验证完全由自己的应用程序来控制，而不依赖于系统和Web服务器，Bearer验证的标准请求方式如下：

``` C#
Authorization:Bearer[BEARER_TOKEN]
```

**使用Bearer验证的好处：**

(1) CORS： Cookies + CORS并不能跨不同的域名。而Bearer验证在任何域名下都可以使用HTTP Header头部来传输用户信息。

(2) 对移动端友好：当在一个原生平台（IOS、Android、Windows Phone 等）时，使用Cookie验证并不是一个好主意，因为我们需要和Cookie容器打交道，而使用Bearer验证则简单得多。

(3) CSRF：因为Bearer验证不再依赖与Cookies，也就避免了跨站请求攻击

(4) 标准：在Cookies认证中，用户未登录时，返回一个302到登录页面，这在非浏览器情况下很难处理，而Bearer验证则返回的是标准的401Challenge。

###### 2.5.3 JWT(JSON Web Token)

上面介绍的Bearer认证，其核心便是BEARER_TOKEN，而最流行的Token编码方式便是：JSON Web Token。

JSON Web Token（JWT），是为了在网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519）。该Token被设计为紧凑且安全的，特别适用于分布式站点的单点登录(SSO)场景。JWT的声明一般被用来在身份提供者和服务者之间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其他业务逻辑所必需的声明信息，该Token也可直接被用于认证，也可被加密。

JWT分割由如下三部分组成：

**1. 头部（Header）**

Header一般由两个部分组成:alg , typ

alg是所使用的hash算法，如HMAC SHA256 或 RSA，typ是Token的类型，在这里就是JWT。

``` json
｛
	"alg":"HS256",
	"typ":"JWT"
｝
```

之后使用Base64Url编码成第一部分:

``` base64
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<second part>.<third part>
```

**2. 载荷(Payload)**

这是JWT主要的信息存储部分，其中包含了许多声明(Claims)。

Claims的实体一般包含用户和一些元数据，这些Claims分成三种类型:

（1）reserved claims：预定义的一些声明，并不是强制的，但是推荐使用，他们包括iss（issuer）、exp（expiration time）、sub（subject）、aud（audience）等（这里都是用三个字母的原因是保证JWT的紧凑）。

（2）public claims：公有声明，这个部分可以随便定义，但是要注意和IANA JSON Web Token冲突。

（3）private claims：私有声明，这个部分是共享被认定信息中自定义的部分。

一个简单的Payload可以使这样的：

``` json
｛
	"sub":"1234567890",
	"name":"John Doe",
	"admin":true
｝
```

这部分同样适用Base64Url编码成第二部分:

``` base64
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.<third part>
```

**3. 签名（Signature）**

Signature是用来验证发送者的JWT的同时，也能确保在期间不被篡改。

在创建该部分时，你应该已经有了编码后的Header和Payload，然后适用保存在服务端的密钥对其签名即可，一个完整的JWT如下:

``` base64
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

使用JWT具有如下好处：

（1）通用：因为JSON的通用性，所以JWT是可以进行跨语言支持的，像Java、JavaScript、NodeJS、PHP等很多语言都可以被使用。

（2）紧凑：JWT的构成非常简单，字节占用很小，可以通过GET、Post等放在HTTP的Header中，非常便于传输。

（3）扩展：JWT包含了必要的所有信息，不需要再服务端保存会话信息，非常易于应用的扩展。



#### 3. 跨域Cors

指的是有两个请求路径的项目、

（1） 前端项目

​          (1) VS Code需要安装 Live Server

​          (2) Ajax请求

​              （a） 原生对象请求

​              （b） Jquery封装

​              （c） Promise

​         (3) Vue.js

 当我们前端界面制作完成之后，需要进行记录运行之后的网址信息 ip:端口号

（2） WebApi

当我们现在前后端项目都创建完成，启动的时候会报错，

![](imgs/33.png)

这个错误信息提示我们请求的内容头部信息当中缺少“Access-Control-Allow-Origin”,解决方式有一种就是在前端请求Ajax的时候直接把这个头部信息配置进去，但是我们正常写的跨域不这么玩。

我们只需要在Program.cs文件当中注册跨域服务和中间件即可。

我们需要去Program.cs当中进行配置

首先配置服务

``` C#
builder.Services.AddCors(options => 
       options.AddPolicy("自己起的名字",
           builder => 
            builder.WithOrigin("允许的访问路径（允许多个值通过逗号相隔）")
              .AllowAnyOrigin() //允许任何路径进行访问，这个与上面的要求只能写一个
              .AllowAnyHeader() //允许所有的头部信息进行访问
              .AllowAnyMethod() //允许所有的提交方式进行访问           
  )
);
```

我们还需要在下面进行配置中间件

``` C#
app.UseCors("服务里起的名字");
```

#### 4. 日志--NLog

1. 我们去Nuget当中安装Nuget的包

> NLog.Extensions.Loggin

2. 我们去当前项目的根目录下配置一下日志信息

``` xml
<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"
      autoReload="true"
      throwExceptions="false"
      internalLogLevel="Off" internalLogFile="c:\temp\nlog-internal.log">

	<variable name="myvar" value="myvalue"/>
	<targets>
		<target xsi:type="File" name="f" fileName="${basedir}/logs/${shortdate}.log"
			  layout="${longdate} ${uppercase:${level}} ${message}"
				maxArchiveFiles="999"
			  archiveAboveSize="10485760"/>
	</targets>
	<rules>
		<logger name="*" minlevel="Debug" writeTo="f" />
	</rules>
</nlog>
```

这段xml文件代码主要是对我们日志输出时的配置，里面有具体的输出信息格式。

3. 我们去Program.cs当中进行注册，让我们这次安装的NLog与微软自带的ILogger联动。

``` c#
builder.Services.AddLogging(m => { m.AddNLog(); });
```

4. 在我们想要使用日志的控制器当中先去声明一个日志的字段，之后通过构造函数进行注入，之后我们就去正常调用即可。

``` C#
private ILogger _logger;
        public HomeController(ILogger<HomeController> logger)
        {
            _logger = logger;
        }

        public IActionResult Index()
        {
            NLog.LogManager.GetCurrentClassLogger().Info("ddd");
            _logger.LogInformation("this is test");
            return View();
        }
```

我们可以根据实际情况去更改_logger后面的方法，实现跟踪记录不同程度的信息。

>debugger   调试
>
>information 信息
>
>warning      警告
>
>error           错误

#### 5. Identity框架

Authentication    验证,它用来对访问者的用户什么进行验证

Authorization     授权,它用来验证访问者的用户身份是否有对资源机芯访问的权限

Asp.Net Core 提供了标识框架(Identity),它采用了RBAC(Role-Based Access Control,基于角色的访问控制)策略,
内置了对用户,角色等表的管理以及相关的接口.Identity框架还提供了对外部登录(比如QQ登入,微信登入等等)的支持

标识框架提供了IdentityUser\<TKey>和IdentityRole\<TKey>两个实例类型,其中的TKey用于设定是主键的类型

##### 操作步骤

1. 创建项目  ---> WebApi

2.  添加NuGet包
        Microsoft.EntityFrameworkCore
        Microsoft.EntityFrameworkCore.SqlServer
        Microsoft.EntityFrameworkCore.Tools
        Microsoft.AspNetCore.Identity.EntityFrameworkCore 

3. 添加Models文件夹,实现封装类的操作   

4. 创建数据库上下文 
   我们原来的数据库上下文继承的是DbContext,但是当我们现在用Identity,那么这个地方我们就需要
    更改一下,把继承的父类更改为IdentityDbContext<User,Role,int>    

5. 配置信息

  (a) 创建数据库链接语句  appsettings.json
  (b) 去Program.cs类当中配置数据库上下文的内容

 RoleManager  UserManager   ---> 这个是Identity框架给我们自带的两个内容,他们帮助我们来进行数据库操作的内容(指的是2个表User,Role),他们当中封装了大量的方法

   RoleManager当中常用的方法:

| 方法                                          | 说明                       |
| --------------------------------------------- | -------------------------- |
| Task\<IdentityResult> CreateAsync(TRole role) | 创建角色                   |
| Task\<IdentityResult> DeleteAsync(TRole role) | 删除角色                   |
| Task\<bool> RoleExistsAsync(string roleName)  | 指定名字的角色是否存在     |
| Task\<TRole> FindByNameAsync(string roleName) | 根据名字的角色获取角色对象 |

UserManager当中常用的方法

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Task\<IdentityResult> CreateAsync(TUser user,string password) | 创建用户,由于数据库中用户的密码是保存的哈希值,IdentityUser类中没有明文密码,因此我们需要通过第二个参数指定明文密码,由此方法完成密码的哈希计算 |
| Task\<IdentityResult> UpdateAsync(TUser user)                | 更新用户                                                     |
| Task\<IdentityResult> DeleteAsync(TUser user)                | 删除用户                                                     |
| Task\<TUser> FindByIdAsync(string userId)                    | 根据ID获取用户                                               |
| Task\<TUser> FindByNameAsync(string userName)                | 根据用户名获取用户                                           |
| Task\<TUser> FindByEmailAsync(string email)                  | 根据用户的邮件获取用户                                       |
| Task\<bool> CheckPasswordAsync(TUser user,string pwd)        | 检查用户使用pwd这个密码是否能登入成功,建议如果检查失败则调用AccessFailedAsync方法以记录失败的次数,这样当登入失败次数过多的时候,框架会自动把账号锁定,以避免账户被暴力破解 |
| Task\<IdentityResult> ChangePasswordAsync(TUser user,string currentPassword,string new password) | 修改用户的密码,其中currentPassword参数指旧的密码,newPassword参数指新的密码 |
| Task\<string> GeneratePasswordResetTokenAsync(TUser user)    | 由于通过ChangePasswordAsync修改密码需要输入旧密码,因此如果用户忘记了旧密码,则可以使用GeneratePasswordResetTokenAsync方法来生成一个比较复杂的字符串作为令牌,然后把这令牌通过邮箱,短信等方式发送给用户,要求用户填写收到的令牌,在调用ResetPasswordAsync方法来重置密码 |
| Task\<IdentityResult> ResetPasswordAsync(TUser user,string token,string newPassword) | 重置用户密码.其中token参数为GeneratePasswordResetTokenAsync方法生成的令牌,newPassword参数为新密码,token这个参数需要由客户提供 |
| Task\<IdentityResult> AddToRoleAsync(TUser user,string roleName) | 为用户增加名字为roleName的角色                               |
| Task\<IdentityResult> RemoveFromRoleAsync(TUser user,string role) | 为用户删除名字为role的角色                                   |
| Task\<IList\<string>> GetRolesAsync(TUser user)              | 获取用户拥有的所有角色的名字                                 |
| Task\<bool> IsInRoleAsync(TUser user,string role)            | 判断用户是否拥有指定的角色                                   |
| Task\<bool> IsLockedOutAsync(TUser user)                     | 判读用户是否被锁定                                           |
| Task\<DateTimeOffset?> GetLockoutEndDateAsync(TUser user)    | 获取用户被锁定的结束时间                                     |
| Task\<IdentityResult> SetLockoutEndDateAsync(TUser user,DateTimeOffset? lockoutEnd) | 设置用户被锁定的结束时间                                     |
| Task\<IdentityResult> AccessFailedAsync(TUser user)          | 记录一次"用户登录失败",一般在处理用户登录的时候,如果尝试登录失败,我们就应该调用一次AccessFailedAsync.当多次登录失败的时候,用户就会被临时锁定一段时间,以避免账户被暴力破解 |

> IdentityResult这个是我们上面部分方法的返回值类型,这个类型当中包含了bool类型Succeeded属性,表示操作成功;如果操作失败,我们可以从Errors属性中获取错误的详细信息,其中主要包含了code(错误码),Description(错误的详细信息)

(6) 去实现对应的功能,如新增角色,新增用户信息

---

##### 代替Session(会话)的JWT

JWT全称 JSON Web Token

JWT的结构:

(1) 头部(header): 保存加密算法说明的

(2) 负载(payload):保存的使用户信息(用户的id,用户名,角色等)

(3) 签名(signature): 根据头部和负载一起算出来的值

**JWT实现登录的流程**

* 客户端向服务器端发送用户名和密码等请求登录
* 服务器端校验用户名,密码,如果校验成功,则从数据库中取出这个用户的ID,角色等用户信息
* 服务器端采用只有服务器端才知道的密钥来对用户信息的JSON字符串进行签名,形成签名数据
* 服务器端把用户信息的JSON字符串和签名拼接到一起形成JWT,然后发送给客户端
* 客户端保存服务器端返回的JWT,并且在客户端每次向服务器端发送请求的时候都带上这个JWT
* 每次服务器端接收到浏览器请求中携带的JWT后,服务器端用密钥对JWT的签名进行校验,如果校验成功,服务器端则从JWT中的JSON字符串中读取用户信息.这样服务器端就知道这个请求对应的用户了,也就是实现了登录的功能.

**JWT的基本应用**

(1)  安装NuGet包

​       Microsoft.Extensions.Configuration

​       Microsoft.Extensions.Configuration.Abstractions

​       Microsoft.Extensions.Configuration.Binder

​       Microsoft.Extensions.Configuration.Json

​       System.IdentityModel.Tokens.Jwt 

(2) 创建一个Jwt所对应的类，里面封装两个属性，分别对应签名和过期时间

``` C#
public class JWTOptions
{
    public string SigningKey{ get;set; }
    
    public int ExpireSeconds{ get;set; }
    
}
```

(3) 我们在登录方法的登录成功的情况下，添加对JWT的配置

​     （a） 首先我们去创建一个私有的方法，用于生成Token

       ``` C#
       //用于让我们生成Token
               private static string BuildToken(IEnumerable<Claim> claims, JWTOptions options) 
               {
                   //1. 设定过期时间
                   DateTime expire = DateTime.Now.AddSeconds(options.ExpireSecondss);
                   //2. 把登入时得到签名内容转换为字节数组
                   byte[] bytes = Encoding.UTF8.GetBytes(options.SigninKey);
                   //3. 加密字节数组
                   var secKey = new SymmetricSecurityKey(bytes);
                   //4. 转换为可信数据
                   var credentials = new SigningCredentials(secKey,SecurityAlgorithms.HmacSha256Signature);
                   //5. token的配置
                   var tokenDescriptor = new JwtSecurityToken(expires: expire,
                                           signingCredentials: credentials,
                                           claims: claims
                                          );
                   //6. 转换token并且返回这个内容
                   return new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);
               }
       ```

​         （b）在登录成功的情况下，书写下面的代码

``` C#
//下面开始配置我们当前登入用户信息的宣告
            var claims = new List<Claim>();
            claims.Add(new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()));
            claims.Add(new Claim(ClaimTypes.Name, user.UserName));

            // 获取当前登入用户的角色
            var roles = await _userManager.GetRolesAsync(user);
            foreach (string item in roles)
            {
                claims.Add(new Claim(ClaimTypes.Role, item));
            }
            //根据我们得到jwt选项和声明信息得到Token
            var jswToken = BuildToken(claims, jswOption.Value);
            return Ok(jswToken);
```

 (4)  去appsettings.json文件中对JWT进行配置

``` json
  "JWT": {
    "SigninKey": "自己随便输入不要太短",
    "ExpireSeconds": "设定的过期时间，单位是秒"
  }
```

（5）去Program.cs当中注册服务，和开启中间件

​         (a) 首先更改Swagger的配置，让Swagger当中带有验证的锁，我们需要对Swagger的AddSwaggerGen方法进行更改，代码如下：

``` C#
builder.Services.AddSwaggerGen(
    c => 
    {
        var scheme = new OpenApiSecurityScheme() 
        {
            Description="Authorization header: \r\n Example:'Bearer 12345667asdasd",
            Reference = new OpenApiReference 
            {
                Type = ReferenceType.SecurityScheme,Id = "Authorization"
            },
            Scheme ="oauth2",Name= "Authorization",
            In = ParameterLocation.Header,Type=SecuritySchemeType.ApiKey
        };
        c.AddSecurityDefinition("Authorization", scheme);
        var requirement = new OpenApiSecurityRequirement();
        requirement[scheme] = new List<string>();
        c.AddSecurityRequirement(requirement);
    }    
);
```

​         （b）添加JWT的Token设定

``` c#
builder.Services.AddIdentityCore<User>(
    option => 
    {
        option.Password.RequireDigit = false;
        option.Password.RequireLowercase = false;
        option.Password.RequireNonAlphanumeric = false;
        option.Password.RequireUppercase = false;
        option.Password.RequiredLength = 6;
        option.Tokens.PasswordResetTokenProvider = TokenOptions.DefaultEmailProvider;
        option.Tokens.EmailConfirmationTokenProvider = TokenOptions.DefaultEmailProvider;
    }    
);
```

 	   （c） 添加JWT的服务

``` C#
builder.Services.Configure<JWTOptions>(builder.Configuration.GetSection("JWT"));

//我们开始配置Bearer

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(
        x =>
        {
            var jwtOption = builder.Configuration.GetSection("JWT").Get<JWTOptions>();
            byte[] bytes = Encoding.UTF8.GetBytes(jwtOption.SigninKey);
            var secKey = new SymmetricSecurityKey(bytes);
            x.TokenValidationParameters = new()
            {
                ValidateIssuer = false,
                ValidateAudience = false,
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = secKey
            };
        }

    );
```

​		（d）确保有下面的两个中间件

``` C#
app.UseAuthentication();
app.UseAuthorization();
```



#### 6.  DDD 领域驱动设计

微服务架构是目前系统设计的主流架构，而DDD(domain-driven design，领域驱动设计)是设计一个优秀的微服务架构的指导思想。然而，由于DDD概念过于抽象，而且没有一个标准的实现方式，很多开发人员对DDD有不同的理解和现实，因此开发人员入门DDD的时候，可能会感觉迷茫和无助。

所以我们首先需要了解DDD的基本概念

##### （1）什么是微服务

传统的软件项目大部分都是单体结构，也就是项目中的所有代码都放到同一个应用程序中，一般它们也都运行在同一个进程中。

![](imgs/64.png)

单体结构的项目由结构简单，部署简单等优点，但是有如下的缺点:

* 代码之间耦合严重，代码的可维护性低。
* 项目只能采用但一个语言和技术栈，甚至采用的开发包的版本都必须统一
* 一个模块的崩溃就会导致整个项目的崩溃
* 我们只能整体进行服务器扩容，无法对其中一个模块进行单独的服务器扩容
* 当需要更新某一个功能时，我们需要把整个系统重新部署一遍，这会导致新功能的上线流程边长。

微服务加固把项目拆分位多个应用程序，每个应用程序单独构建和部署。

![](imgs/65.png)

微服务架构由如下的优点：

* 每个微服务只负责一个特定的业务，业务逻辑清晰，代码简单，对于其他微服务的依赖非常低，因此易于开发和维护。
* 不同的微服务可以用不同的语法和技术栈开发。
* 一个微服务的运行不会影响其他微服务
* 可以对一个特定的微服务进行单独扩容
* 当需要更新某一个功能的时候，我们只需要重新部署这个功能所在的微服务即可，不需要重新部署整个系统。

当然，万事万物都不会只有优点没有缺点，微服务架构的缺点如下：

* 在单体结构中，运维人员只需要保证一个应用的正常运行即可，而在微服务架构中，运维人员需要保证多个应用的正常运行，这给运维工作带来了更大的挑战。
* 在单体结构中，各模块之间时进程内调用，数据交互效率高，而在微服务架构中，各微服务之间要通过网络进行通信，数据交互的效率低。
* 在单体结构中，各模块之间的调用都是在进程内进行的，实现容错，事务一致性等比较容易，而在微服务架构中，各微服务之间通过网络通信，实现容错，事务一致性等非常困难

##### （2）什么是DDD

DDD的应为全称是domain driven design ，翻译成中文就是“领域驱动设计”。这里面的主干词是“设计”，也就是说DDD是一种设计思想。这里的形容词是“领域驱动”，那么什么是“领域”呢？

领域其实指的就是业务，因此DDD其实就是一种用业务驱动的设计。传统的软件设计把业务和实现技术割裂，在系统的需求设计完成后，技术人员把业务人员描述的需求文档转换位代码去实现，业务人员和技术人员对系统的理解并不完全匹配。随着系统的升级，技术人员对代码进行修改，业务人员和技术人员对系统的理解偏差越来越大，从而造成系统的扩展性、可维护性越来越差。而DDD则是指在项目的全生命周期内，管理、产品、技术、测试、实施、运维等所有岗位的人员都基于对业务的相同理解来开展工作，技术人员在把业务落地位设计、代码的时候，也直接把业务映射到代码中，而不是用代码去实现业务。DDD的核心理念就是所有人员站在用户的角度、业务的角度去思考问题，而不是站在技术的角度思考问题。

##### （3）领域与领域模型

“领域”(domain)是一个比较宽泛的概念，主要指的是一个组织作的所有事情。

> 例如：一家银行做的所有事情就是银行的领域。为了缩小讨论问题的范围，我们同窗会把领域细分为多个“子领域”（简称“子域”），比如银行的领域就可以划分为“对公业务子域”，“对私业务子域”，“内部管理子域”等，子域还可以继续划分位更细粒度的子域，比如“对私业务子域”分为“柜台业务子域”，“ATM业务子域”，“网银业务子域”等。



##### (4) DDD的实现

###### A.  贫血模型与充血模型

在面向对象的设计中有贫血模型和充血模型两种风格。

贫血模型：一个类中只有属性或者成员变量，没有方法

充血模型：一个类中既有属性、成员变量，也有方法。

例如： 我们需要定义一个类，这个类中可以保存用户名，密码，积分；用户必须具有用户名；为了保证安全，密码采用密码的哈希值保存；用户的积分为10；每次登录成功奖励5积分，每次登录失败扣3个积分(这样的需求肯定是不合理的，这里只是为了方便演示而已)

如果采用贫血模型，代码如下：

``` C#
public class User
{
    	public string UserName{ get; set; }
    	public string PasswordHash{ get;set;}
    	public int Credit{ get;set; }
    
}
```

 这是一个典型的只包含属性，不包含逻辑方法的类，这样的类通常被叫做POCO类，这就是典型的“贫血模型”。使用这样的类，我们编写代码来进行用户创建，登录，积分变动操作，例如：

``` C#
User u1 = new User();
u1.User.Name = "张三";
u1.Credit = 10;
u1.PasswordHash  = HashHelper.Hash("123456"); //HashHelper是用于hash加密的类
string pwd  = Console.REadLine();
if(HashHelper.Hash(pwd) == u1.passwordHash)
{
	u1.Credit += 5;
    Console.WriteLine("登录成功");
}
else
{
    if(u1.Credit < 3)
        Console.WriteLine("积分不足，无法扣减");
    else
    {
        u1.Credit -= 3;
        Console.WriteLine("登录成功");
    }
    Console.WriteLine("登录失败");
    
}
```

当我们使用充血模型创建User类，代码如下：

``` C#
public class User
{
    public string UserName{ get;set; }
    public int Credit{ get; private set;}
    private string? passwordHash;
    public User(string userName)
    {
        this.UserName = userName;
        this.Credit = 10;
    }
    
    
    public void ChangePassword(string newValue)
    {
        if(newValue.Length < 6)
        {
            throw new ArgumentException("密码太短");
        }
        this.passwordHash = HashHelper.Hash(newValue);
    } 
    
    public bool CheckPassword(string password)
    {
        string hash = HashHelper.Hash(password);
        return passwordHash = hash;
    }
    
    public void DeductCredits(int delta)
    {
        if(delta <= 0)
        {
            throw new ArgumentException("额度不能为负值");
        }
        this.Credit -= delta;
    }
    
    public void AddCredits(int delta)
    {
        this.Credit += delta;
    }
}
```

经过User类的封装，我们把应该封装到User类中的行为都隐藏到了User类中，类的使用者需要了解的领域知识非常少。下面代码为调用新版的User类。

``` C#
User u1 = new User();
u1.ChangePassword("123456");
string pwd = Console.ReadLine();
if(u1.CheckPassword(pwd))
{
    u1.AddCredits(5);
    Console.WriteLine("登录成功");
}
else
{
    u1.DeductCredits(3);
    Console.WriteLine("登录失败");
}
```

根据上面的代码书写，我们可以看到User类的使用者的工作量减少了很多，他们需要了解的领域知识也少了很多。

**贫血模型和充血模型有什么区别呢**

首先，从代码的角度来讲，把本应该属于User类的行为封装到User类中，这是符合“单一职责原则”的，当系统中其他地方需要调用User类的时候就可以复用User中的方法。其次，贫血模型是站在开发人员的角度思考问题的，而充血模型是站在业务的角度思考问题的。领域专家不明白什么是“把用户输入的密码进行哈希运算，然后把哈希值保存起来”，但是他们明白“修改密码、检查密码成功”等充血模型反映出来的概念，因此领域模型中的所有行为应该有业务价值，而不应该只是反映数据属性。

> 尽管充血模型带来的好处更明显，但是贫血模型依然很流行，其根本原因就是在于早期的很多持久性框架（比如ORM等）要求实体类的所有属性必须是可读可写的，而且我们可以很简单地把数据库中的表按照字段逐个映射为一个贫血模型的POCO类，这样“数据库驱动”的思维方式更简单直接，因此我们就见到“到处都是贫血模型”的情况了。
>
> **目前大部分主流的持久性框架都已经支持充血模型的写法了，比如：EF Core对充血模型的支持就非常的好**

**EF Core 对实体类属性操作的秘密**

EF Core对实体类属性的读写操作有一个非常不容易被发现的密码，了解这个秘密之火，我们能更好地在EF Core中实现充血模型。

按照常规的面向对象的要求，对于属性的读写操作都要通过get、set代码块进行，因此当我们通过EF Core 把实体类对象写入数据库或者把数据从数据库中加载到实体类对象的时候，EF Core也应该通过实体类对象的属性get、set进行属性的读写。但是基于性能和对特殊功能支持的考虑，EF Core在读写属性的时候，如果可能，它会直接跳过get、set，而直接操作真正存储属性值的成员变量。

例如：我们定义一个实体类Dog

``` C#
public class Dog
{
    public long Id{ get;set; }
    private string name;
    public string Name
    {
        get
        {
            Console.WriteLine("get被调用");
            return name;
        }
        set
        {
            Console.WriteLine("set被调用");
            this.name = value;
        }
    }
}
```

Dog类只有Id，Name两个属性：为了方便我们观察代码对Name属性的get、set代码块的调用情况，我们编写Name属性的代码时没有使用{ get;set; }这样简化的语法，而是使用完全的get,set代码块，把属性的值显式地保存到名字为name的成员变量中，并且在get和set代码块中都加入了调试输出信息。

EF Core当中实现充血模型中的实体类和POCO类相比，有如下的特征：

（1）属性是只读的或者只能被类内部的代码修改。

（2）定义了有参构造方法。

（3）有的成员变量没有对应属性，但是这些成员变量需要映射为数据库表中的列，也就是我们需要把私有成员变量映射到数据库表中的列。

（4）有的属性是只读的，也就是它的值是从数据库读取出来的，但是我们不能修改属性值。

（5）有的属性不需要映射到数据列，仅在运行时被使用。

要避免开发人员调用实体类的午餐构造方法，保证EF Core 能正确地从数据库中读取数据并赋值给实体类对象，我们有如下两种实现方式：

* 实体类中可以定义无参构造方法，但是午餐构造方法定义为private。由于开发人员无法直接调用私有的午餐构造方法，而只能调用有参构造方法，这样就可以避免开发人员创建包含非法属性值的对象；EF Core可以调用私有构造方法，因此EF Core在从数据库中加载数据到实体类对象的时候，会调用这个私有构造方法创建实体类的对象，然后对各个属性机械能赋值。
* 实体类中不定义无参构造方法，只定义有意义的有参构造方法，但是要求构造方法中的参数的名字和属性的名字一致。无论是开发人员还是EF Core加载数据的时候，都调用这些无参构造方法来完成对象的初始化。

下面通过User类来综合演示这5种特征的实现。

``` C#
public class User
{
    public int Id{ get; init; }                       //特征一
    public DateTime CreatedDateTime { get;set; }      //特征一
    public string UserName{ get; private set; }       //特征一
    public int Credit{ get; private set; }            //特征一
    
    private string? passwordHash;                     //特征三
    private string? remark;
    
    public string? Remark                             //特征四
    {
        get{ return remark; }
    }
    
    public string? Tag { get;set; }                   //特征五
    
    private User()                                    //特征二
    {
        
    }
    
    public User(string yhm)                           //特征二
    {
        this.UserName = yhm;
        this.CreatedDateTime = DateTime.Now;
        this.Credit = 10;
    }
    
    public void ChangeUserName(string newValue)
    {
        this.UserName = newValue;
    }
    
    public void ChangePassword(string newValue)
    {
        if(newValue.Length < 6)
        {
            throw new ArgumentException("密码太短");
        }
        this.passwordHash = HashHelper.Hash(newValue);
    }
}
```



 #### 7. SignalR 服务器消息推送

在传统的HTTP中，只能客户端主动向服务器段发起请求，服务器端无法主动向客户端发送消息。有的业务场景下，我们需要服务器端主动项客户端发送消息，比如Web聊天室就需要服务器端主动项客户端发送新收到的消息，OA（office automation,办公自动化）系统就需要服务器端主动向客户端发送请假申请审批结果，站内消息系统就需要服务器端主动通知客户端“有新消息”。

为了实现服务器端项客户端推送消息，在2008年诞生了WebSocket协议，并且该协议在2011年成为国际标准。目前所有的主流浏览器已支持WebSocket协议。

WebSocket基于TCP(transmission control protocol,传输控制协议)，支持二进制通信，因此通信效率非常高，它可以让服务器处理大量的并发WebSocket连接；WebSocket是双工通信，因此服务器可以高效地向客户端推送消息。

##### 7.1 SignalR基本使用

WebSocket是独立于HTTP的，但是我们一般仍然把WebSocket服务器端部署到Web服务器上，因为我们需要借助HTTP完成初始的握手，并且共享HTTP服务器的端口，这样就可以避免为WebSocket单独打开新的服务器端口。因此，SignalR的服务器端一般运行在ASP.NET Core项目中。

SignalR中一个重要的组件是集线器(Hub),它用于在WebSocket服务器端和所有客户端之间进行数据交换，所有连接到同一个集线器上的程序都可以相互通信。

通过集线器来完成服务器端向客户端的消息推送，也可以完成客户端之间的消息推送，当然WebSocket也允许客户端向服务器端发送消息。

案例：创建一个聊天室

步骤如下：

(1) 创建一个Asp.Net Core WebApi项目，并且在项目中创建一个继承自Hub类的ChatRoomHub类，所有的客户端和服务器端都通过这个集线器进行通信

> Hub位于Microsoft.AspNetCore.SignalR命名空间下

代码如下：

``` C#
public class ChatRoomHub : Hub
{
    public Task SendPublicMessage(string message)
    {
        string connId = this.Context.ConnectionId;
        string msg = $"{connId} {DateTime.Now}：{message} ";
        return Clients.All.SnedAsync("ReceivePublicMessage",msg);
    }
        
    
}
```

(2) 编辑Program.cs在builder.Build之前调用builder,Services.AddSignalR注册所有SignalR的服务，在app.MapControllers之前调用app.MapHub\<ChatRoomHub>("/Hubs/ChatRoomHub")启用SignalR中间价，并且设置当客户端通过SignalR请求”/Hubs/ChatRoomHub“这个路径的时候，由ChatRoomHub进行处理。

``` C#
builder.Services.AddSignalR();
string[] urls= new []{"http://localhost:3000"};
builder.Services.AddCors(
	options => options.AddDefaultPolicy(builder => builder.WithOrigins(urls).AllowAnyMethod().AllowAnyHeader().AllowCredentials())
);

var app = builder.Build();

app.UseCors();
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapHub<ChatRoomHub>("/Hubs/ChatRoomHub");
app.MapControllers();
```

(3) 我们需要编写一个静态HTML页面提供交互界面。按照前后端分离的理念，我们应该把HTML页面放到一个单独的前端项目中。我们需要在前端项目中通过npm进行安装SignalR的JavaScript客户端SDK,安装命令如下：

``` shell
npm install @microsoft/signalr
```

在SignalR的JavaScript客户端中，我们使用HubConnectionBuilder来创建从客户端到





# 2. Web前端框架

## 一. 弹性布局

现在常规网站的常规布局基本分为2种

(1) 固定布局: 这种很早的时候是我们做网站的比较常见的方式,好处是做的网站内容不会蹿版,但是问题也有

a. 当我们电脑的分辨率过大的时候,网页两边会有大量的留白存在

b. 当我们电脑的分辨率过小的时候,网页的页面内容显示不全

(2) 弹性布局: 这种布局是现在的主流,它会根据我们自己电脑的分辨的大小自动改变,实现这种布局的时候我们也有2种方式

a. 浮动+百分比布局 这种布局好处是网页内容可以自己适应浏览器的宽度,多种设备都可以适用

b. Flex布局 : 这个是我们现在设计网站的主流方式

#### Flex布局

Flex布局是CSS3引进的一种布局方式,我们管它叫做"弹性盒子模型",这种模型决定一个盒子在其他盒子中的分布方式以及处理可用的空间.

##### Flex 功能

* 在屏幕和浏览器窗口发生大小改变的时候,可以灵活的调整布局
* 控制元素在页面的布局方向
* 按照控制不同与DOM所指定排序方式对屏幕上的元素进行重新排序

##### Flex优势

* 可以让盒子里的元素排在一行
* 盒子里面元素的高度是相同的

##### Flex 语法

``` css
display:flex;
```

我们可以在父级容器的选择器当中添加如上的样式内容,代表我们这个容器下的内容采用的是flex布局.

Flex布局还带有如下的常用属性

| 属性            | 说明       |
| --------------- | ---------- |
| flex            | 伸缩性     |
| flex-direction  | 伸缩流方向 |
| flex-wrap       | 伸缩换行   |
| justify-content | 主轴对齐   |
| align-items     | 侧轴对齐   |

**(1) flex属性**

这个用于控制我们子元素在父级容器当中所在比例,语法如下:

``` css
flex:1; /*这个代表当前元素在父级容器当中占有1份空间,数值越大代表占有的空间越大*/
```

例如:

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box{ border:1px red solid; display: flex;}
        .first{ background: orange; height: 100px; flex:1;}
        .second{ background: pink; margin-left: 10px;  flex:2;}
    </style>
</head>
<body>
    <div class="box">
        <div class="first"></div>
        <div class="second"></div>
    </div>
</body>
</html>
```

效果如下:

![](imgs/21.png)

我们可以看到粉色背景的div是比橘色背景的div大的

> 注意: 我们浏览器对css3属性的支持不同,有的时候我们需要对这个属性添加浏览器兼容性的前缀

**(2) flex-direction属性**

这个属性是让我们控制伸缩流方向的,语法如下:

``` css
flex-direction: row | row-reverse | column | column-reverse;
```

我们可以看到属性值共分为2组,row代表的是横向排列,从左到右 带有reverse后缀的采取相反操作,从右向左排列,其中row是这个属性的默认这.

column代表的是纵向排列,从上之下的排列,带有reverse后缀的采取相反操作,从下到上的排列.

例如:

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box{ border:1px red solid; display: flex; flex-direction: row-reverse;}
        .first{ background: orange; height: 100px; flex:1;}
        .second{ background: pink; margin-right: 10px;  flex:2;}
    </style>
</head>
<body>
    <div class="box">
        <div class="first"></div>
        <div class="second"></div>
    </div>
</body>
</html>
```

效果如下:

![](imgs/22.png)

**(3) flex-wrap属性**

这个属性是控制我们子级元素在父级元素宽度不够的时候是否换行的,语法如下:

``` css
flex-wrap: nowrap | wrap | wrap-reverse;
```

其中nowrap是默认值,代表不换行

wrap代表换行

wrap-reverse 代表换行,但是这个是向上换行

**(4) justify-content属性**

这个属性是设定我们子级元素在父级容器当中如何横向布局的,布局方式一共有5种,分别如下:

| 属性值        | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| flex-start    | 向一行的起始位置靠齐                                         |
| flex-end      | 向一行的结束位置靠齐                                         |
| center        | 向一行的中间位置靠齐                                         |
| space-between | 平均分布在行内,第一个伸缩项目在一行的最开始,最后一个伸缩项目在一行的最终点 |
| space-around  | 平均分布在行内,两端保留一半空间                              |

**(5) align-items属性**

这个是让我们设定子级元素在父级容器当中垂直分布的,它也有5个属性值

| 属性值     | 说明                                     |
| ---------- | ---------------------------------------- |
| flex-start | 在侧轴起点的外边距紧靠该行在侧轴起始边   |
| flex-end   | 在侧轴终点边的外边距紧靠该行在侧轴终点边 |
| center     | 外边距盒子在该行的侧轴上居中放置         |
| stretch    | 拉伸填充整个伸缩容器,这个是默认值        |
| baseline   | 根据第一行的文字的基线对齐               |

#### 响应式布局

响应式网页设计(RWD, Responsive Web Design) 这个是由Ethan Marcotte(伊桑·马科特) 提出,它将现在已有的三种开发技术整合起来,并且命名的.

这三种技术是: a. 弹性布局 b. 弹性图片 c. 媒体和媒体查询

弹性布局上面我们说了

弹性图片是指不给图片设定固定尺寸,而是根据流体网格进行缩放,用于适应各种网格的尺寸.实现方法是比较简单的,一句代码就能搞定.代码如下:

``` css
img{max-width:100%;}
```

##### 媒体查询

**(1) 媒体类型**

在CSS2中我们常遇到的媒体类型是

* All  全部
* Screen  屏幕
* Print  页面打印或者打印预览模式

实际上媒体类型不止这三种,W3C共列出了10种媒体类型

| 值         | 设备类型                                        |
| ---------- | ----------------------------------------------- |
| All        | 所有设备                                        |
| Braille    | 盲人用点字法触觉回馈设备                        |
| Embossed   | 盲人打印机                                      |
| Handheld   | 便携设备                                        |
| Print      | 打印用纸或打印预览视图                          |
| Projection | 各种投影设备                                    |
| Screen     | 电脑显示器                                      |
| Speech     | 语音或音频合成器                                |
| Tv         | 电视机类型设备                                  |
| Tty        | 使用固定密度字母栅格的媒介,比如电传打字机和终端 |

我们根据设备的内容来进行选择,常用的是all和screen

**媒体类型的引入方式**

我们有两种方式进行引入

(1) 在样式表当中通过@media方式进行引入,语法如下:

``` css
@media 媒体类型{
    选择器{样式代码}
}
```

(2) 在我们html页面通过link引入样式表的时候进行引入,语法如下:

``` html
<link rel="stylesheet" href="样式表的路径" media="媒体类型" />
```

我们比较常用第一种方式

**(2) 媒体特性**

媒体特性是CSS3对媒体类型的增强版,我们可以把媒体特性看成是

> "媒体类型(判断条件)" + CSS(符合条件的样式规则)

媒体特性包含如下内容:

| 属性          | 值                                  | Min/Max | 描述               |
| ------------- | ----------------------------------- | ------- | ------------------ |
| device-width  | Length                              | Yes     | 设置屏幕的输出宽度 |
| device-height | Length                              | Yes     | 设置屏幕的输出高度 |
| width         | Length                              | Yes     | 渲染界面的宽度     |
| height        | Length                              | Yes     | 渲染界面的高度     |
| Orientation   | Portrait(纵向) 或者 landscape(横向) | No      | 横屏或竖屏         |
| Resolution    | 分辨率(dpi/dpcm)                    | Yes     | 分辨率             |
| Color         | 整数                                | Yes     | 每种颜色的字节数   |
| color-index   | 整数                                | Yes     | 色彩表中的色彩数   |

语法如下:

``` CSS
@media 媒体类型 and (媒体特性){
    CSS样式
}
```

其中我们看到了 and 关键字,这个代表并且,是要求同时满足这两者时才生效的,例如:

``` css
@media screen and (max-width:1200px){} /*这个代表了是电脑屏幕并且最大宽度为1200像素的才能使用里面的样式*/
```

我们还可以在媒体类型的前面添加not 关键字,用于排除某种指定的媒体类型,例如:

``` CSS
@media not print and (max-width:1200px){}/*这个代表了排除打印设备,并且最大宽度为1200像素的才能使用里面的样式*/
```

响应式布局的优缺点如下:

* 优点: 
  * 面对不同的分辨率设备灵活性强, 能够快捷解决多设备显示使用问题
  * 更少维护,开发一个网站,多终端可以使用
*  缺点:
  * 兼容各种设备工作量大
  * 代码累赘,会出现隐藏无用的元素,加载时间长

根据上面的优缺点我们找到了更加合理的网站设计方式 ----- 前端框架

例如: Bootstrap, LayUI, Vue 等等,自带响应式布局

## 二. Bootstrap

#### 1. 简介

##### 1.1 初始Bootstrap

Bootstrap框架是由Twitter设计师Mark Otto和Jacob Thornton共同开发出来的,准确的讲它就是一个HTML+CSS的前端框架.

Bootstrap框架提供了优雅的HTML+CSS规范,是由动态CSS语言完成的,它完美的解决了页面响应式设计的难点.因此该框架推出之后颇受欢迎.

> 什么是响应式设计?
>
> 上面笔记有此处略

##### 1.2 响应式设计四大原则

响应式设计需要遵循如下四个基本原则

* 移动端优先还是PC端优先
* 内容流
* 位图还是矢量图
* 相对单位还是固定单位

###### 1.2.1 移动优先还是PC优先

随着移动互联网的发展,很多小型创业企业甚至没有自己的网站,只有一个APP应用.在这个时代,网站项目是从小屏幕入手过渡到大屏幕,还是从大屏幕过渡到小屏幕,这个称为了企业考虑的首要问题.

在传统的大企业改造型网站,大部分是从大屏幕过渡到小屏幕的,而且在过渡到小屏幕的时候会碰到一些限制,比如:设法在第一页面显示更多的内容.

在新兴的创业公司,通常情况下都会从两个方面同时着手,所以具体哪个优先还是要看哪种方式最为合适.

###### 1.2.2 内容流

随着移动端屏幕尺寸越来越小,内容所占的垂直空间会越来越多.也就是说,内容会向下方延伸,这被称为"内容流".

###### 1.2.3 位图还是矢量图

首先我们先来说一下什么是位图,什么是矢量图

位图: 当一张图片被放大会出现比较虚的情况,这种图片被称为位图.

矢量图: 当一张图片被放大后不变虚的则为矢量图.

矢量图是使用线段和曲线描述图像,所以称为矢量,同时图形也包含了色彩和位置信息.

位图是使用像素点来描述图像的,计算机的显示器屏幕就是一张包含大量像素点的网格.在位图中,图像由每一个网格中的像素点的位置和色彩值来决定,每一点的色彩是固定的所以放大后观看图像时,每一个小点看上去就像是马赛克,这就是我们常说的"虚".

在响应式设计中,如果我们的图标使用了很多细节,并且应用了很多华丽的效果这种情况就是用位图.否则考虑矢量图.如果是位图,使用jpg,png或gif.矢量图则最好使用SVG或图表字体.

矢量图的优缺点:

优点:  通常比较小,非常适合移动端来展示

确定:  对浏览器的支持不是特好,老的浏览器不支持矢量图.

###### 1.2.4 相对单位还是固定单位

传统的设计单位有px,pt,cm等, 这些都是固定单位,没法实现跨平台展示.那么在这种情况下,百分比等相对单位就到了发挥作用的时候了.使用百分比时,我们所说的宽度50%是表示宽度占屏幕大小的一半.

##### 1.3 Bootstrap设计目标

其实从Bootstrap3版本开始,Bootstrap框架就包含了贯穿于整个库的移动设备优先的样式.Bootstrap 4版本默认的CSS本身就是对移动设备优先进行友好的支持.

Bootstrap框架的设计目标从优先支持桌面端转变到了优先支持移动端的设备.          

#### 2. 开发环境

##### 2.1 下载安装包

首先我们需要到官网网站进行在下开发包

官方网址是: [https://v4.bootcss.com](https://v4.bootcss.com/)

进入该网址之后,点击页面上的下载即可下载开发包.

##### 2.2 Bootstrap开发包目录结构

我们把下载好的开发包解压之后,就能看到里面包含了css和js两个文件夹,他们分别代表了编译好的样式文件和脚本文件.

css文件夹内包含的文件如下:

![](imgs/23.png)

js文件夹内包含的文件如下:

![](imgs/24.png)

##### 2.3 在页面内引入Bootstrap框架

当我们在自己的项目下想要使用Bootstrap的时候,需要在代码页面内引入框架的样式和脚本

具体引入方式如下:

![](imgs/25.png)

我们需要注意的地方是: 在引入Bootstrap的js文件前,必须先引入jquery的脚本文件否则会报错.,当我们在页面内如上引入了内容,就可以在这个页面里来使用bootstrap框架的样式了.

#### 3. Bootstrap脚手架

脚手架:英文原名Scaffolding,好多的中文翻译为脚手架,也有人翻译成基础架构的.它实际就是网页的整体模板和架构.

##### 3.1 Bootstrap全局样式

######  什么是全局样式

所谓的Bootstrap全局样式,其实就是通过Bootstrap框架为页面设置的全局CSS样式表.该全局样式表包括基本的HTML元素样式以及栅格系统,可以增强页面及其元素的CSS效果.

Bootstrap框架为屏幕,排版和链接设置了基本的全局样式,具体定义在了Bootstrap源码包scss文件夹中的_variables.scss文件中,我们可以打开这个文件阅读这些代码进行参考(注:这些代码是以scss来进行编写的),多读这些源码对我们的前端开发有好处.

##### 3.2 栅格系统

栅格系统是Bootstrap框架的一大特色,通过使用栅格系统使得页面布局更简单,更合理,更美观,更易于维护.

Bootstrap框架默认的栅格系统最多为12列,形成一个960px宽的容器,默认就是响应式布局特性.栅格系统会根据可视窗口的宽度从540px到1140px进行自适应的动态调整.在可视化窗口宽度小于540px的时候,列将不再固定,并且会在垂直方向进行自动堆叠.

常用的样式有:

(1) 容器样式: container , container-fluid,其中container是固定宽度,会在网页的两端留有空白,而container-fluid是以百分比的形式布局的,不会有空白保留

(2) 行: row 代表在容器当中存在着一行的内容

(3) 栅格中的格: col-n, col-sm-n , col-md-n,col-lg-n 这个是我们栅格系统当中的栅格,根据中间的单词来确定针对于那种分辨率的设备,之后在n的位置上写对应的格数即表示占有几个栅格

sm小屏幕 , md 中屏幕, lg 大屏幕, col-n 这个代表的是超小屏幕 

(4) 偏移列

Bootstrap中支持偏移列,我们可以使用 offset-a-b类将列向右移动,其中a的位置需要我们填写屏幕大小,b的位置需要我们填写要偏移多少个栅格

例如: offset-md-3 在中屏幕分辨率下向右偏移3个栅格位置

##### 3.3 页面布局

Bootstrap框架设计了固定布局,流式布局,弹性布局等方式.默认是弹性布局.

###### 3.3.1 固定布局和流式布局

固定布局 container

流式布局 container-fluid

这两种上面我们介绍了,就不详讲了.

###### 3.3.2 弹性布局

弹性布局实际是CSS的一个特性,是一种当页面需要适应不同的屏幕大小以及设备类型时,确保元素拥有恰当行为的布局方式.Bootstrap也采用了这种布局方式,也有人称为弹性盒子.Bootstrap 4使用了一整套响应式FlexBox快速管理网格列,导航等组件的布局,对齐和大小.

> 注意: IE9及以下版本不支持弹性布局.

我们可以在元素上通过引入类选择器实现弹性布局例如:

``` html
<div class="d-flex">我是一个弹性盒子</div>
<div class="d-inline-flex">我是一个嵌入式的弹性盒子</div>
```

看到上面的代码我们知道,弹性盒子有2种模式:

(1) d-*-flex 

(2) d-*-inline-flex

其中*可以省略或者更换为任意的屏幕大小,例如:sm,md,lg等













## 三. ES 6

### 1. ES 6 的简介

> JavaScript的组成:  DOM , BOM , ECMAScript

ECMAScript 其实就是我们现在要讲的ES6  --> 其中的这6代表的是版本号

在2015年6月份,发布的es6的这个版本,在这之后所有的版本都是叫做es6

> 什么是ECMAScript?它与JavaScript的关系是?
>
> ECMAScript 是由国际标准化组织ECMA对JavaScript语言设定的一系列标准
>
> ECMAScript与JavaScript的关系是: 前者是后者的规范,后者是前者的一种实现方式

### 2.  let 和 const 命令

#### 2.1 let 命令

这个命令是es6当中新增的内容,主要用于声明变量. 它的用法基本与var类似,不同点是 let声明的变量只能在let命令所在的代码块内有效. **let声明的变量都是局部变量**

声明变量的语法:

``` JavaScript
var 变量名 = 值;
let 变量名 = 值;
```

**在ES6的语法当中,提倡使用let命令进行创建变量,而不是使用var命令**

> var 与 let 声明的变量除了上面的不同点以外是否还有不同点?
>
> 有, **不存在变量提升**, 我们使用var创建的变量如果在创建之前就去使用了,那么这种情况下,会提示这个变量并没有被初始化(undifined) , 我们使用let创建的变量,则会直接报错

阅读下面的代码说出执行后的结果

``` javascript
var temp = 1111;
if(true){
    temp = 2222;
    let temp;
    console.log(temp);
}

```

答: 报错,上面这种情况我们一般管他叫做 "暂时性死区"

**什么是暂时性死区**

只要块级元素作用域内存在let命令,他所声明的变量 就绑定到这个区域

**let命令在同一个作用域下不允许出现同名的变量**

#### 2.2 ES6 块级作用域

我们一般带有{ } 就叫做块级作用域 , **ES6当中允许代码块之间互相嵌套**

``` JavaScript
{{{let a = 10;}}}
```

 上面的写法我们叫做3层块级作用域

阅读下面的代码,说出最后运行结果是什么

``` javascript
{
    {
        {let a = 20;}
  		console.log(a);
 	}
}
```

上面代码执行后报错,

``` javascript
{
    {
        {let a = 10;}
        let a = 10;
        console.log(a);
    }
}
```

上面的代码执行后,会在控制台输出10,因为通过let命令创建的2个变量a,没在同一个作用域下

**块级作用域与函数声明**

``` JavaScript
if(true){
    function a(){
        
    }
}
```

上面的写法如果是在ES5的开发环境下,会报错,**ES5的环境要求函数必须是声明在顶级作用域下**

ES6的开发环境是允许这么写的,在块级作用域下声明的函数与let命令声明的变量类似,它只能在这个作用域下使用,出了这个作用域是找不到的

#### 2.3  do表达式

**块级作用域本质上就是一个语句,这个语句只是把多个操作封装在一起了,并且不带有返回值**

``` JavaScript
{
    let t = f();
    t = t * t + 1;
    function f(){
        return 3;
    }
}
```

我们在块级作用域外面想要得到t的值是否能得到?

答: 不能, 第一点变量t是在作用域下创建的局部变量,外面找不到, 第二点,作用域是不带有返回值的,所以也获取不到

**在ES6当中我们可以通过do表达式把这个作用域变成表达式,带有返回值内容**

``` javascript
function f() {
   return 3;
}
let a = do {
     let t = f();
     t * t + 1;
};
```

#### 2.4 const命令

这个命令创建的变量就是一个常量,**const命令与let命令一样,在同一个作用域下不可以存在同名的变量**

> 常量: 初始化之后,不可再去修改

### 3. 变量的解构赋值

要求: 创建3个变量a,b,c 并且分别给这三个变量赋值为1,2,3

ES6当中允许我们像下面这种创建变量并且赋值

``` javascript
let [a,b,c] = [1,2,3];
```

上面的中写法,可以从数组当中提取出对应的值,并且按照对应的位置赋值给对应的变量

上面这种写法属于"模式匹配",要求是等号两边的模式相同,左边的变量就可以被赋予对应的值

``` javascript
let [a , [[b] , c ]] = [1 , [[2] , 3]];  
```

我们在去输出a,b,c的时候是否会报错呢? 不会报错

我们除了上面的写法以外,还可以在创建的时候同时给对应的变量指定一个默认值

``` JavaScript
let [a , b = 100] = [50]; 
```

阅读下面代码说出最后执行的结果是

``` javascript
let [a , b = 'B' ] = ['A', undefined];
```

这个地方会输出 A, B ,其中b在赋值的时候给的是undefined代表未定义,就是不给B进行合理的存值,那么b变量就会存入默认值

阅读下面代码说出最后执行的结果是

``` javascript
let [a = b , b = 2] = [];
```

阅读下面的代码说出最后执行的结果是

``` javascript
let [a = 1, b = 2] = [3 , null];
```

**对象的解构赋值**

解构不仅可以通过数组的形式来进行存值,还可以通过对象的形式进行存值

``` javascript
let {a,b} = { a:1, b:2 };
```

阅读下面的代码说出最后执行的结果是

``` javascript
let {a : 1 , b : 2} ={a:3}; 
```

上面的这个东西报错, : 后面不能直接指定准确的内容, : 后面只能存放变量,而且只能有一个声明,不能是多个声明

``` JavaScript
let {a : b} = { a: 1 , b:2};
```

我们在这个代码后面只能通过输出b得到结果,如果我们输出a,则会报错,提示a未定义,但是存储的值还是以我们后面赋值时对应名称的值为主,上面的这段代码最后的输出结果是1,我们后面b:2这段代码是用于给a设定默认值为2的,但是b这个变量在上面并没有真的声明,所以:b 并不会把真的值存入到a, 而是会因为b没有声明,存入undefined

**对象的解构赋值的内部机制是先找到同名属性,然后再去赋值给对应的变量.真正被赋值的是后者,而不是前者**

对象的解构赋值嵌套

``` javascript
let obj = {
  pre : [
      "Hello",
      { aft : "world" }
  ] 
};
```

上面的这种写法就是我们S2讲过的Json字符串的写法, { }里面用于设定key和value,上面代码当中key为 pre, 值是:后面的内容, { }里面只能存放一个属性 , [ ] 相当于我们存放的数组值,里面可以存放多个内容

上面的变量obj经过3次解构赋值

### 4. 字符串的扩展

#### 4.1 字符的Unicode表示法

在ES6中加强了对Unicode的支持,并且扩展了字符串.

JavaScript当中允许我们使用\uxxxx形式表示一个字符,其中xxxx表示字符的unicode码点.

例如: \u0061 这个代表的是字母 a

上面的这种表示法只限于码点在\u0000 ~ \uFFFF之间的字符,如果超出这个范围的字符,必须采用2个双字节的形式表达

#### 4.2 codePointAt()

JavaScript内部,字符以UTF-16的格式存储,每个字符固定为2个字节.对于那些需要4个字节存储的字符(Unicode码点大于0xFFFF的字符),JavaScript会认为它们是2个字符

``` Javascript
let s = "吉";

s.length;
s.charAt(0); //
s.charAt(1); //
s.charCodeAt(0);
s.charCodeAt(1);
s.codePointAt(0);
```

#### 4.3 String.fromCodePoint

让我们把编码格式的内容转换成对应的字符 ,这个方法是ES5提供,这个方法不能识别32位UTF-16

的字符

``` JavaScript
let a = "0x20BB7";
console.log(String.fromCodePoint(a));
```

这个方法我们可以传递多个参数,他会把这些值合并成一个字符串进行返回

#### 4.4 字符串的遍历器接口

原始玩法:

``` JavaScript
   let a = "Hello World";
   for (let i in a) {
      console.log(a[i]);
   }
```

在ES6当中,为字符串添加了一个遍历器接口,我们可以通过这个接口内容直接遍历出字符串的每个字符

使用的语法还是循环,但是循环语法变了

``` javascript
for(let 变量名 of 要遍历的字符串名字){
    console.log(变量名);
}
```

#### 4.5 at函数

功能与charAt()相同,主要得到字符串当中某个字符

``` JavaScript
字符串变量名.at(要得到字符的索引)
```

> at函数与charAt函数的区别:
>
> charAt函数返回的内容是UTF-16编码当中的某个字节,当我们的内容Unicode编码大于0xFFFF的时候是无法正常显示的,但是at函数可以

#### 4.6 模板字符串

原始玩法:

``` javascript
let str = "";

for(....){
    
    str += "<tr>";
    ...
    str += "</tr>";
}


```

在ES6当中认为上面的写法太过于繁琐,所以引进了模板字符串

``` javascript
let str = "";
for(....){
    
    str += `
       <tr>
           <td>${data[i].title}</td>
	   </tr>
    `;}
```

### 5. 函数的扩展

#### 5.1 函数的默认值

正常函数的声明

``` javascript
function 函数名([参数列表]){
    函数内容
    [return xx;]
}
```

例如:

``` javascript
function calc(x,y){
    console.log(x+y);
}

calc(1,2);

```

当我们方法某个参数因为值比较固定,大部分的时候是不需要存储,使用默认值即可,但是特殊情况下我们还需要

进行存值操作的,我们就可以按照下面的方式进行声明函数

``` javascript
function calc(x,y = 5){
    
}
```

**带有默认值的参数必须放到参数列表的最后面**

#### 5.2 rest 参数

这个参数就是C#当中多个参数值(params)

``` javascript
function 函数名(...参数名){
    //我们在函数内部想要使用这个参数,需要循环遍历,它会以数组的形式进行操作
}
```

只要看到上面这种形式的声明方式,代表我们可以在参数上传递多个值

> js当中的数组是否可以一次通过push方法添加多个值进入数组

**要求带有rest修饰的参数,必须是参数列表当中的最后一位**

#### 5.3 箭头函数

ES6 是允许我们使用 => 来定义函数的,我们通过这种方式定义的函数,默认是带有返回值

语法:

``` js
let 变量 = function(){
    return ...;
}

//上面的写法是正常的写法,箭头函数的写法如下
let 变量 = () => ...;

```

例如:

``` js
let sum = function(x,y){
    return x+y;
}

//转变为箭头函数
let sum = (x,y) => x+y;

```

上面的写法是当我们的函数里只存在一条语句的写法,如果说我们的函数当中存在着多条语句,那么箭头函数该如何写

``` js
//现在我们要求传递2个参数值,并且计算这两个数字的和与差,之后返回这两个值
let v = function(x,y){
    let sum = x + y;
    let c = x - y;
    return [sum,c];
}
//把上面的内容转换为箭头函数

let v = (x,y) => { 
	let sum = x + y;
    let c = x - y;
    return [sum,c];
}
```

#### 5.4 尾调用优化

##### 5.4.1 尾调用

尾调用是函数式编程的一个重要概念,它是指在某个函数的最后一步的时候调用另一个函数.

例如:

``` js
function show(x){
    return a(x);
}
```

> 阅读下面代码说出哪个(哪些)不是尾调用
>
> ``` js
> function f(x){
>     let y = g(x);
>     return y;
> }
> 
> function f(x){
>     return g(x) + 1;
> }
> 
> function f(x){
>     g(x);
> }
> 
> ```
>
> 上面三种当中没有一个属于尾调用
>
> 第三种不带有返回值的函数,我们要把所有的代码写全是如下效果:
>
> ``` js
> function f(x){
>     g(x);
>     return undefined;
> }
> ```
>
> 下面的这种写法是否为尾调用
>
> ``` js
> function f(x){
>     if(x > 0)
>         return m(x);
>     return k(x);
> }
> 
> ```
>
> 这种写法是属于

##### 5.4.2 优化

举例:

``` js
function f(){
    let m = 1;
    let n = 2;
    return g(m+n);
}

f();

//等同于
function f(){
    return g(3);
}
f();

//等同于
g(3);
```

上面代码当中,如果函数g不是尾调用,函数f就需要保存内部变量m和n的值,g的调用位置等等信息.

但是我们现在的写法调用g函数之后,函数f就结束了,所以执行到最后一步时,就完全可以删除掉f函数的调用,只要我们能够找到g函数的调用即可,这种操作就是尾调用的优化.

> 什么是尾调用优化?
>
> 只保留内层函数的调用,这种写法叫做尾调用优化

> 尾调用优化的优点?
>
> 因为我们使用尾调用优化时,每次只需要调用一项,这种写法会大大的节省内存

### 6. 数组的扩展

> apply与call函数的区别
>
> 两个方法都是用于更改this指向的
>
> apply方法的第二个参数让我们来进行传递数组形式的值进行展现
>
> call 方法的第二个参数让我们来进行传递正常形式的参数内容

#### 6.1 替换数组的apply方法

就是把我们现在数组内容展开不需要再去使用apply方法了,我们使用类似于rest参数的形式来进行更改

``` js
var arr = [1,2,3,4,5,6];
function add(x,y,z){
    //arr.push(x,y,z);
    //我们现在要求是通过这个方法把参数的值传递(添加到)给我们指定的数组
}

add.apply(null,arr); //这个地方让我们通过apply方法来进行指定,指定add方法当中的this对象是arr数组

//ES6的写法

function add(x,y,z){
    
}
var arr = [1,2,3];
add(...arr); //这个就是es6当中指定当前函数里this对象代指arr数组的意思

```

#### 6.2 扩展运算符的应用

**合并数组**

``` js
var a = [1,2,3,4];
var b = [5,6,7,8];
//我们需要把上面两个数组合并之后,再去进行循环遍历输出
a.concat(b); // ES5的写法 ,通过concat方法来实现数组的拼接

var c = [...a,...b]; //ES6的写法,通过rest参数形式来进行拼接
```

**函数的返回值**

``` js
//设定一个函数,函数的参数传递进去一个数组,我们要求返回这个数组当中大于9的所有数字
 function getNum(...arr) {
       var sum = [];
       for (let i of arr[0]) {
           if (i > 9) {
              sum.push(i);
           }
       }
       return sum;
 }
```

#### 6.3 Array.from()

该方法可以把类似于数组的对象转换为真正的数组对象

例如:

``` js
let haha = {
            "0": "张三",
            "1": "李四",
            "2": "王五",
            "3": "马六",
            length: 4
        };
        console.log("原始的:");
        console.log(haha);
        console.log("转化后:");
        console.log(Array.from(haha));
```

#### 6.4 Array.of()

这个方法是让我们把一组值转换为数组

例如:

``` js
let a = 1;
let b = 2;
let c = 3;
Array.of(a,b,c);
```

Array.of 基本上可以用来代替Array() 或者 new Array(),并且不存在因为参数不同而导致的重载,它的行为非常统一

#### 6.5 copyWithIn()

数组实例当中通过copyWithIn方法会在当前数组内部将指定位置的成员复制到其他位置上,并且会覆盖掉这个原有成员.,返回值为当前数组

例如:

``` js
let arr = [1,2,3,4,5];
//数组名.copyWithIn(target,start,end)
//target       从该位置开始替换数据
//start(可选)   从该位置开始读取数据,默认为0,,如果值为负数了,则表示倒数 
//end(可选)     到该位置前停止读取数据,默认等于数组长度,如果值为负数了,则表示倒数
arr.copyWithIn(0,2,3); //这个位置就是把值进行替换了,数组更改为[3,2,3,4,5]

arr.copyWithIn(0,3); //这个的输出结果是? // [4,5,3,4,5]

```



### 7. 对象的扩展

#### 7.1 简介的表示法

ES6允许直接写入变量和函数作为对象的属性和方法.

ES5之前的写法

``` js
var foo = 'haha';
var obj = {foo};
console.log(obj);
```

ES6的写法:

``` js
var obj = { foo : "haha"};
```



ES5之前的方法返回对象的写法:

``` js
function fuc(x,y){
    return { x:x,y:y };
}
```

ES6的写法:

``` js
function fuc(x,y){
    return {x,y};
}
```

ES6当中如果对象我们只写了属性名,并没有写属性值,这个时候,属性值等于属性名所代表的变量

> 当我们创建一个对象时,这个对象既包含属性,又包含方法,我们该如何声明

``` js
var person ={
    name:"张三",
    age:16,
    gender:"男",
    show:function(){
        //方法具体内容
    }
};
```

上面的内容可以简化为下面的写法

``` js
var person ={
    name:"张三",
    age:16,
    gender:"男",
    show(){
        //方法具体内容
    }
};
```

#### 7.2 属性名表达式

JavaScript当中语言定义对象的属性有两种方式:

(1) 

``` js
obj.name = "";
```

(2)

``` js
obj["na"+"me"] = "";
```

第一种方式时直接用标识符作为属性名,第二种时用表达式作为属性名,这时要将表达式放在中括号当中

当我们使用的时ES5的时候,我们一般不会用到上面的两种,而是采用花括号的方式进行定义属性.

我们使用花括号形式的时候,ES5里面只能使用 第一种方式的形式创建属性

``` js
//ES5
var obj ={
    name:"",
    age: 16 ,
};
```

ES6允许我们定义属性时采用第二种方式定义

``` js
var obj ={
    ["na"+"me"] : "",
    age : 16
}
```

#### 7.3 Object.is()

ES5当中用于比较两个值是否相等,只有两个运算符 相等运算符(==)和严格相等运算符(===).

它们都有缺点: == 会自动转换数据类型,===的NaN不会等于自身,以及 +0 等于 -0

ES6当中提出"Same-value equality"(同值相等)算法来解决这个问题. Object.is就是部署这个算法的新方法,它用来比较两个值是否严格相等的,与===的行为基本一致.

语法:

``` js
Object.is(a,b)
```

#### 7.4 \__proto__属性

这个是用来读取或者设置当前对象的prototype对象.

``` js
var obj = {
    method:function(){ ... }
};
obj.__proto__ = ...;    
```

ES6当中当某个属性前后都带有了双下划线,这样的属性我们叫做内部属性,并不是对外公开的

**Object.setPrototypeOf()**

这个函数作用与我们上面的\__proto__这个属性相同,用来设置一个对象的prototype对象,返回参数对象本身/

``` js
Object.setPrototypeOf(object,prototype);
```

例如:

``` js
var o = Object.setPrototypeOf({},null);
```

### 8. Symbol

Symbol这个是ES6引进的一种新的原始数据类型,表示独一无二的值.

> JavaScript 我们之前讲了几种数据类型,分别是什么?
>
> 我们之前一共讲了6种,Undefined,Null,boolean , string , number ,object

Symbol这个是我们讲的js当中第7种数据类型

#### 8.1 Symbol变量的声明

语法:

``` js
let 变量名 = Symbol();
```

这种数据类型比较特殊,它是通过函数进行声明的

**我们该如何赋值呢?**

``` js
let s =  Symbol('haha'); //这个代表我们声明了一个Symbol类型的变量s,并且赋值为haha
```

> 我们现在声明的Symbol类型变量是否为一个对象
>
> 不是一个对象,所以Symbol类型的内容是不带有属性的,我们可以把这种数据类型看做成一种类似与字符串类型的数据类型

**判断两个Symbol数据类型的值是否相等**

**就因为symbol要求是独一无二的,所以我们写的2个函数的返回值都是不相同的**

案例1:

``` js
let s1 = Symbol();
let s2 = Symbol();
console.log(s1 == s2);  //false
console.log(s1 === s2); //false
```

案例2:

``` js
let s1 = Symbol('haha');
let s2 = Symbol('haha');
console.log(s1 == s2);  //false
console.log(s1 === s2); //false
```

**Symbol数据类型的值是不可以与其他数据类型的值进行运算的,否则会报错**

#### 8.2 作为属性名

由于每一个symbol变量的值都是不同的,所以我们可以把这种变量的值当作标识符用于对象的属性名.

实例:

``` js
let sss = Symbol();
//第一种写法:
var a = {}; //代表创建一个对象
a[sss] = 'Hello'; //给这个对象添加一个属性,属性名是上面创建的Symbol变量值,值是hello

//第二种写法:
var a = {
  [sss] : "hello"  
};


```

#### 8.3 实例: 消除魔术字符串

魔术字符串: 在代码中多次出现,与代码形成强耦合的某一个具体的字符串或者数值.

**我们在良好的代码开发当中,应该尽量消除魔术字符串,使用含义清晰的变量代替**

``` js
function getArea(shape,options){
    var area = 0;
    switch(shape){
        case 'Triangle': //这个地方我们就叫做魔术字符串
            area = 0.5 * options.width * options.height;
            break;
         ....   
    }
}
```

上面的代码当中出现了Triangle变量值,它就是一个魔术字符串.它会出现多次,与代码形成了"强耦合",不利于我们后期的修改和维护.

我们需要把上面的魔术字符串消除,最常用的方式就是把魔术字符串变成一个变量

代码更改为:

``` js
var shapeType={
    triangle : 'Triangle'
};

function getArea(shape,options){
    var area = 0;
    switch(shape){
        case shapeType.triangle: 
            area = 0.5 * options.width * options.height;
            break;
         ....   
    }
}


```

### 9. Set和Map数据结构

#### 9.1 Set数据结构

Set是ES6提供的新的一种数据结构,,它类似于数组,但是成员的值都是唯一,没有重复.

``` js
let s = new Set(); //这个代表我们创建了一个新的set结构

let s = new Set([1,2,3,4,5,6]); //这个是我们创建了set结构,并且存储了值
```

阅读代码说出结果

``` js
let items = new Set([1,2,3,4,5,5,5,5,5]);
console.log(items.size); //size是set结构的属性,用于得到set结构的长度
```

#### 9.2 Set实例的属性和方法

##### Set的属性

(1) Set.prototype.constructor : 构造函数,默认就是Set函数

(2) Set.prototype.size : 返回Set结构当中成员的总数

##### Set的方法

分为两种方法,操作方法(用于操作Set当中的数据的)和遍历方法(用于遍历Set当中的成员的)

add(value)     给set结构当中添加某个值的,返回Set结构本身

delete(value) 删除某个值,返回一个布尔值,用于表示是否删除成功

clear( )            清除掉Set结构当中所有的成员,没有返回值

has(value)      用于判断value的值是否为Set成员,返回布尔值

> 创建一个Set集合,往里存储几个学生姓名,如果其中包含 张三,我们就去删除他

##### 遍历操作

keys()       返回键名的遍历器

values()    返回键值的遍历器

entries()   返回键值对的遍历器



**因为Set结构并没有键名,只有键值,所以Set结构当中键名和键值都是同一个值,就是键值**

也是因为set当中只有values,所以我们一般不常用values方法而是直接通过for .. of的形式遍历Set结构

``` js
for(let item of set结构名){
    
}
```

forEach()  使用回调函数遍历每个成员

forEach() 用于遍历每个成员,并且执行任意操作,但是这个方法是不带有返回值的

``` js
let s = new Set([1,2,3,4]);

s.forEach(v => console.log(v*2)); //2,4,6,8
```

##### 交集,并集,差集

并集:就是把2个Set集合合并到一起

``` js
let a = new Set([1,2,3]);
let b = new Set([4,5,6]);
//并集就是把 a,b放到一起形成一个新的集合
let union = new Set([...a,...b]);
```

交集: 就是2个集合当中共同存在的内容

``` js
let a = new Set([1,2,3]);
let b = new Set([4,3,2]);
let c = new Set([...a].filter(v => b.has(v)));
```

filter这个是过滤方法,用于在某个集合当中筛选出 要求的值,小括号里我们需要书写一个箭头函数,这个箭头函数主要就是让我们填充过滤的条件

差集: 集合a当中的哪个值在集合b当中是不存在的

``` js
let a = new Set([1,2,3]);
let b = new Set([4,3,2]);
let c = new Set([...a].filter(v => !b.has(v)));
```

#### 9.3 WeakSet

WeakSet结构与Set结构类似,里面也是存储不重复值的集合.它与Set有两个区别

(1) WeakSet的成员只能是对象,而不能是其他类型的值

(2) WeakSet中的对象都是弱引用,弱引用就是垃圾回收机制不考虑WeakSet对该对象的引用.

语法:

``` js
let 变量名 = new WeakSet(要存储的对象内容);
```

**WeakSet再通过构造函数存值的时候只能接受一个数组或者类似数组的对象作为参数,换句话说只要是能够遍历都可以当作参数进行传递**

##### WeakSet方法

add()                向WeakSet实例添加一个新的成员

delete()           在WeakSet实例当中删除指定的成员

has()                判断某个值是否在WeakSet实例中存在

#### 9.4 Map数据结构

Map是JavaScript当中一个键值对的集合(Hash结构),其中键只能存储字符串的值

语法:

``` js
let m = new Map(); //这个是创建了一个Map集合,名字叫做m
```

Map集合也可以通过构造函数进行存值,它可以接受一个数组作为参数,该数组的成员是一个个表示键值对的数组

例如:

``` js
let m = new Map([
    ['name', '张三'],
    ['age', 16]
]);
```

##### Map属性

.size     用于获取集合当中的长度,**map集合当中键值对的数量**

##### Map方法

set(k,v )    用于给Map集合存值的 

get(k)       用于获取我们指定的key所对应的值 

delete(k) 用于删除我们指定的key所对应的键值对,返回布尔值,用于提示是否删除成功

has(k)      用于判断我们指定的key是否存在,存在返回true,不存在返回false

小练习:

``` js
let items = [
    ["stu1",{name:'张三',age:16,gender:"男"}],
    ["stu2",{name:'李四',age:16,gender:"女"}],
    ["stu3",{name:'王五',age:16,gender:"男"}]
];
let m = new Map(); //要求把上面数组当中的值通过set方法存储到m集合当中

// for (let item of items) {
//     m.set(item[0], item[1]);
// }
//items.forEach(x => m.set(x[0], x[1]));
items.forEach(([key, value]) => m.set(key, value));
```

> 如果我们给上面的map集合,stu1,在存储一个新的值,那么代码是否会报错呢?
>
> 不会报错,会把原有的值进行覆盖

> 我们是否可以通过一个set方法给map集合存储多个值,如果可以该如何书写
>
> 可以,代码如下:
>
> ``` js
> let m = new Map();
> m.set();
> //上面的写法我们可以简化一下
> let m = new Map().set("first", "aaa").set("second", "bbb");
> 
> ```
>
> 

##### Map 转数组

``` js
[...map集合名]
```

##### Map 转Json

``` js
let jsonstr =[
    {key:value,key1:value1,...},
    {key:value,key1:value1,...}, 
];
```

有2种情况

第一种情况: Map的键名都是字符串,这个时候我们可以选择转为对象JSON

``` js
//我们先声明一个Map集合转换为对象的方法
function strMapToObj(strMap) {
   let obj = Object.create(null); //创建一个空的对象
   for (let [k, v] of strMap) {
      obj[k] = v;
   }
   return obj;
}

//我们需要把上面的map集合转换成json
function strMapToJsonObj(strMap) {
   return JSON.stringify(strMapToObj(strMap));
}
```

第二种情况: Map集合的键名存在着非字符串的形式,这种可以选择转为数组Json

``` js
 //我们声明一个数组转换为json的方法
function mapToArrayJson(map) {
    return JSON.stringify([...map]);
}

```

##### Json转Map

正常情况下,所有的键名都是字符串

``` js
//我们需要先写一个对象转换成map的方法
function objToMap(obj){
    let m = new Map();
    for(let k of Object.keys(obj)){ //Object.keys(对象名) 是获取这个对象当中的所有属性名的
        m.set(k,obj[k]);
    }
    return m;
}

//我们还需要有一个把json字符串变成json对象的方法,之后调用上面的内容更改为map
function jsonToMap(jsonstr){
    return objToMap(JSON.parse(jsonstr)); //JSON.parse() 这个方法是把json字符串转换为json对象的
}
```

还有一种特殊情况,整个JSON就是一个数组,且每个数组成员本身又是一个具有2个成员的数组.

``` js
//我们直接把这些数组转换成Map即可
function jsonToMap(jsonstr){
    return new Map(JSON.parse(jsonstr));
}
```

### 10. Proxy

#### 10.1 简介

Proxy是用于修改某些操作的默认行为,等同于在语言层面做出修改,所以属于一种"元编程"(meta programming),就是对编程语言进行编程.

Proxy可以理解成在目标对象前架设一个"拦截"层,外界对该对象的访问都必须先通过这层拦截.我们可以把它叫做"代理器".

小案例

``` js
var obj = new Proxy({},{
    get:function(target,key,receiver){
      return Reflect.get(target,key,receiver);  
    },
    set:function(target,key,value,receiver){
        return Reflect.set(target,key,value,receiver);
    }
});
obj.count = 1;
console.log(obj.count);
```

上面的代码我们对一个空对象进行了一层拦截,重定义了属性的读取(get)和设置(set),即用自己定义的方法覆盖了语言本身原始的定义.

ES6提供的Proxy的构造函数,用于让我们生成Proxy实例

``` js
let 对象名 = new Proxy(target,handler);
```

**Proxy对象的所有用法都是上面这种形式,不同的是handler参数的写法**

target 参数:    表示的是所要拦截的目标对象

handler参数:  这个参数本身也是一个对象内容,这个对象是让我们来设定拦截行为的

例如:

``` js
        var p = new Proxy({}, {
            get: function(target, property) {
                return 1111;
            }
        });

        console.log(p.name); // 1111
        console.log(p.age); // 1111
        p.age = 1;
        console.log(p.age); // 1111
```

上面的代码,因为构造函数Proxy接受2个参数: 第一个参数是所要代理的目标对象,这个对象是个空对象,代表proxy没有介入,操作原来要访问的就是这个对象.第二个参数是一个配置对象,对于每一个被代理的操作,都需要提供一个对应的函数进行处理操作

**如果handler参数上没有设置任何拦截,那就等同于直接通向原对象(就是没有拦截器的效果)**

#### 10.2 Proxy提供的方法

##### (a) get(target,propKey,receiver)

拦截对象属性的读取,最后一个receiver参数是一个可选参数

##### (b) set()

set方法用于拦截某个属性的赋值操作

例如: Person对象 有个age属性,要求这个属性值不能大于120的整数

``` js
let validator = {
  set:function(obj,prop,value){
      if(prop == 'age'){ //判断是否为age属性
          if(!Number.isInteger(value)){ //判断我们存入的值是否为整数
              throw new TypeError('age属性值不是整数');
          }
          if(value > 120){
              throw new RangeError('age属性值超出范围');
          }
          obj[prop] = value;
      }
      else{
          obj[prop] = value;
      }
  }  
};
```

##### (c) apply()

这个方法拦截函数调用,call和apply的操作

apply方法可以接受3个参数,分别是目标对象,目标对象的上下文对象(this)和目标对象的参数数组

``` js
var a = function(){ return "猿师傅";}

var handler={
    apply:function(){
        return "曲昌浩";
    }
};

var p = new Proxy(a,handler);
console.log(p());
```

变量p是Proxy对象的实例,作为函数调用时(p())就会被apply方法拦截,返回一个字符串

##### (d) has()

用于拦截HasProperty操作,就是用于判断对象是否存在某个属性.**这个函数当中存在着一个典型的操作运算符 --- in**

例如: 使用has函数隐藏某些属性,使其不被in运算符发现

``` js
let handler = {
   has(target,key){
       if(key[0] === "_"){
           return false;
       }
       return key in target;
   }  
};

let target = { prop : 'AAA' , _prop : 'BBB'};
let p = new Proxy(target,handler);
console.log('_prop' in p);

```

> 小练习: 创建2个 用户对象,用户对象包含 name , age , salary(薪资)
>
> 我们要求验证:当余额大于5000  达到了全市的平均工资 

``` js
let handler = {
            has(target, prop) {
                if (prop === 'salary' && target[prop] < 5000) {
                    return false;
                }
                return prop in target;
            }
        };

        let u = {
            name: "张三",
            age: 16,
            salary: 3000
        };
        let u2 = {
            name: "李四",
            age: 16,
            salary: 6000
        };
        let u3 = {
            name: "王五",
            age: 16
        }
        let p = new Proxy(u3, handler);
        if ('salary' in p) {
            console.log('达标');
        } else {
            console.log('未达标');
        }
```

### 11. Reflect

ES6新提供的内容,Reflect对象的设计目的:

* 将Object对象的一些明显属于语言内部的方法放到Reflect对象上.未来新的方法将只在Reflect对象上部署.
* 修改某些Object对象方法的返回结果,让其变得更加合理
* 让Object操作都变成函数行为.
* Reflect对象的方法与Proxy对象的方法一一对应,只要是Proxy对象的方法,就能在Reflect对象上找到对应的方法

#### 11.1 静态方法

* Reflect.apply(target,thisArg,args)
* Reflect.construct(target,args)
* Reflect.get(target,name,receiver)
* Reflect.set(target,name,value,receiver)
* Reflect.defineProperty(target,name,desc)
* Reflect.deleteProperty(target,name)
* Reflect.has(target,name)
* Reflect.ownKeys(target)
* Reflect.isExtensible(target)
* Reflect.preventExtensions(target)
* Reflect.getOwnPropertyDescriptor(target,name)
* Reflect.getPrototypeOf(target)
* Reflect.setPrototypeOf(target,prototype)

#### 11.2 get函数

Reflect.get方法查找并且返回 target对象的name属性,如果没有这个属性,返回 undefined

``` js
let stu = { realname:'张三',age:16,gender:'男'};
Reflect.get(stu,'realname');
Reflect.get(stu,'score');
```

get方法当中第三个参数receiver 如果给name属性部署了读取函数(getter),则读取函数的this绑定receiver

#### 11.3 set函数

``` js
let stu = { name:"",age:17};

Reflect.set(stu,"age",3);

console.log(stu.age); //这个地方的结果为3

```

#### 11.4 has函数

``` js
//原始写法:
var stu = {name:"",age:17};
//我想要知道这个学生对象当中是否存在 score属性
//旧的写法
"score" in stu
//新的写法
Reflect.has(stu,"score");
```

**has函数或者in运算符如果第一个位置上的参数不是对象的话,会报错**

#### 11.5 实现观察者模式

观察者模式(P吧server mode) 指的是函数自动观察数据对象的模式,一旦这个对象发生改变,函数就会自动执行

观察者模式我们一般是通过Proxy对象实现的

``` js
let p = observable({name:'张三',age:16,gender:'男'}); //这个就是代表这个对象是观察目标

function show(){
    console.log(`${p.name},${p.age}`);
}

//下面我们需要设定观察者
observe(show);
p.name = '李四'; //这个是更改对象当中的name属性值,用来触发观察者的方法

//我们需要把上面的observable和observe两个函数实现了
```

我们现在在上面的代码当中明确p对象是观察目标,函数show是观察者,只要数据对象发生改变,就需要show函数自动执行

想要实现观察者模式我们需要使用Proxy编写一个观察者模式的最简单实现,即实现observable和observer这两个函数

下面的代码是针对于 observable和observe两个函数的声明

``` js
let haha = new Set(); //实现观察者的声明赋值过程

let observe = fn => haha.add(fn); //这个是我们声明的观察者函数
let observable = obj => new Proxy(obj,{set}); //这个是我们声明的观察者目标函数

function set(target,key,value,receiver){ //设定拦截的set函数
    let rs = Reflect.set(target,key,value,receiver);
    haha.forEach(observer => observer());
    return rs;
}
```

### 12. Promise对象

Promise是异步编程的一种解决方案,比我们之前学习的传统的解决方法(回调函数和事件),更合理且强大

Promise简单来说他就是一个简单的容器,里面保存了未来某个事件才会结束的事件的结果

Promise的特点:

1. 对象的状态不受外界的影响(3种状态: 进行中(Pending),已成功(FulFilled),已失败(Rejected))
2. 一旦状态改变了就不会再改变,任何时候 都可以得到这个结果

  Promise对象状态的改变只有2种情况

(1) 进行中  ---> 已成功

(2) 进行中  ---> 已失败

**只要状态到达了 已成功或者已失败,结果就不会在发生改变了,会一直保持这个结果,这个时候或者说这个状态我们叫做已定型(Resolved)**

Promise的缺点:

(1) 无法取消,一旦新建它就会立即执行,无法中途取消

(2) 如果我们不设置回调函数,Promise内部抛出的错误不会反应到外部

(3) 当处于Pending状态时,我们无法得知目前进展到哪一个阶段了(这个阶段指的时刚刚开始还是即将完成)

#### 12.1 语法

``` js
let promise = new Promise(function(resolve,reject){
   //异步代码 
});
```

Promise创建的时候,接受一个函数作为参数,这个函数带有2个参数resolve和reject,这个两个参数也是两个函数内容,这两个函数是由JavaScript引擎提供的,不用我们自己部署.

resolve函数的作用是: 将Promise对象的状态从"未完成"变为"成功",在异步操作成功时调用,并将异步操作的结果作为参数传递出去

reject函数的作用是: 将Promise对象的状态从"未完成"变为"失败",在异步操作失败时调用,并将异步操作的结果作为参数传递出去

当Promise实例生成之后,我们可以使用then方法分别指定Resolved状态和Rejected状态的回调函数

``` js
promise.then(function(value){
 	//当成功的时候,回调   
},function(error){
    //当失败的时候,回调
})
```





### 13. 修饰器



<<<<<<< HEAD
### 14. Echarts 图表元素

官网:[https://echarts.apache.org/zh/index.html](https://echarts.apache.org/zh/index.html)

简单案例:
=======
### 14. Echarts 

这个是Apache旗下的一种制作图表的js文件，我们需要通过这个内容做条形图，折线图，饼图。

想要使用这个内容我们首先需要到官网对其进行下载，官网网址为：[https://echarts.apache.org/zh/index.html](https://echarts.apache.org/zh/index.html)

使用的时候我们需要在页面内，先去引入下载下来的echarts.js文件之后按照下面的示例，进行简单的使用。

下面为简单使用代码：

#### 14.1 条形图的简单使用

(1) 我们需要在页面内引入之前下载echarts.js文件
``` html
<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8" />
    <title>ECharts</title>
    <!-- 引入刚刚下载的 ECharts 文件 -->
    <script src="echarts.js"></script>
  </head>
  <body>
    <!-- 为 ECharts 准备一个定义了宽高的 DOM -->
    <div id="main" style="width: 600px;height:400px;"></div>
    <script type="text/javascript">
      // 基于准备好的dom，初始化echarts实例
      var myChart = echarts.init(document.getElementById('main'));

      // 指定图表的配置项和数据
      var option = {
        title: {
          text: 'ECharts 入门示例'
        },
        tooltip: {},
        legend: {
          data: ['销量']
        },
        xAxis: {
          data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
        },
        yAxis: {},
        series: [
          {
            name: '销量',
            type: 'bar', //这个是设置图标样式: bar 条形图 , 
            data: [5, 20, 36, 10, 10, 20]
          }
        ]
      };

      // 使用刚指定的配置项和数据显示图表。
      myChart.setOption(option);
    </script>
  </body>
</html>
```


(2) 之后再body标签内设定一个用于引入Echarts的容器,我们可以在这个容器上设定宽度和高度,这个宽度和高度也会应用在Echarts上
```html



<body>
    <div id="main" style="width:500px;height:400px;">
         
    </div>
</body>
```

(3) 之后我们只需要在div的下面通过script标签对Echarts进行初始化,并且通过setOption方法把Echarts的选项引入到初始化的div里面即可.

``` html
<body>
    <div id="main" style="width:500px;height:400px;">
         
    </div>
    <script>
    	var ecs = echarts.init(document.querySelector("#main")); //在设定好的容器中,初始化echarts实例
        var opt ={
            title:{
                text:'成绩表条形图'
            },
            legend:{
                data:['scores']
            },
            xAxis:{
                data:['语文','数学','英语']
            },
            yAxis:{},
            series:{
                name:'scores',
                type: 'bar',
                data:[90,70,50]
            }
        }; //设定echarts的选项设置
    	ecs.setOption(opt); //把选项设置引入到echarts实例当中,并且显示条形图
    </script>
</body>
```

完成上面的代码之后就会有如下的效果

![](imgs/29.png)

#### 14.2 折线图

前两个步骤是一样的, 之后我们主需要把series属性当中的type值改为line,就可以变成折线图,具体代码如下:

``` html
<body>
    <div id="main" style="width:500px;height:400px;">
         
    </div>
    <script>
    	var ecs = echarts.init(document.querySelector("#main")); //在设定好的容器中,初始化echarts实例
        var opt ={
            title:{
                text:'成绩表条形图'
            },
            legend:{
                data:['scores']
            },
            xAxis:{
                data:['语文','数学','英语']
            },
            yAxis:{},
            series:{
                name:'scores',
                type: 'line',
                data:[90,70,50]
            }
        }; //设定echarts的选项设置
    	ecs.setOption(opt); //把选项设置引入到echarts实例当中,并且显示条形图
    </script>
</body>
```

运行上面代码就会得到如下的效果图.

![](imgs/30.png)

#### 14.3 饼图

前两个步骤一致,之后因为饼图不需要x,y轴坐标,所以我们需要把xAxis和yAxis属性去掉,并且在series属性当中传递的值需要放生更改,具体代码如下:

``` html
<body>
    <div id="main" style="width:500px;height:400px;">
         
    </div>
    <script>
    	var ecs = echarts.init(document.querySelector("#main")); //在设定好的容器中,初始化echarts实例
        var opt ={
            title:{
                text:'成绩表条形图'
            },
           legend:{
               data:["scores"]
           },
            series:{
                name:'scores',
                type: 'pie',
                data:[
                    {
                        name:'语文',
                        value:90
                    },
                    {
                        name:'数学',
                        value:70
                    },
                    {
                        name:'英语',
                        value:50
                    },
                ]
            }
        }; //设定echarts的选项设置
    	ecs.setOption(opt); //把选项设置引入到echarts实例当中,并且显示条形图
    </script>
</body>
```

展示后的效果如下:

![](imgs/31.png)
>>>>>>> a5da05a623a6ed3bb6333e84a5ba7c641667a78d



## 四. Vue

搭建开发环境

(1) 安装 node.js

官方网址: [http://nodejs.cn/download/](http://nodejs.cn/download/)

**我们要下载的内容一定是长期支持版,不要最新版**

(2) 安装 cnpm

我们安装node.js的时候,会自动安装npm的包安装器,npm连接的软件库是国外的网址,在我们国内下载的内容比较慢,而且失败的风险比较大,所以我们国内开发人员一般都会选择更改或者安装cnpm的内容,这个的库是国内的,一般般都是淘宝镜像

``` shell
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

安装之后,我们可以通过 npm --version 查看是否安装成功

(3) 安装 vue

vue官方网址:[https://cn.vuejs.org/v2/guide/](https://cn.vuejs.org/v2/guide/)

安装方式:

npm

``` shell
npm install -g @vue/cli
```

cnpm

``` shell
cnpm install -g @vue/cli
```

安装完成之后,我们可以通过vue --version 进行查看安装的vue脚手架版本

Vue 分两种使用方式: 1. 使用vue.js文件进行操作   2. 脚手架创建vue项目

第一种外面没人使用,这种只适合我们前期学习操作

我们后面主要学习的内容一定是第二种,而且不管前后端第二种方式必会

### 1. 简介

Vue.js是一套响应式系统,前端开发库. 其他前端开发库也有很多,例如: jQuery , ExtJS , Angular ,React等.

Vue.js是由一位美籍华人尤雨溪开发的.

Vue.js主要的特点:

1. 轻量级框架

​    Vue.js能够自动追踪依赖的模板表达式和计算属性,提供MVVM数据绑定和一个可组合的组件系统,具有简单,灵活的API,能够更快的上手

2. 双向数据绑定

  声明式渲染是数据双向绑定的主要体现,同样也是Vue.js的核心,它允许采用简介的模板语法将数据声明式渲染整合进DOM 

3. 指令

  Vue.js与页面进行交互,主要就是通过内置指令来完成的,指令的作用是当其表达式的值改变时相应地将某些行为应用到DOM上

4. 组件化

   组件(Component)是Vue.js最强大的功能之一. 组件可以扩展HTML元素,封装可重用的代码. 在Vue中,父子组件通过props传递通信,从父向子单项传递. 子组件与父组件通信,通过触发事件通知父组件改变数据.这样就形成了一个基本的父子通信模式.

5. 客户端路由

   Vue-router 是Vue.js官方的路由插件,与Vue.js深度集成,用于构建单页面应用.Vue单页面应用是基于路由和组件的,路由用于设定访问路径,并将路径和组件映射起来,传统的页面是通过超链接实现页面的切换和跳转的.

6. 状态管理

   状态管理实际就是一个单项的数据流,State驱动View的渲染,而用户对View进行操作产生Action,使State产生变化,从而使View重新渲染,形成一个单独的组件.

### 2. Vue.js的下载与引用

我们去官网进行下载文件

![](imgs/28.png)

我们学习的时候尽量使用的是开发版,但是我们很少直接下载本地文件,因为以后我们出去做开发的时候,并不是这么引入项目的,这个内容只是让我们学习的

我们学习的时候推荐使用的是第二种方式,引入cdn当中vue文件,这种方式要求我们电脑必须联网,我们需要在页面内,添加如下的script标签

``` html
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
```

### 3. Vue的使用

#### 3.1 实例化Vue对象,数据和方法

在使用vue的时候,首先我们需要去实例化一个 vue对象,在实例化的时候我们还需要传递一个对象的参数

``` js
let 对象名 = new Vue({
    
});
```

我们传递参数的对象包含如下属性,这些数据是可选的

(1) el   --->  选择对象的挂在元素,就是设定我们在html页面当中哪个位置上需要使用这个vue的对象

(2) data ---> 设定我们的数据内容

(3) methods ---> 设定我们要操作的方法

(4) tamplate ---> 设定我们在html当中要使用的模板的

(5) mounted --->  设定vue的声明周期钩子函数的 (重点)

例如:

``` html
<body>
    <div id="app">
        <h3>{{msg}}</h3>
        <p>
            {{show()}}
        </p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script>
        //1. 实例化vue对象
        let vue = new Vue({
            el: "#app",
            data: {
                msg: "Hello World",
                name: "张三",
                age: 16
            },
            methods: {
                show: function() {
                    return "学生姓名:" + this.name + ",学生年龄:" + this.age;
                }
            }
        });
    </script>
</body>
```

#### 3.2 Vue指令

指令(Directives) 是我们vue当中用于在界面当中操作vue对象数据的一系列带有v-前缀的特殊属性.

指令的职责是当其表达式的值发生改变的时候相应地将某些行为应用到DOM上.

##### 3.2.1 v-html

这个指令是让我们展示数据当中包含元素标签或者样式的

**我们vue当中的所有指令都是充当标签内部的属性来进行使用的,使用指令的时候,如果原标签内部有内容,则会把原始内容覆盖掉,显示指令指定的内容**

``` html
<body>
    <div id="app">
        <p>{{msg}} hahaha</p> <!-- 这种插值表达式的写法不识别html代码,后面的标签内的元素会显示 -->
        <p v-html="msg">hahahalalla</p> <!-- 指令设定的内容会识别html代码,标签内的内容会被覆盖掉,不显示 -->

    </div>
    <script src="js/vue.js"></script>
    <script>
        let vue = new Vue({
            el: "#app",
            data: {
                msg: "<strong>Hello World!!</strong>"
            }

        })
    </script>
</body>
```

##### 3.2.2 v-text

让我们显示指定的内容的,并且这个是不识别标签或者样式内容的

> 我们已经有了插值表达式了,为什么还要有这种的指令呢?
>
> 因为当我们电脑网络较差的时候,导致某个页面加载过慢的时候,插值表达式的内容会显示在页面当中,但是我们通过v-text指令添加的内容并不会展示,这样的写法更安全点,但是我们也不常用,因为v-text这种指令的写法对于字符串的拼接并不是特别的友好

##### 3.2.3 v-if

这个主要是让我们用于做判断的,用于判断，当v-if当中的值是true，则展示，为false隐藏不显示

``` html
<div id="app">
    <ul>
        <li>张三</li>
        <li>李四</li>
        <li v-if="result">猿师傅</li>
    </ul>
</div>
....
<script>
	var vue = new Vue({
        el:"#app",
        data:{
            result:true
        }
        
    });
</script>
```



##### 3.2.4 v-else

这个是与v-if连用的，要求写一起

``` html
<div id="app">
    <ul>
        <li>张三</li>
        <li>李四</li>
        <li v-if="result">猿师傅</li>
        <li v-else>电月画</li>
    </ul>
</div>
....
<script>
	var vue = new Vue({
        el:"#app",
        data:{
            result:true
        }
        
    });
</script>
```



##### 3.2.5 v-for

``` html

<div id="container">
    <ul class="nav">
        <li v-for="stu in stuArr" [:key="index"]>{{stu}}</li>
    </ul>
</div>

<script src="js/vue.js"></script>
<script>
	var vue = new Vue({
       el : ".nav",
       data: {
           stuArr:[ "张三","李四","王武"]
       } 
    });

</script>

```

:key代表的是绑定索引,这个内容是可以省略的,如果里面遍历的内容是普通数组内容,则不需要写,如果里面遍历的内容是复杂的数据,则需要输入一个值用于存储索引值

var-for的用法更加的贴近于C#的foreach循环,用于遍历后面集合当中的每一项的值

##### 3.2.6 v-model

双向绑定,在vue当中特主要,这属性一般用表单元素

``` html

<form id="aaa">
    <input type="text" v-model="title(vue当中设定的数据名称)" />
    <p>
        {{title}}
    </p>
</form>

<script src="js/vue.js"></script>
<script>
	var vue = new Vue({
       el : "#aaa",
       data: {
           title:""
       } 
    });

</script>


```

##### 3.2.7 v-bind

在Vue当中这个是让我们用来绑定属性值的

``` html
<div id="app">
    <span v-bind:id=""></span>
</div>
.....
<script>
	var vue = new Vue({
       el:"#app",
       data:{
           name:"sp01" //我们现在想要把这个值绑定
           //上面span的id属性当中，上面是全部写法，我们还可以进行省略，把v-bind省略掉，直接:id="name"
       } 
        
    });

</script>
```



##### 3.2.8 v-on

v-on是用来绑定事件方法的，例如点击事件等等

``` html
<div id="app">
    <button v-on:click="ClickMe()">
        
    </button>
    <button @click="ClickMe()">
        
    </button>
    <!-- @就是v-on的缩写 -->
</div>
.....
<script>
	var vue = new Vue({
       el:"#app",
       methods:{
           //这个代表我们当前vue当中所带有的事件
           ClickMe:function(){
               
           },
           ClickMe2(){
               
           }
       }
        
    });

</script>
```

**方法参数的几种使用方式**

（1）最简易的在绑定事件的时候直接书写自增，自减

``` html
<button v-on:click="a+=1"></button>
```

（2）直接跟方法，在方法中调用vue对象的内容作为参数，语法如下：

``` html
<button @click="add"></button>
```

（3）直接在方法后跟上参数，语法如下：

``` html
<button @click="add(x1,x2)"></button>
```

> 小练习：在vue对象当中定义3个变量a,b,c，之后再去定义2个方法其中第一个方法名字叫做show1,里面的操作为把a+1的值赋值给b，第二个方法叫做show2，这个方法带有2个参数，分别是a,b，之后把这两个参数相加的和赋值给c，最后我们在页面上通过button来分别调用，显示对应的值。

**事件修饰符**

Vue为v-on指令提供了事件修饰符来处理DOM事件细节，如: event.preventDefault( )或event.stopPropagation( )

Vue通过由“.”表示的指令后缀来调用修饰符

常见的修饰符如下:

| 修饰符关键字 | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| .stop        | 阻止.....                                                    |
| .prevent     | 用来阻止浏览器的默认事件的，浏览器的默认事件包括3种：（1）超链接的自动跳转（2） form标签中的submit按钮点击导致的页面刷新（3）网页中右键单击，会弹出一个菜单 |
| .capture     | 这个含义是捕捉                                               |
| .self        | 代表只有当事件在该元素本身（而不是子元素）触发时触发回调     |
| .once        | 代表该事件只能点击一次                                       |

使用方式如下：

``` html
<!-- 阻止单击事件冒泡 -->
<a v-on:click.stop="函数名"></a>

<!-- 提交事件不再重新加载页面 -->
<form v-on:submit.prevent="函数名"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.repevent="函数名"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件侦听器时，使用事件捕捉模式 -->
<div v-on:click.capture="函数名">
    ...
</div>

<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
<div v-on:click.self="函数名">
    ...
</div>

<!-- click 事件只能点击一次 -->
<a v-on:click.once="函数名"></a>

```

**按键修饰符**

Vue允许在监听键盘事件时，为v-on添加按键修饰符。

例如：只有在keyCode是13时，调用aaa方法

``` html
<input v-on:keyup.13="aaa" />
```

记住所有的keyCode比较困难，所以Vue为最常用的按键提供了别名:

``` html
<input v-on:keyup.enter="aaa" />
```

缩写语法如下：

``` html
<input @keyup.enter="submit" />
```

全部的按键别名包括: .enter,.tab,.delete(捕获"删除"和“退格”键)，.esc,.space,.up,.down,.left,.right,.ctrl,.alt,.shift,.meta。

##### 3.2.9 v-once

v-once在日常开发当中用得很多，该指令表示元素和组件只渲染一次，不会随着数据的改变而改变。

只渲染元素和组件一次，随后的渲染使用此指令的元素/组件及其所有的子节点，都会当作静态内容并跳过，这可以用于优化更新性能。

##### 3.2.10 v-show

v-show指令主要用来决定它所在区块显示与否、

语法如下：

``` html
<p v-show="一个布尔值"></p>
```

其中布尔值为true的时候所在区域显示，否则不显示。

> 面试题：
>
> v-if与v-show的区别：
>
> v-show仅是隐藏/显示，值为false时，该元素依旧存在于DOM树中。若其原有样式设置了display:none，则会导致其无法正常显示。
>
> v-if是动态添加，当值为false时，完全移除该元素，即DOM树种不存在该元素。
>
> 



#### 3.3 Vue.js 过滤器的使用

Vue.js允许我们自己定义过滤器，用于常见的文本格式化，由“管道符”指示，格式如下：

``` html
{{ 属性名 | 自定义函数}} <!-- 写在两个花括号中 -->
<!-- 在v-bind指令中 -->
<div v-bind:id="rawId | formatId"></div>
```

过滤器函数接受表达式的值作为第一个参数。

我们还需要在vue对象当中引入过滤器的属性

``` html
<script>
	var vue = new Vue({
        el:"xx",
        filters:{
            //这个里面书写自定义过滤器的处理函数
            自定义函数名:function(value){
                
            }
        }
    })

</script>
```

> 练习题： 在vue对象当中声明一个属性，属性值为dianyuehua,要求通过过滤器把这个属性值的首字母改为大写

**过滤器串联**

我们可以同时使用多个过滤器，多个过滤器通过“|”关联到一起。

代码格式如下：

``` html
{{message | filterA | filterB}}
```

过滤器是JavaScript函数，因此可以接受参数。

``` html
{{message | filterA('arg1',arg2)}}
```

其中message是第一个参数，字符串'arg1'将传给过滤器作为第二个参数，arg2表达式江北求值，然后传给过滤器作为第三个参数



#### 3.4 计算属性

##### 3.4.1 什么是计算属性

我们现在可以写一些简单的vue应用了，但是如果表达式过长，或者逻辑更为复杂时，就会变得臃肿甚至难以阅读和维护，例如：

``` html
<div>
    {{ text.split(',').reverse().join(',') }}
</div>
```

这里的表达式包含3个操作，并不是很清晰，所以在遇到复杂的逻辑时应该使用计算属性。我们可以对上面的代码使用计算属性进行改写。

``` html
<div id="app">
    {{ reversedText }}
</div>
<script>
	var app = new Vue({
       el:"#app",
       data:{
           text:"123,456"
       },
       computed:{
           reversedText:function(){
               return this.text.split(',').reverse().json(',');
           }
       } 
        
    });
</script>
```

**所有的计算属性都以函数的形式写在Vue实例内的computed选项内，最终返回计算后的结果。**

##### 3.4.2 计算属性用法

在一个计算属性里可以完成各种复杂的逻辑，包括运算，函数调用等，只要最终返回一个结果就可以，除了上面例子中简单的用，计算属性还可以依赖多个Vue实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。



> 我们在这个地方要求实现一个类似于购物车的效果

#### 3.5 组件

**以后的vue开发都是组件化开发**

组件(Component)是vue最强大的功能之一，可以扩展HTML元素，封装可以重用的代码。组件系统使我们可以独立可复用的小组件来构建大型应用，几乎任意类型的应用界面都可以抽象为一个组件树。

##### 3.5.1 全局组件

注册全局组件有两种方式：

(1) 普通注册

(2) Vue构造器注册

**（1）普通注册 **

注册一个全局组件的语法如下:

``` js
Vue.component(组件名,配置选项);
```

当我们完成上面的组件的注册之后，在想要使用这个组件内容的时候，只需要在html页面内，进行调用这个组件即可，实现方式如下：

``` js
<组件名></组件名>
```

**我们注册的组件要求必须写在vue对象实例化的上面**

**（2）Vue构造器**

格式如下：

``` js
var 组件内容 = Vue.extend({
    template:'这个里面书写组件当中包含的内容'
});
Vue.component("组件名称",组件内容);
```

上面代码中Vue.extend( )是Vue构造器的扩展，调用Vue.extend( )创建的是一个组件构造器，而不是一个具体的组件实例。

Vue.extend( )构造器有一个选项对象，选项对象的template属性用于定义组件要渲染的HTML。

使用Vue.component( )注册组件时，需要提供2个参数，第1个参数是组件的标签，第2个参数是组件构造器。

Vue.component( )方法内部会调用组件构造器，创建一个组件实例。

##### 3.5.2 局部组件

我们也可以在实例选项中注册局部组件，这样组件只能在这个实例中使用。

调用Vue.component( )注册组件时，组件的注册是全局的，这意味着该组件可以在任意Vue实例下使用。

如果我们不需要全局注册，或者只是在其他组件内使用该组件，可以用选项对象的components属性实现局部注册。

注册一个简单的局部组件并使用它，主要分为3个步骤：

（1）创建一个组件模板

``` js
var info= {
    template:"模板内容"
};
```

（2）在Vue的根实例中，使用components来注册组件

``` js
var vue = new Vue({
    el:"#app",
    components:{
        '组件名':我们上面定义的模板
    }
    
})
```

（3）在html当中使用局部组件

``` html
<div id="app">
    <组件名></组件名>
</div>
```



#### 3.6 vue的生命周期

![](imgs/45.png)

#### 3.7 Watch监视



#### 3.8 vue cli

##### 3.8.1 简介

Vue Cli 是一个基于Vue.js进行快速开发的完整系统，它所提供了:

* 通过@vue/cli 实现的交互式的项目脚手架
* 通过@vue/cli + @vue/cli-service-global 实现的零配置原型开发
* 一个运行时依赖（@vue/cli-service），该依赖：
  * 可升级
  * 基于webpack构建，并带有合理的默认配置
  * 可以通过项目内的配置文件进行配置
  * 可以通过插件进行扩展
* 一个丰富的官方插件集合，集成了前端生态中最好的工具
* 一套完全图形化的创建和管理vue.js项目的用户界面

我们想要使用cli来创建项目，首先我们需要通过npm来进行安装@vue/cli

> 注意： Vue Cli的包名由原来的vue-cli改为了@vue/cli,如果之前安装了老版的cli，我们需要先通过卸载命令： npm uninstall vue-cli 进行卸载，之后再去安装新版的cli。

安装命令如下：

``` shell
npm install -g @vue/cli
```

安装之后我们可以通过vue命令来进行查看，是否安装成功。

``` shell
vue --version
```

##### 3.8.2 创建第一个项目

我们可以在控制台（cmd）通过下面的命令来创建项目

``` shell
vue create 项目名
```

例如：

![](imgs/34.png)

我们进行创建一个名字叫做hello world的项目，空格位用横线连接，输入完上面的命令我们回车执行，如果我们连接的npm仓库网速过慢，则会提示是否更改一个源，进行更快的安装。

![](imgs/35.png)

我们输入y进行更换源，之后则会询问我们是否采用默认模板来快速构建项目，这个地方我们一般选择最后一项，手动创建，我们可以通过方向键来进行更改高亮项，我们把最后一项Manually Select features选为高亮。这个选项是让我们来进行手动进行配置。

![](imgs/36.png)

选择完成之后，就会进入到下面的界面当中

![](imgs/37.png)

上面内容当中babel为js的编译器，Linter/Formatter这个是设定我们代码标准的，这两个是我们的默认选项，其余选项是我们可以根据自己项目的需求自己进行选择的，这次创建项目我们就采用默认的这种方式来进行。

我们直接回车，就进行入下一个页面，下个页面是让我们选择vue.js的版本，我们默认采用vue.js 3.x版本。

![](imgs/38.png)

我们回车，进入下一个界面这个界面是让我们选择书写代码标准和格式化的，我们先采用默认的值即可，直接回城进入下个界面。

![](imgs/39.png)

进入下个界面之后会让我们选择如果代码当中出现不符合lint规则的代码时，如何处理。

![](imgs/40.png)

**Lint on save**

这种要求是 当代码文件中有代码不符合lint规则时，会在编译（compile）阶段提示warning。如果出现了语法错误，会直接在页面上显示error。

**Lint and fix on commit**

这种要求是 代码除了语法错误导致的error外不会提示warning。而是在当前项目进行git commit操作的时候，通过githook，在pre-commit阶段执行lint和fix操作，自动帮我们把有语法错误的地方修改为符合规范。

我们这次创建项目的时候暂时默认选择第一项，直接回车。

回车之后，我们会进行选择配置文件的类型，是config文件还是json文件，我们这个选择现在比较统一，都是选择json文件。我们通过方向键选择In package.json,之后回车。 当这个操作做完我们也到了最后一步了，它会提示我们是否保存这次的配置，我们直接输入N，不保存即可。

![](imgs/41.png)



当我们完成上面的配置之后，就会进入项目创建的过程，这个过程比较漫长，创建出来的内容比较多，所以需要耐心等待下。

##### 3.8.3 Props属性

props是父组件用来传递数据的一个自定义属性。父组件的数据需要通过props属性传给子组件，子组件需要显式地用props选项声明“props”。

我们下面做一个示例:定义一个组件，然后通过props属性传递内容。

主要有2个步骤：

（1）注册一个自定义名称为FirstDemo的组件文件，同时声明props,代码如下：

   ![](imgs/42.png)

 （2） 在html视图中，使用自定义组件，同时通过props属性的变量content来传递值到组件，代码如下：

![](imgs/43.png)



#### 3.9 Axios

这个是基于Promise的HTTP库，帮助我们实现异步操作。

**Axios特性：**

* 从浏览器中创建XMLHttpRequests
* 从node.js创建HTTP请求
* 支持Promise Api
* 拦截请求和响应
* 转换请求数据和响应数据
* 取消请求
* 自动转换JSON数据
* 客户端支持防御XSRF

**安装**

``` shell
npm install axios
```

安装之后我们需要去main.js当中进行引入配置

``` js
import axios from 'axios'
```

安装完成之后我们就可以通过这个对象来进行请求数据的操作了。

> 如果我们在main.js文当中引入了，但是其他的组件当中还是无法启用，这种情况我们可以按照下面的对main.js进行修改
>
> <img src="imgs/44.png" style="zoom:50%;" />

**基本使用**

执行GET请求

我们一般要进行GET请求的时候都是在查询，查询的时候分为无条件查询和条件查询

``` js
//当我们要进行提交请求的时候
axios.get('要访问的路径[?参数名=值]')
.then(function(response){
    //执行成功的时候
})
.catch(function(error){
    //执行失败的时候
})

//上面的请求我们也可以按照下面的来写
axios.get('要访问的路径',{
    params:{
        参数名:值
    }
})
.then(function(response){
    
})
.catch(function(error){
    
})
```

上面的Get请求第二种方式我们用的比较多。

执行POST请求

``` js
axios.post('访问路径',{参数})
.then(function(response){ })
.catch(function(error){ })
```









#### 3.10 Router

##### 3.10.1 路由基础

**1. 什么是路由**

路由就是我们用于进行界面跳转的那个网址路径，当我们每次通过网址进行跳转页面的时候，在web服务器进程中，该路径都都对应者相应的处理逻辑，程序会把请求交给路径对应的处理逻辑，这样就完成了一次“路由分发”。

对于单页面应用程序来说，主要通过的URL中的hash(#号)来实现不同页面之间的切换。HTTP请求中不会包含和hash相关的内容，所以单页面应用程序中的页面跳转主要由hash实现。在单页面应用程序中，这种通过hash改变切换页面的方式，称为前端路由（区别后端路由）。

前端路由主要是根据不同的用户事件，显示不同的页面内容，本质上是用户事件与事件处理函数之间的对应关系。

##### 3.10.2 Vue Router

Vue.js官方提供了一套专用的路由工具库Vue Router,也叫作路由管理器，并且与Vue.js的核心深度集成，让构建单页面应用程序变得非常简单。路由实际上可以理解为指向，就是在页面上单击一个按钮需要跳转到对应的页面，这就是路由跳转。这里需要理解下面三个词语的区别：

（1）route：是个单数，译为路由。即可以理解为单个路由或某一条路由。

（2）routes：是个复数，表示多个路由的集合，JavaScript中表示多种不同状态的集合形式只有数组和对象两种，事实上官方定义routes是表示多个数组的集合。

（3）router：译为路由器，一个包含route和routes的容器，或者说router是一个管理者，负责管理route和routes。例如：当用户在页面上单击按钮的时候，router就会在routes中查找route,即路由器会在路由集合中查找对应的路由。具体功能如下：

* 嵌套的路由 / 视图表
* 模块化的、基于组件的路由配置
* 路由参数、查询、通配符
* 基于Vue.js过渡系统的视图过渡效果
* 细粒度的导航控制
* 自定义的滚动条行为



**1. 安装**

安装的时候分为两种形式：

（1）创建项目的时候，直接选中安装路由。

（2）在创建项目的时候，没有安装，之后执行下面的命令进行安装

``` shell
npm install vue-router@4
```

其中@后面的代表的是版本，如果不想写版本改成next。



Vue Router 是vue的一个插件，需要在Vue的全局应用中通过Vue.use()方法将其纳入到实例中。在项目的main.js中如下：

``` js
import {createApp} from 'vue'
import App from './App.vue'
import router from './router' //从router文件夹下导入路由器
createApp(App).use(router).mount('#app') //将路由器启动并挂载到id='app'的div上
```



**2. 建立路由模块**

先建立一个路由模块来配置和绑定相关信息。在router文件夹下的index.js文件中使用createRouter方法创建一个路由器router。在路由器router指定两个内容，一个是用什么方法使用路由(有两种方法:history模式和hash模式)；另一个是路由数组。

其中，history模式使用下面的命令进行指定：

``` js
history：createWebHistory(process.env.BASE_URL)
```

hash模式使用下面的命令进行指定：

``` js
history:createWebHashHistory()
```

路由数组中的每一个元素是一条路由对象，一条路由对象由三部分组成:name、path和component。其中，name表示的链接名称；path表示当前路由规则匹配的hash地址；component表示当前路由规则对应要暂时的组件。

我们需要在router文件夹当中的index.js文件当中创建如下代码

``` js
import {createRouter , createWebHisotry} from 'vue-router' //从vue-router引入createRouter、createWebHashHistory方法
import HelloWorld from '../views/HelloWorld.vue'   //导入HelloWorld组件

const routes = [
    {
        path:'/',
        name:'HelloWorld',
        component:HelloWorld
    },
    {
        path:'/Login',
        name:'Login',
        component:() => import('../views/Login.vue') //引入文件的另一种方式
    }
]

//使用createRouter方法创建路由器router
const router = createRouter({
    history:createWebHistory(process.env.BASE_URL), //指定history模式
    routes   //定义路由数组，相当于routes:routes
})
export default router

```



**3. 路由重定向**

路由重定向是当用户在访问地址A的时候，强制用户跳转到地址B，从而展示特定的组件页面。通过路由规则的redirect属性指定一个新的路由地址，以设置路由的重定义。其中，path表示需要被重定向的原地址;redirect表示将要被重定向到的新地址。

例如：把根目录地址‘/’重定向到‘Login’,其代码如下：

``` js
import {createRouter , createWebHistory} from 'vue-router'
import Login from '../views/Login.vue'
const routes=[
    {
        path:'/', //根目录
        redirect:'/Login' //路由重定向到 '/Login'
    },
    {
        path:'/Login',
        component: Login
    }
]
const router = createRouter({
    history:createWebHistory(),
    routes
})

export default router
```



**4. 添加路由链接**

\<route-link>是Vue提供的标签，默认会被渲染为\<a>标签，to属性可以用来指定目标地址，to属性会被选软为\<a>标签的href属性。

例如：

``` html
<route-link to="home">Home</route-link>
```

上面的代码会被渲染成下面的效果：

``` html
<a href="home">Home</a>
```

使用v-bind的JavaScript表达式表示：

``` html
<router-link v-bind:to="home">Home</router-link>
<router-link :to="home">Home</router-link>
<router-link :to="{path: 'home'}">Home</router-link> <!-- 同上 -->
```

在v-bind绑定的to属性中定义对象，而在该对象中定义name属性进行路由命名。其实现语句如下:

``` html
<route-link :to="{name:'applename'}">to apple</route-link>
```

在使用命名路由之前，我们需要在项目脚手架router目录下的index.js文件中进行路由命名，然后name属性值才起作用，其实现语句如下：

``` html
const routes =[
	{
		path : '/home',
		name: 'applename',
		component:() => import('../views/Home.vue')
	}
]
```

如果需要定义带查询参数的路由，在对象中定义query属性，其属性值也定义为一个对象，在该对象中再来定义相关的属性和属性值。例如：在/home地址后面加上color=red属性和属性值，即地址变成:/home?color=red,实现代码如下：

``` html
<route-link :to="{path:'home',query:{ color:red } }">to Home</route-link>
```

无论是直接路由path、命名路由name还是带查询参数query，其地址栏都将转换成下面结果:

``` text
/url?查询参数名=查询参数值
```

##### 3.10.3 编程式导航

**1. 简介**

Vue中页面的导航有两种主要方式:一种是通过单击定义的链接实现导航的方式，叫作声明导航。例如：普通网页中的\<a>\</a>链接或Vue中的\<router-link>\</router-link>。另一种是通过调用JavaScript形式的API实现导航的方式，叫做编程式导航。

**2. 编程式导航的基本方法**

使用的时候我们首先必须先引入useRouter，代码如下：

``` js
import { useRouter } from 'vue-router'  //引入useRouter

const router = useRouter() //创建router
```

(1) router.push( )方法。如果要导航到不同的URL，则使用router.push( )方法。这个方法会向history栈添加一个新的记录，这样当用户单击浏览器中的"后退"按钮时，则退回到上一次访问的浏览器网页。另外，单击\<router-link :to="...">等同于调用router.push( )方法，该方法的参数可以使一个字符串路径，或者一个描述地址的对象。

例如：

``` js
//字符串
router.push('home')

//对象
router.push({ path: 'home'})

//命名的路由
router.push({ name:'user' , params:{ userId : '123' } })

//带查询参数，编程 /register?plan=private
router.push({ path:'register' , query:{ plan : 'private' } })
```

需要强调的是，如果提供了path参数，则params参数将会被忽略，上面的例子中的query并没有这个限制。当需要提供命名路由由name或手写完整的参数path时，可以使用一下语句实现:

``` js
const userId = '123'

router.push({ name : 'user' , params:{ userId } }) //导航到: /user/123
router.push({ path: `/user/${userId}`})            //导航到: /user/123

//下面的 params不生效
router.push({ path: '/user' , params:{ userId } }) //导航到: /user
```







#### 3.11 Vuex

##### 3.11.1 介绍

Vuex是一个专门为Vue.js应用程序开发的**状态管理模式+库。** 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

**什么是“状态管理模式”**

状态自管理应用包含以下几个部分：

* **状态**，驱动应用的数据源
* **视图**，以声明方式将**状态** 映射到视图
* **操作**，响应在**视图**上的用户输入导致的状态变化。  

运行模式如下(单向数据流)：

![](imgs/46.png)



**我们可以通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化易维护。**

这就是Vuex背后的基本思想，借鉴了Flux,Redux和The Elm Architexture。与其他模式不同的是，Vuex是专门为Vue.js设计的状态管理库，以利用Vue.js的细粒度数据响应机制来进行高效的状态更新。

![](imgs/47.png)

**什么情况下应该使用Vuex**

Vuex可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。

如果不打算做大型单页面应用，使用Vuex可能是繁琐冗余的。如果应用比较简单，您最好不要使用Vuex。如果需要构建一个中大型单页应用，我们可能会考虑如何更好地在组件外部管理状态，Vuex将会成为自然而然的选择。

##### 3.11.2 安装

我们可以通过下面的指令来进行安装

``` shell
npm install vuex@next --save
```

##### 3.11.3 使用

每一个vuex应用的核心就是store(仓库）。"store"基本上就是一个容器，它包含看你的应用中大部分的**状态(state)**。vuex和单纯的全局对象有以下两个不同点:

（1）Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。

（2）我们不能直接改变store中的状态。改变store中的状态的唯一途径就是显示地**提交(commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

**最简单的Store**

安装Vuex之后，让我们来创建一个store。创建过程直截了当——仅需要提供一个初始state对象和一些mutation：

我们在vue项目当中的src文件夹当中创建一个store文件夹，并且在这个文件夹当中创建一个index.js文件

![](imgs/48.png)



之后我们在这个文件内进行配置state和mutation,代码如下：

``` js
import{ createStore } from 'vuex'

export default createStore({
    state:{
        
    },
    getters:{
        
    },
    mutations:{
        
    },
    actions:{
        
    },
    modules:{
        
    }
})
```

之后我们还需要去main.js当中去注册使用一下vuex，代码如下：

``` js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

createApp(App).use(store).use(router).mount('#app')
```

例如：

在store文件夹下index.js当中代码：

``` js
import { createStore } from 'vuex'

export default createStore({
  state() {
    return{
        count:0
    }
  },
  getters: {
  },
  mutations: {
    increment(state){
       state.count++
    }
  },
  actions: {
  },
  modules: {
  }
})

```

之后我们去在views里面创建一个新的组件，例如：VuexDemoView.vue

``` js
<template>
    <button @click="haha">点击</button>

</template>

<script>

export default{

    name:'VuexDemoView',
    methods:{
        haha:function(){
            this.$store.commit("increment")
            console.log(this.$store.state.count)
        }
    }

}
```

然后我们去路由当中配置一下：

``` js
import { createRouter, createWebHashHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
  },
  {
    path:'/vuex',
    component:() => import('../views/VuexDemoView.vue')
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router

```

在App.vue当中添加当前页面的导航

``` js
<template>
  <nav>
    <router-link to="/">Home</router-link> |
    <router-link to="/about">About</router-link>|
    <router-link to="/vuex">Vuex</router-link>
  </nav>
  <router-view></router-view>
</template>
```

当我们点击Vuex的这个超链接的时候，我们就能进入到我们自己创建的组件当中，在控制台当中能看到我们每次点击按钮的时候，state数据的改变。

![](imgs/49.png)



##### 3.11.4 核心概念

###### a. State

我们可以在这对象当中存储一些共有的数据，之后我们在其他组件当中可以通过this.$store.state.xxx来进行调用。

###### b. getter对象

有时候组件当中获取到store中的state数据后，需要对其他进行加工后才能使用，computed属性中就需要用到写操作函数，如果有多个组件中都需要进行这个操作，那么在各个组件中都要写相同的而函数，如果有多个组件中都需要进行这个操作，那么在各个组件中都要写相同的函数，这就非常地麻烦。

这时可以把这个相同的操作写道store中的getters对象中。每个组件只要引用getter就可以了，非常方便。getter就是把组件中共有的对state的操作进行了提取，它相当于是state的计算属性。getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变，才会被重新计算。

> getter接受state作为其第一个参数。

getters可以用于监听state中的值的变化，返回计算后的结果。例如:

``` js
import {createStore} from 'vuex'

export default createStore({
    state:{
        name:'苹果',
        price: 8600
    },
    getters:{
        getterPrice(state){
            return state.price += 300
        }
    }，
    mutations:{
    
    },
    actions:{
                           
    },
    modules:{
        
    }
})
```

在组件当中我们可以按照下面的内容来进行书写

``` vue
<template>
	<div>
        <h1>产品名称：{{ name }}</h1>
        <h1>产品涨价后的价格: {{ getPrice }}</h1>
    </div>
</template>
<script>
	export default{
        name: 'HelloWorld',
        computed:{
            name(){
                return this.$store.state.name
            },
            price(){
                return this.$store.state.price
            },
            getPrice(){
                return this.$store.getters.getterPrice
            }
        }
    }
</script>
```



###### c. mutation对象

我们想要修改Vuex的store中的数据，唯一方法就是提交mutation。Vuex中的mutation类似于事件。每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。这个回调函数就是实际进行数据修改的地方，并且它会接受state作为第一个参数。

我们修改一下之前的例子，在项目中添加两个button标签，修改的数据将会渲染到组件当中。

``` js
import {createStore} from 'vuex'

export default createStore({
    state:{
        name:'苹果',
        price: 8600
    },
    getters:{
        getterPrice(state){
            return state.price += 300
        }
    }，
    mutations:{
    	addPrice(state,obj){
    		return state.price += obj.num;
		},
        subPrice(state,obj){
            return state.price -= obj.num;
        }    
    },
    actions:{
                           
    },
    modules:{
        
    }
})
```

修改HelloWorld.vue的代码如下:

``` vue
<template>
	<div>
        <h1>产品名称：{{ name }}</h1>
        <h1>产品涨价后的价格: {{ getPrice }}</h1>
        <button @click="handlerAdd()">涨价</button>
        <button @click="handlerSub()">降价</button>
    </div>
</template>
<script>
	export default{
        name: 'HelloWorld',
        computed:{
            name(){
                return this.$store.state.name
            },
            price(){
                return this.$store.state.price
            },
            getPrice(){
                return this.$store.getters.getterPrice
            }
        },
        methods:{
            handlerAdd(){
                this.$store.commit("addPrice",{
                    num:100
                })
            },
            handlerSub(){
                this.$store.commit("subPrice",{
                    num:100
                })
            }
        }
    }
</script>
```

###### d. action对象

action类似于mutation，不同之处如下：

* action提交的是mutation,而不是直接变更数据状态
* action可以包含任意异步操作。

在Vuex中提交mutation是修改状态的唯一方法，并且这个过程是同步的，异步逻辑都应该封装到action对象中。

action函数接受一个与store实例具有相同方法和属性的context对象，因此可以调用context.commit来提交一个mutation，或者通过context.state和context.getters来获取state和getters中的数据。

我们可以把上面的代码改为使用action对象执行异步操作，单击按钮后，异步操作在3秒后执行。

``` js
import {createStore} from 'vuex'

export default createStore({
    state:{
        name:'苹果',
        price: 8600
    },
    getters:{
        getterPrice(state){
            return state.price += 300
        }
    }，
    mutations:{
    	addPrice(state,obj){
    		return state.price += obj.num;
		},
        subPrice(state,obj){
            return state.price -= obj.num;
        }    
    },
    actions:{
        addPriceasy(context){
            setTimeout( () => {
                context.commit("addPrice",{
                    num:100
                })
            },3000)
        },
        subPriceasy(context){
             setTimeout( () => {
                context.commit("subPrice",{
                    num:100
                })
            },3000)
        }    
    },
    modules:{
        
    }
})
```

修改HelloWorld.vue的代码如下：

``` vue
<template>
	<div>
        <h1>产品名称：{{ name }}</h1>
        <h1>产品涨价后的价格: {{ getPrice }}</h1>
        <button @click="handlerAdd()">涨价</button>
        <button @click="handlerSub()">降价</button>
    </div>
</template>
<script>
	export default{
        name: 'HelloWorld',
        computed:{
            name(){
                return this.$store.state.name
            },
            price(){
                return this.$store.state.price
            },
            getPrice(){
                return this.$store.getters.getterPrice
            }
        },
        methods:{
            handlerAdd(){
                this.$store.commit("addPrice",{
                    num:100
                })
            },
            handlerSub(){
                this.$store.commit("subPrice",{
                    num:100
                })
            }，
            handlerAddasy(){
        		this.$store.dispatch("addPriceasy")
            },
            handlerSubasy(){
                this.$store.dispatch("subPriceasy")
            }    
        }
    }
</script>
```



##### 3.11.5 关于Vuex的几个问题

###### 问题1：Vuex和单纯的全局对象有什么不同？

Vuex和单纯的全局对象有以下两点不同：

（1）Vuex的状态存储是响应式的。当Vue组件从store中读取数据的时候，如果store中的状态发生变化，那么相应的组件也会相应地得到高效更新。

（2）不能直接改变store中的数据。改变store中数据的唯一途径就是显式地提交（commit）mutation。这样使得可以方便地跟踪每一个数据的变化，从而能够实现一些工具以帮助我们更好地了解应用。 

###### 问题2： 什么情况下使用Vuex?

Vuex可以帮助我们管理共享数据，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。

如果不打算开发大型单页应用，使用Vuex可能是烦琐冗余的。如果你的应用够简单，最好不要使用Vuex，一个简单的store模式就足够了。但是，如果需要构建一个中大型单页应用，那么可能要考虑如何更好地在组件外部管理数据，Vuex将会成为自然而然的选择。

一般情况下，只有组件之间共享的数据，才有必要存储到Vuex中，对于组件中的私有数据，一般存储在组件自身的data选项中即可。







#### 3.12 Vite

Vite是一个web开发构建工具，由于其原生ES模块导入方式，可以实现三点半的冷服务器启动。

通过在终端中运行以下命令，可以使用Vite快速构建Vue项目。  

``` shell
#npm 6.x
npm init vite@latest <project-name> --template vue

#npm 7+
npm init vite@latest <project-name> -- --template vue
```

通过上面的内容我们可以快速构

建项目，之后我们需要进入到这个项目的文件夹，之后把构建的内容安装到这个文件夹当中

``` shell
cd <project-name>
npm install
```

之后我们可以启动服务器，这个与我们之前通过cli创建的项目不一样，我们这次使用的是下面的指令

``` shell
npm run dev
```

> vite.config.js
>
> 这个文件是做全局配置，把我们自己添加的包在这个里面进行配置,好让我们这个包能在项目当中的任意位置上进行调用

走前端的需要把Webpack学了，这个Web项目的打包的



#### 3.13 Element Plus

官网：[https://element-plus.gitee.io/zh-CN/](https://element-plus.gitee.io/zh-CN/)

##### 3.13.1 设计模式

###### 一致性 Consistency

* 与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念
* 在界面中一致： 所有的元素和结构保持一致，比如：设计样式、图标和文本、元素的位置等。

###### 反馈 Feedback

* 控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；
* 页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。

###### 效率 Efficiency

* 简化流程：设计简洁直观的操作流程；
* 清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策
* 帮助用户识别： 界面简单直白，让用户快速识别而非会议，减少用户记忆负担。

###### 可控 Controllability

* 用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策。
* 结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。



##### 3.13.2 安装

我们可以通过npm进行安装

``` shell
npm install element-plus --save
```

之后我们需要在main.js中进行导入

``` js
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

createApp(App).use(ElementPlus).mount('#app')
```

##### 3.13.3 Element UI 基础

###### 1. Layout 布局

  通过基础的24分栏，迅速简便地创建布局。这个地方的使用与我们之前讲的Bootstrap当中的栅格系统比较类似。但是ElementUI是通过 row和col组件实现的，例如：

``` vue
<template>
	<el-row>
    	<el-col :span=“24”>
            <div>
                
    		</div>
    	</el-col>    
    </el-row>

</template>
```

其中，在el-col当中带有的 :span 属性是让我们用于控制这个内容占有多少格的属性，最多写24

我们还可以在el-row当中添加:gutter属性，来进行设定分栏之间的间隔（通过padding实现的）

例如：

``` vue
<template>
    <el-row :gutter="10">
        <el-col :span="4"><div class="grid-content bg-purple">aaaaa</div></el-col> 
        <el-col :span="4"><div class="grid-content bg-purple">aaaaa</div></el-col> 
        <el-col :span="4"><div class="grid-content bg-purple">aaaaa</div></el-col> 
        <el-col :span="4"><div class="grid-content bg-purple">aaaaa</div></el-col> 
    </el-row>
</template>

<script>

export default {
  name: 'HomeView',
 
}
</script>
<style>

  .bg-purple {
    background: #d3dce6;
  }
</style>

```

**分栏偏移**

我们可以在col组件当中添加 offset属性来进行指定分栏偏移的栏数

``` vue
<template>
  <el-row :gutter="20">
  <el-col :span="6">
      <div class="grid-content bg-purple"></div>
  </el-col>
  <el-col :span="6" :offset="6">
      <div class="grid-content bg-purple"></div>
    </el-col>
</el-row>
<el-row :gutter="20">
  <el-col :span="6" :offset="6">
      <div class="grid-content bg-purple"></div>
   </el-col>
  <el-col :span="6" :offset="6">
      <div class="grid-content bg-purple"></div>
  </el-col>
</el-row>
<el-row :gutter="20">
  <el-col :span="12" :offset="6">
      <div class="grid-content bg-purple"></div>
    </el-col>
</el-row>
</template>

<style>

  .bg-purple {
    background: #d3dce6;
  }
</style>
```

###### 2. 布局容器

使用布局的容器组件，方便我们能快速搭建页面的基本结构：

\<el-container>: 外层容器，当子元素包含\<el-header>或者\<el-footer>时，全部子元素回垂直上下排列，否则会水平左右排列

\<el-header>: 顶栏容器

\<el-aside>: 侧边栏容器

\<el-main>: 主要区域容器

\<el-footer>: 底栏容器

**以上组件采用了flex布局，其中\<el-container>的子元素只能是后四者，后死者的父元素也只能是\<el-container>**

![](imgs/54.png)

如上面的效果，代码如下:

``` vue
<template>
    <el-container>
        <el-header>header</el-header>
        <el-container>
           <el-aside>aside</el-aside> 
           <el-main>main</el-main>
        </el-container>
        <el-footer>footer</el-footer>
    </el-container>
</template>

<script>


export default {
  name: 'App',
}
</script>

<style>
*{
  text-align: center;
}
.el-header,
  .el-footer {
    background-color: #b3c0d1;
    color: var(--el-text-color-primary);
    text-align: center;
    line-height: 60px;
  }

  .el-aside {
    background-color: #d3dce6;
    color: var(--el-text-color-primary);
    text-align: center;
    line-height: 200px;
  }

  .el-main {
    background-color: #e9eef3;
    color: var(--el-text-color-primary);
    text-align: center;
    line-height: 160px;
  }

  body > .el-container {
    margin-bottom: 40px;
  }

  .el-container:nth-child(5) .el-aside,
  .el-container:nth-child(6) .el-aside {
    line-height: 260px;
  }

  .el-container:nth-child(7) .el-aside {
    line-height: 320px;
  }
</style>

```

###### 3. 色彩

Element Plus 为了避免视觉传达差异，使用一套特定的调色板来规定颜色，为你所搭建的产品提供一致的外观视觉感受。

**主色**

Element Plus主要品牌颜色时鲜艳，友好的的蓝色。

![](imgs/55.png)

**辅助色**

除了主色外的场景色，需要在不同的场景中使用（例如：危险色表示危险的操作）。

![](imgs/56.png)



中性色

中性色用于文本，背景和边框颜色。通过运用不同的中性色，来表现层结构。

![](imgs/57.png)

###### 4.边框

**Border 边框**

我们对边框进行统一规范，可用于按钮、卡片、弹窗等组件里。

**边框**

我们提供了以下几种边框样式，以供选择。

| 名称                | 粗细 |
| ------------------- | ---- |
| 实线(solid)         | 1px  |
| 虚线(dotted,dashed) | 2px  |

**圆角**

我们提供了以下几种圆角样式，以供选择。

无圆角 border-radius: 0px

小圆脚 border-radius: 2px

大圆角 border-radius: 4px

圆形圆角 border-radius: 20px

**投影**

我们提供了以下几种投影样式，以供选择。

基础投影：box-shadow: 0 2px 4px rgba(0,0,0,0.12), 0,0,6px rgba(0,0,0,0.04)

![](imgs/58.png)

浅色投影： box-shadow: 0 2px 12px0 rgba(0,0,0,0.1)

![](imgs/59.png)

###### 5. Icon 图标

我们这边采用的是之前讲过的fontawesome，之前我们是直接下载的文件，现在在vue当中我们只需要通过npm把fontawesome安装到项目当中，之后进行全局导入即可使用了。

安装：

``` shell
npm install font-awesome --save
```

之后去main.js当中，进行全局导入配置

``` js
import 'font-awesome/css/font-awesome.min.css'
```

当完成上面的配置之后，我们就可以去页面当中使用i标签进行样式引入了

``` vue
<template>
	<i class="fa fa-search"></i>
</template>
```

###### 6. Button 按钮

``` vue
<el-button type="指定按钮的样式"></el-button>
```

type的属性值：default 默认的按钮样式，白色背景

​                           primary 这个是带有蓝色背景的按钮

​                           warning 这个是黄色的

​                           danger   这个是红色

​                           success  这个是成功的颜色，绿色

​                           info         这个是灰色

我们还可以在按钮的基础上添加 plain,这个是圆角矩形 ， round ,两侧变成半圆形的按钮，circle圆形按钮

``` vue
<el-button type="primary" round></el-button>
```

###### 7. Link文字连接

这个内容的效果就是超链接。

``` vue
<template>
	<el-link href="" type=""></el-link>
</template>
```

其中el-link就是为当前的连接组件，里面href就是原生的跳转属性，用于存储跳转路径的，type用于设定当前文本的颜色效果。这个标签还有其他的一些属性，用于设定当前文本连接的效果

| 属性名    | 说明         | 类型    | 可选值                              |
| --------- | ------------ | ------- | ----------------------------------- |
| type      | 类型         | string  | primary/success/danger/warning/info |
| underline | 是否下划线   | boolean | -                                   |
| disabled  | 是否禁用状态 | boolean | -                                   |
| href      | 原生href属性 | string  | -                                   |
| icon      | 图标类名     | string  | -                                   |

###### 8. 表单元素

**8.1 单选按钮**

语法：

``` vue
<template>
	<el-radio v-model="" label="">Text</el-radio>
</template>
```

上面的就是element-plus当中的单选按钮，其中只要v-model当中数据名相同，就为同一组数据，一组数据当中我们只能选中一个。label当中用于存储传递的值，与原生标签当中的value。

我们还可以把同一组当中的内容通过el-radio-group进行分组存储。

``` vue
<template>
	<el-radio-group v-model="">
    	<el-radio label="value">Text</el-radio>
    	<el-radio label="value">Text</el-radio>
    </el-radio-group>
</template>
```

当然我们还可以把这一组当中的单选按钮改为按钮的样式

``` vue
<template>
	<el-radio-group v-model="">
    	<el-radio-button label="value">Text</el-radio>
    	<el-radio-button label="value">Text</el-radio>
    </el-radio-group>
</template>
```

**8.2 复选框**

使用方法与单选按钮的使用方法相同。

**8.3 输入框**

``` vue
<el-input v-model=""></el-input>
```

**8.4 Select选择器**

``` vue
<el-select v-model="">
	<el-option v-for="" :key="" :label="" :value=""></el-option>

</el-select>
```

其中label绑定的是选择器中用于传递的值，value绑定的是用于显示的值。

**8.5 Cascader 级联选择器**

当一个数据集合有清晰的层次结构时，可通过级联选择器逐级查看并选择。

级联选择器有两种方式出发子菜单

(1) 点击触发

(2) hover触发

我们只需要给Cascader的options属性指定选项数组即可渲染出一个级联选择器，通过props.expandTrigger可以定义展开子级菜单的触发方式。

``` vue
<template>
	<el-cascader v-model="" :options=""></el-cascader>
</template>

<script>
	export default{
        data(){
            return{
                value:[],
                props:{ expandTrigger:'click'},
                 options:[
           { 
              value:'yinianji',
              label:'一年级',
              children:[
                 {
                    value:'yiban',
                    label: '一班'
                 },
                 {
                    value:'erban',
                    label: '二班'
                 }

              ]
           },
           {
              value:'ernianji',
              label:'二年级',
              children:[
                   {
                    value:'yiban',
                    label: '一班'
                 },
                 {
                    value:'erban',
                    label: '二班'
                 },
                 {
                    value:'sanban',
                    label:'三班'
                 }
              ]
            }
          ] 
        }
    }

</script>
```

其中，:options绑定的就是我们获取到的数据，数据结构当中的value代表传递的值，label代表显示的值，children代表子选项

**8.6 switch开关**

``` vue
<el-switch v-model="" active-color="" inactive-color="" active-text="" inactive-text=""></el-switch>
```

我们可以使用active-color和

active-color属性来设定开关的背景色，active-text和inactive-text=""设定开关的文字描述

**8.7 TimePicker 时间选择**

用于选择或者输入事件

``` vue
<el-time-picker
	v-model=""
    :disabled-hours=""
    :disabled-minutes=""
    :disabled-seconds=""
    placeholder=""   >
	
</el-time-picker>
```

我们可以通过disabledHours,disabledMinutes和disabledSeconds限制可选时间范围。

**8.8 DatePicker 日期选择器**

用于选择或者输入日期，这种控件是以日为基本单位的。

``` vue
<el-date-picker 
  v-model="" type="date" placeholder= ""></el-date-picker>
```

**8.9 Upload上传**

``` vue
<el-upload class="" action=""></el-upload>
```

class的值用于设定上传按钮的样式，根据这个值来做不同的效果

upload-demo 这个样式就是一个普通的按钮，点击之后就能打开文件选择窗体

avatar-uploader 一个正方形，中间带有加号的样式，中间的加号是一个图标实现的

action属性，要求必须带有，这个属性用于设定与后台接口连接的路径

:on-success 这个代表我们上传图片成功之后要执行的方法

**上传图片这个操作是一个post提交，而且是通过原生Ajax做的**

> 原生Ajax对象： ActiveXObject 旧版浏览器的
>
> ​                            XMLHttpRequest 新版浏览器

###### 9. 导航条

**1. Affix固定**

作用：将页面元素固定在特定的可视区域，例如:我们想要把元素固定到页面顶部。

``` vue
<template>
	<el-affix :offset="120">
    	<el-button type="primary">距离顶部 120px</el-button>
    </el-affix>
</template>
```

我们可以通过offset属性进行设定该元素距离顶端的距离。默认值为0。

我们还可以通过target属性用于设定该元素在某个页面元素的内部，超出的部分将会隐藏。

``` vue
<template>
	<div class="affix-container">
        <el-affix target=".affix-container" :offset="80">
            <el-button type="primary"> 指定容器
            </el-button>
        </el-affix>
    </div>
</template>
```

**2. NavMenu 导航菜单**

该内容是让我们在界面当中添加一个导航菜单。默认为垂直模式，通过mode属性设定属性值为horizontal可以使导航菜单变更为水平模式。另外，在菜单中通过sub-menu组件可以生产二级菜单。Menu还提供了backgound-color、text-color和active-text-color，分别用于设置菜单的背景色，菜单的文字颜色和当前激活菜单的文字颜色。

``` vue
<template>
  <el-menu
    default-active="1"
    class="el-menu-demo"
    mode="horizontal"
    :ellipsis="false"
    @select="handleSelect"
  >
    <el-menu-item index="0">LOGO</el-menu-item>
    <div class="flex-grow" />
    <el-menu-item index="1">Processing Center</el-menu-item>
    <el-sub-menu index="2">
      <template #title>Workspace</template>
      <el-menu-item index="2-1">item one</el-menu-item>
      <el-menu-item index="2-2">item two</el-menu-item>
      <el-menu-item index="2-3">item three</el-menu-item>
      <el-sub-menu index="2-4">
        <template #title>item four</template>
        <el-menu-item index="2-4-1">item one</el-menu-item>
        <el-menu-item index="2-4-2">item two</el-menu-item>
        <el-menu-item index="2-4-3">item three</el-menu-item>
      </el-sub-menu>
    </el-sub-menu>
  </el-menu>
</template>

<script>

const handleSelect = (key, keyPath) => {
  console.log(key, keyPath)
}
</script>

<style>
.flex-grow {
  flex-grow: 1;
}
</style>
```

通过上面的代码我们可以实现如下效果

![](imgs/60.png)

我们也可以制作一个侧面导航栏，代码如下：

``` vue
<template>
  <el-row class="tac">
    
    <el-col :span="12">
      <h5 class="mb-2">Custom colors</h5>
      <el-menu
        active-text-color="#ffd04b"
        background-color="#545c64"
        class="el-menu-vertical-demo"
        default-active="2"
        text-color="#fff"
        @open="handleOpen"
        @close="handleClose"
      >
        <el-sub-menu index="1">
          <template #title>
            <span>Navigator One</span>
          </template>
          <el-menu-item-group title="Group One">
            <el-menu-item index="1-1">item one</el-menu-item>
            <el-menu-item index="1-2">item one</el-menu-item>
          </el-menu-item-group>
          <el-menu-item-group title="Group Two">
            <el-menu-item index="1-3">item three</el-menu-item>
          </el-menu-item-group>
          <el-sub-menu index="1-4">
            <template #title>item four</template>
            <el-menu-item index="1-4-1">item one</el-menu-item>
          </el-sub-menu>
        </el-sub-menu>
        <el-menu-item index="2">
          <span>Navigator Two</span>
        </el-menu-item>
        <el-menu-item index="3" disabled>
          <span>Navigator Three</span>
        </el-menu-item>
        <el-menu-item index="4">
          <span>Navigator Four</span>
        </el-menu-item>
      </el-menu>
    </el-col>
  </el-row>
</template>

<script>

const handleOpen = (key, keyPath) => {
  console.log(key, keyPath)
}
const handleClose = (key, keyPath) => {
  console.log(key, keyPath)
}
</script>
```

展示效果为：

![](imgs/61.png)



#### 3.14 TypeScript

微软公司根据JavaScript制作出一个js的库文件，这种语言的好处更加贴近于我们正常程序员的开发的编程语言，与C#特别的类似。

现在的前端要求必须会项，现在所有前端框架最新版都是通过TypeScript编写的

我们想要在自己电脑当中使用ts首先需要先去安装ts的编译器

``` shell
npm install -g typescript
```

我们现在再去创建脚本文件的时候，不要再用js扩展名了，我们需要把扩展名改为ts,我们在这个文件当中书写ts代码，之后我们在执行编译把ts文件编译成js文件

手动编译命令

``` shell
tsc 文件名
```



##### 3.14.1 数据类型

ts当中带有的数据类型包含：number，string，boolean , 数组(array)，元组(tuple)，枚举(enum)，void , null , undefined, never等。

###### 1. Undefined

Undefined类型只包含一个值，即undefined。在变量未被初始化时，他的值为undefined。

###### 2. Null

Null类型也只包含一个值，即null。我们通常使用null值来表示未初始化的对象。此外，null值也常被用在json文件中，表示一个值不存在。

###### 3. Boolean

Boolean类型包含两个逻辑值，分别是true和false

###### 4. String

String类型表示文本字符串，它由0个或多个字符构成。

Javascript使用UTF-16编码来表示一个字符。UTF-16编码以两个字节作为一个编码单元，每个字符使用一个编码单元或者两个编码单元来表示。在底层存储中，字符串是由零个或者多个16位无符号整数构成的有序序列。

###### 5. Number

Number类型表示一个数字。JavaScript不详细区分整数类型、浮点数类型以及带符号的数字类型等。JavaScript使用双精度64位浮点数格式(IEEE 754)来表示数字，因此所有数字本质上都是浮点数。

###### 6. Symbol

Symbol是ECMAScript 2015新引入的原始类型。Symbol值有一个重要特征，那就是每一个Symbol值都是唯一的且不可改变的。Symbol值的主要应用场景是作为对象的属性名。

Symbol的设计初衷是用来实现对象的私有属性，但实际上Symbol并不能实现真正意义上的私有属性。Javascript还是提供了一些方法允许程序去访问Symbol属性。虽然Symbol无法实现绝对的私有属性。但是它确实有助于缓解属性命名冲突问题。

**Symbol()**

JavaScript提供了一个全局的“Symbol()"函数来创建Symbol类型的值。我们可以将”Symbol()"函数想象成GUID(全局唯一标识符)的生成器，每次调用"Symbol()"函数都会生成一个完全不同的Symbol值，例如：

``` typescript
const sym = Symbol();
const obj = { [sym]: 'some value'};
obj[sym]; //some value
```

**Well-Know Symbol**

JavaScript 内置了一些所谓的Well-Know Symbol常量。这些Symbol常量用作对象属性名，它们的功能是定制对象的特定行为。在ECMAScript 2015规范中一共定义了11个Well-Know Symbol常量。

| 名称                      | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| Symbol.hasInstance        | 方法值，用于判断一个对象是否位某个构造函数的实力，与instanceof运算符的行为相关 |
| Symbol.isConcatSpreadable | 布尔值，表示在执行“Array.prototype.concat"方法时，一个对象是否允许被展开 |
| Symbol.iterator           | 方法值，表示迭代器函数，与for ... of 语句的行为相关          |
| Symbol.match              | 用于定义”String.prototype.match()"方法的行为                 |
| Symbol.replace            | 用于定义“String.prototype.replace()"方法的行为               |
| Symbol.search             | 用于定义"String.prototype.search()"方法的行为                |
| Symbol.species            | 用于定义在创建派生对象时使用的构造函数                       |
| Symbol.split              | 用于定义"String.prototype.split()"方法的行为                 |
| Symbol.toPrimitive        | 方法值，用于定义将一个对象转换为原始值时的行为               |
| Symbol.toStringTag        | 用于定义"Object.prototype.toString()"方法的行为              |
| Symbol.unscopables        | 用于定义对象值在with语句中的行为                             |

###### 7. Object

对象时属性的集合，每个对象属性都属于以下两种形式之一:

* 数据属性。可以位Undefined、Null、Boolean、String、Number、Symbol和Object类型的值。
* 存取器属性。由一个或两个存取器方法构成，用于获取和设置Undefined、Null、Boolean、String、Number、Symbol和Object类型的值。

对象属性使用简直来标识，键值只能为字符串或Symbol值。所有字符串（也包括空字符串）和Symbol值都是合法的键值。

###### 8. 字面量

在计算机科学中，字面量用于在源代码中表示某个固定值。在JavaScript程序中，字面量不是变量，它是直接给出的固定值。

**Null字面量**

Null字面量只有一个，记作null。

**Boolean字面量**

Boolean字面量有两个，分别记作true和false

**Number字面量**

Number字面量包含四类：二进制整数字面量、八进制整数字面量、十进制整数字面量以及十六进制整数字面量。

**字符串字面量**

字符串字面量是使用一对单引号或双引号包围起来的Unicode字符。字符串字面量中可以包含Unicode转义序列和十六进制转义序列。JavaScript中的主流编码风格推荐使用单引号表示字符串字面量。

**模板字面量**

模板字面量是ECMAScript 2015引入的新特性,它提供了一种语法糖来帮助构造字符串。模板字面量的出现帮助开发者解决了一些长久以来的痛点，如动态字符串的拼接和创建多行字符串等。模板字符串的基本语法是使用反引号”`“替换了字符串字面量中的单引号，双引号。

###### 9. 对象

在Javascript中，对象是属于非原始类型。同时，对象也是一种复合数据类型，它由若干个对象属性构成。对象属性可以是任意数据类型，如数字，函数或者对象等。当对象属性为函数时，我们通常称之为方法。当然，这只是惯用叫法不同，在本质上并无差别。

**对象字面量**

对象字面量也叫做对象初始化器，是最常用的创建对象的方法。

​	**数据属性**

​    对象字面量的数据属性由属性名和属性值组成，语法如下所示：

``` typescript
{
    propertyName : PropertyValue,
}
```

​    在改语法中，PropertyName表示属性名，PropertyValue表示属性值。对象属性名可以为标识符、字符串字面量和数字字面量，对象属性值可以为任意值。

   **存取器属性**

   一个存取器属性由一个或两个存取器方法组成，存取器方法分为get方法和set方法两种。get方法能够将属性访问绑定到一个函数调用上，该方法用于获取一个属性值。set方法可以将对象属性赋值绑定到一个函数调用上，当尝试给该属性赋值时，set方法就会被调用。存储器属性的语法如下：

``` typescript
{
    get PropertyName(){
        return PropertyValue;
    }
    set PropertyName(value){
        
    }
}
```

存储器属性中的get方法和set方法不要求同时存在。我们可以只定义get方法而不定义set方法，反过来也是一样。如果一个属性只定义了get方法而没有定义对应的set方法，那么该属性就成了只读属性。

​     **可计算属性名**

​     可计算属性名是指在定义对象字面量属性时使用表达式作为属性名。可计算属性名适用于对象属性名需要动态计算的场景之中。属性名表达式求值之后将得到   

​     一个字符串或Symbol值，该字符串或Symbol值将被用作对象属性名。它的语法如下所示：

```typescript

 {
     [PropertyExpression]: PropertyValue,
     get [PropertyExpression](){
         return PropertyValue;
     }
     set [PropertyExpression](value){ }
 }
 
```

ts案例：

``` typescript
const a :string = "hello world";  
console.log(a);
```

ts声明变量的时候需要我们指明改变量的数据类型

##### 3.14.2 基础语法：略

##### 3.14.3 函数

**函数的声明**

``` js
function 函数名([参数列表]){
    [return]
}
```

TypeScript声明

``` typescript
function 函数名([参数1:类型1,参数2:类型,...]):返回值类型
{
    
    
}
```

**匿名函数**

除了上面的函数声明意外，还可以使用函数表达式来定义一个函数。函数表达式的语法与函数的声明的语法有一个重要区别，那就是函数表达式中的函数名是可选的。当没有指定函数名时，该函数也叫做匿名函数。因为函数表达式属于表达式，并且表达式能够产生一个值，该值是一个函数。函数表达式能够被应用在任何一处期待值的地方。例如：可以将函数表达式赋值给一个变量，也可以将函数表达式当作参数传递给其他函数。

**立即执行的函数表达式**

立即执行的函数表达式指的是在定义时就立即被调用的函数表达式。常见的定义方式有以下两种：

(1)

``` typescript
;(function(){
    // ...
})();
```

(2)

``` typescript
;(function(){
    // ...
}());
```

在立即执行的函数表达式中，我们在起始和结尾位置分别添加了分号。这是为了防止使用代码压缩工具处理代码之后产生错误的语法。例如：将两个立即执行的函数表达式合并到一行并连接在一起后就可能出现错误。

**立即执行的函数表达式特点：**

* 函数表达式和函数声明一样，能够创建出新的作用域，在函数内部声明的变量不会对函数外部产生影响，因此提供了一定的数据封装性。
* 是立即执行的函数表达式自身对外部作用域没有任何影响。在立即执行的函数表达式中，没有将函数引用赋值给任何外部变量。因此，立即执行的函数表达式与外界是完全孤立的。

**箭头函数**

箭头函数是ECMAScript 2015中新增的特性，用来定义匿名的函数表达式。箭头函数一定是匿名函数。箭头函数最显著的特点是使用“=>”符号来连接函数的形参列表与函数体。语法如下：

``` typescript
(args1,args2,...) => { // ... 

}
```

箭头函数除了能够提供简洁的语法外还有一个特别的重要的特性，那就是箭头函数本身没有this绑定，它使用外层作用域中的this绑定。该特性能够帮助缓解程序中常见的一些错误。

##### 3.14.4 TypeScript 语言进阶

###### 1. BigInt

BigInt是在2019年9月份被正式纳入ECMAScript标准中的特性。由于BigInt类型的加入，JavaScript中共支持两种数值类型，即Number类型和BigInt类型。

> 目前JavaScript语言中共有7种原始数据类型：
>
> undefined，null，boolean，string，symbol，number，bigint

> JavaScript语言使用双精度64位浮点型格式来表示Number类型的值。Number类型能够安全标识的最大整数为<span>2<sup>53</sup></span> -1,这个数值能够使用内置的number对象上的max_safe_integer属性来表示。bigint类型能够表示任意精度的整数，尤其是大于int类型最大存值的整数，这也是引入bigint类型的原因。

**创建bigint类型的变量**

我们共有2种创建bigint类型变量的方式。

（1）使用bigint字面量

``` typescript
const a = 1n;
```

bigint字面量的语法是一个整数后面添加一个小写字母“n”。字母“n”必须紧随数字之后，两者之间不允许存在空白字符。

（2）使用bigint()函数

``` typescript
const a = BigInt(1);
```

上面的就是创建一个bigint类型变量，并且存值为1。

**BigInt与Number**

BigInt类型的值能够与Number类型的值进行大小及相等关系的比较，在进行严格相等比较时，BigInt类型的值与Number类型的值永远不相等。在进行非严格相等比较及大小关系比较时，Bigint类型的值与Number类型的值将进行数学意义上的比较。

**BigInt与Number的值虽然都是数字，并且能够进行运算，但是这两种数据类型的值无法进行混合数学运算。**

我们可以通过内置的Number()函数能够将Bigint类型的值转换为number类型的值。

> 需要注意的是bigint类型与number类型之间进行强制转换时，有可能损失精度。



#### 3.15 Vue 组合API基础

##### 3.15.1 实现响应式

API(Application Programming Interface,应用程序接口)是一些预先定义的接口(如函数，HTTP接口)，或者是软件系统不同组成部分衔接的约定。

响应式是一种允许以声明式的方法去适应变化的编程范例。例如，JavaScript实现响应式地说明定义一个数据count如下：

``` js
let count
```

然后回根据这个数据count的情况定义另一个数据如下：

``` js
let doubleCount = count * 2
```

响应式就是要求当count发生变化时，doubleCount也随之发生变化。这里就需要通过监听count的数据的事件处理函数来执行doubleCount数据的变化。也就是说doubleCount会根据count的变化自动响应式地变化。

还有一种响应式是数据在网页上渲染之后，当数据发生变化后会自动在网页上重新渲染新的数据。这在原生JavaScript语言中实现起来是非常困难的。

##### 3.15.2 setup函数

setup函数是一个新的组件选项，作为组件中composition API的起点，composition API的代码都在setup函数中去实现。step函数会优先于生命周期当中beforeCreate和created执行。

##### 3.15.3 响应式API

###### 1. ref函数

ref函数接收一个参数值并返回一个响应式且可改变的ref对象，该对象拥有一个指向内部值的单一value属性。

``` vue
const count = ref(0);
console.log(count)
count.value++
console.log(count.value)
```

当ref作为渲染上下文的属性返回，即在setup函数的return对象中到模板时会自动解套，需要加上value属性，ref函数必须先从Vue中的引用才能使用。例如：

``` vue
<template>
	<div>
        {{ count }}
    </div>
</template>

<script>
	import { ref } from 'vue'

    export default{
        setup(){
            return{
                count:ref(0)
            }
        }
    }
    
</script>

```



> 练习： 在网页上实现一个可以给更改的电子时钟







练习实现代码：

``` vue
<template>
	{{ clock }}
</template>

<script>
	import { onMounted,ref} from 'vue' //onMounted钩子函数，表示网页加载后立即运行函数
    
    export default
    {
        setup(){
            let clock = ref('')
            const week = ['星期天','星期一','星期二','星期三','星期四','星期五','星期六']
            onMounted( //调用钩子函数
            	() =>{
                    timeShow()
                }
            )
            const timeShow =() =>{ //自己声明的函数，用于拼接成“年月日星期时分秒”
                let myTime = new Date()
                clock.value = myTime.getFullYear() + '年'
                clock.value += toTwo(myTime.getMonth() + 1) + '月'
                clock.value += toTwo(myTime.getDate()) + '日'
                clock.value += week[myTime.getDay()]
                clock.value += toTwo(myTime.getHours()) + ':'
                clock.value += toTwo(myTime.getMinutes()) + ':'
                clock.value += toTwo(myTime.getSeconds()) 
            }
            const toTwo = (x) => x > 9 ? x : '0'+x  //把x变成两位数的函数
            setInterval(timeShow,1000)             // 定时1秒钟执行一次timeShow函数
            return{
                msg
            }
        }
    }    
</script>
```

###### 2. reactive函数

reactive函数的用法与ref函数的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的时ref函数用于基本数据类型，而reactive函数用于复杂数据类型，其主要有对象和数组两种数据类型。reactive函数同样必须先从vue中引用才能使用。

``` vue
<template>
	{{ student.name }}
</template>

<script>
	import { reactive } from 'vue'
    export default
    {
        setup(){
            let student = reactive({
                name : '张三'
            })
            
            return {
                student
            }
        }
    }
</script>
```

###### 3. computed方法

computed()方法接受一个getter函数，返回一个默认不可手动修改的ref对象。

``` js
const count = ref(1)
const plus = computed(() => count.value + 1)
console.log(plus.value)   //输出2，通过上面computed方法更改了value属性值

plus.value++ //报错，因为plus.value 是常量。
```

computed方法也可以接受一个拥有get函数和set函数的对象，创建一个可手动修改的计算状态。

``` js
const count = ref(1)

const plus = computed({
    get:() => count.value + 1,
    set: (val) => {
        count.value = val -1
    }
})

plus.value = 1                   // 调用set函数   
console.log(count.value)         // 调用get函数，输出数据0
```

###### 4. watchEffect方法

watchEffect方法的参数是一个函数，该方法可以响应式追踪其依赖，并在其依赖变更时重新运行该函数。该方法想要使用也必须先从Vue中引入,例如：

``` js
import { watchEffect , ref} from 'vue'
export default{
    setup(){
        const count = ref(0)
        watchEffect(() => console.log(count.value))  //用于监视count的变化，如果值发生变化则立即输出
        setTimeout(
        	() =>{
                count.value++     //count值每隔1秒加1
            },1000
        )
        return {
            count
        }
    }
}

```

watchEffect方法不需要指定监听哪一个属性，其会自动收集回调函数中引用到的响应式属性，当这些属性发生变化时这个回调函数都会自动执行，并且watchEffect在组件初始化时就会执行一次用以收集依赖。

停止侦听的两种方法分别是隐式停止和显示停止。其中，隐式停止是当watchEffect在组件的setup函数或者生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并且在组件卸载时自动停止。显示停止使用语句如下：

``` js
const stopWE = watchEffect( ... )
stopWE.stop();
```

##### 3.15.4 响应式系统工具集

###### 1. toRef

toRef可以为一个reactive对象的属性创建一个ref。这个ref可以被传递并且能够保持响应性。例如：

``` js
const state = reactive({
    foo: 1,
    bar: 2
})

const fooRef = toRef(state, 'foo')

fooRef.value++
console.log(state.foo) //输出显示值为2

state.foo++
console.log(fooRef.value) //输出显示值为3
```

上面代码的输出结果可以看出fooRef.value和state.foo指向的时同一个单元。如果需要将setup函数中的参数props的属性作为ref传给组合逻辑函数，也可以使用toRef。例如：

``` js
export default{
    setup(props){
        useSomeFeature(toRef(props,'foo'))
    }
}
```

###### 2. toRefs

把一个响应式对象转换成普通对象，该普通对象的每个属性都是一个ref，和响应式对象属性一一对应。例如：

``` js
const state = reactive({
    foo: 1,
    bar: 2
})

const stateAsRefs = toRefs(state)

/*
	stateAsRefs的类型如下:
	{
		foo: Ref<number>,
		bar: Ref<number>
	}
*/

//ref对象与原属性的引用时“链接”上的
state.foo++
console.log(stateAsRefs.foo.value)  //输出显示值为2

stateAsRefs.foo.value++
console.log(state.foo)             // 输出显示值为3
```

当想要从一个组合逻辑函数中返回响应式对象时，用toRefs是很有效的，该API让组件可以解构/扩展（使用...操作符）返回的对象，并不会丢失响应性。例如：

``` vue
<template>
	<p>
        {{ msg }}
    </p>
</template>

<script>
	import { reactive , toRefs } from 'vue'
	export default{
        setup(){
            const state = reactive({
                msg: 'Hello World'
            })
            
            return{
                ...toRefs(state)
            }
        }
    }
</script>
```



## 五. EasyUI

EasyUI是一个较老的前端框架,它是与Jquery连接进行使用的框架,这个框架使用的局限性比较大,它只能作为后台界面的框架(这种界面看着比较古老),创建的界面如下:

![](imgs/70.png)



EasyUI当中封装了大量的jQuery插件(简化ajax,jquery,css样式,布局)

插件的实现方式:

> (1) HTML+插件的class样式
>
> ``` html
> <a href="#" class="easyui-linkbutton">超链接标签</a>
> ```
>
> (2) HTML+基于编程的插件实现
>
> ``` html
> <a href="#" id="btn">超链接标签</a>
> 
> <script>
> 	$("#btn").linkbutton();
> </script>
> ```

插件的内容:

属性: 设置插件的样式.图标,宽度,高度

事件:  单击事件,双击

方法: 修改插件属性,状态



学习方法

1. 掌握easyui插件的开发模板
2. 通过文档配合,学习它的属性,事件和方法(类似于Bootstrap)



### 1. 搭建EasyUI环境

我们首先需要去官网下载EasyUI的文件,下载地址:[https://www.jeasyui.net/download/](https://www.jeasyui.net/download/),我们需要找到要使用的对应框架内容进行下载,下载之后是一个压缩包,我们对其解压就可以.

![](imgs/71.png)

项目搭建环境步骤:

1. 我们需要导入easyui的核心样式,即上图的easyui.css 和 icon.css

​		easyui.css 在 themes文件夹下,default文件夹下

​	    icon.css 在themes文件夹下,

2. 我们导入相关的js文件:

​		(1) jquery.min.js

​        (2) jquery.easyui.min.js

​        (3) jquery.easyui-lang-zh_CN.js

3. 注意:

​		theme文件夹当中的文件相对路径不能发生改变

我们只需要把整个themes文件夹与要导入的js文件一起存放到项目当中即可,如下:

![](imgs/72.png)

之后我们在html页面内分别对这些几个文件进行导入即可:

![](imgs/73.png)

运行上面的代码,效果如下图:

![](imgs/74.png)

### 2. 插件

#### 1. 按钮插件

##### linkbutton

该插件要使用的时候需要有a标签,我们可以通过2种方式实现,

(1) 样式实现:

``` html
<a href="#" class="easyui-linkbutton">linkbutton</a>
```

(2) jquery脚本实现

> 语法为: $("选中标签的id属性名").插件名();

``` html
<a href="#" id="lnkLabel">linkbutton</a>

<script>
	$("#lnkLabel").linkbutton();
</script>
```







# 3. 数据库

## 一. Sql Server



## 二. MySql

#### 1. 初始MySql

MySql是一个开发源代码的数据库管理系统(Database Management System,DBMS)，它是由MySql AB公司开发、发布并支持的，MySql是一个跨平台的开源关系型数据库管理系统，广泛地应用在Internet上的中小型网站开发中。

##### 1.1 数据库基础

数据库由一批数据构成有序的集合，这些数据被存放在结构化的数据库表里。数据表之间相互关联，反映了客观事物间的本质联系。数据库系统提供对数据额安全控制和完整性控制。

###### 1.1.1 什么是数据库

数据库的概念诞生于60年前，随着信息技术和市场的快速发展，数据库技术层出不穷，随着应用的扩展和深入，数据库的数量和规模越来越大，其诞生和发展给计算机信息管理带来了一场巨大的革命。

数据库的发展大致分为4个阶段：人工管理阶段，文件系统阶段，数据库系统阶段，高级数据库阶段。其种类大概有3种：层次式数据库、网络式数据库和关系式数据库。不同种类的数据库按不同的数据结构来联系和组织。

对于数据库的概念没有一个完全固定的定义，随着数据库的发展，定义的内容也有很大的差异。其中一种比较普遍的观点认为，数据库(Database,DB)是一个长期存储在计算机内的、有组织的、共享的、统一管理的数据集合。数据库是一个按数据结构来存储和管理数据的计算机软件系统，即数据库包含两层含义：保管数据的“仓库”，以及数据管理的方法和技术。

数据库的特点：实现数据共享，减少数据冗余；采用特定的数据类型；具有较高的数据独立性；具有统一的数据控制功能。

###### 1.1.2 表

在关系数据库中，数据库表是一系列二维数组的集合，用来存储数据和操作数据的逻辑结构。它由纵向的列和横向的行组成，行被称为记录，是组织数据的单位；列被称为字段，每一列表示记录的一个属性，都有相应的描述信息，如数据类型、数据宽度等。

###### 1.1.3 数据类型

数据类型决定了数据在计算机中的存储格式，代表不同的信息类型。常用的数据类型有整数数据类型、浮点数数据类型、精确小数类型、二进制数据类型、日期/时间数据类型、字符串数据类型。

表中的每一个字段就是某种指定数据类型，比如：性别字段为字符型数据。

###### 1.1.4 主键

主键（Primary Key）又称主码，用于唯一地标识表中的每一条记录。可以定义表中的一列或多列为主键，主键列上不能有两行相同的值，也不能为空值。

##### 1.2 数据库技术构成

数据库系统由硬件部分和软件部分共同沟成，硬件主要用于存储数据库中的数据，包括计算机、存储设备等；软甲那部分则主要包括DBMS、支持DBMS运行的操作系统以及支持多种语言进行应用开发的访问技术等。

###### 1.2.1 数据库系统

数据库系统有3个主要的组成部分：

* 数据库： 用于存储数据的地方
* 数据库管理系统： 用于管理数据库的软件
* 数据库应用程序： 为了提高数据库系统的处理能力所使用的管理数据库的软件补充。

**数据库系统（Database System）**提供了一个存储空间用于存储各种数据，可以将数据库视为一个存储数据的容器。一个数据库可能包含许多文件，一个数据库系统通常包含许多数据库。

**数据库管理系统（Database Management System,DBMS）** 是用户创建、管理和维护数据库时所使用的软件，位于用于操作系统之间，对数据库进行统一管理。DBMS能定义数据存储结构，提供数据的操作机制，维护数据库的安全性、完整性和可靠性。

**数据库应用程序（Database Application）** 虽然已经有了DBMS,但是在很多情况下，DBMS无法满足对数据管理的要求。数据库应用程序的使用可以满足对数据管理的更高要求，还可以使数据管理过程更加直观和友好。数据库应用程序负责与DBMS进行通信，访问和管理DBMS中存储的数据，允许用户插入、修改、删除DB中的数据。

###### 1.2.2 SQL语言

对数据库进行查询和修改操作的语言叫作SQL。SQL的含义是结构化查询语言(Structured Query Language)。

SQL语言包含以下4个部分：

（1） 数据定义语言（DDL）：Drop、Create、Alter等语句。

（2）数据操作语言（DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语言

（3）数据查询语言（DQL）：SELECT语句

（4）数据控制语言（DCL）：GRANT、REVOKE、COMMIT、ROLLBACK等语句。



##### 1.3 什么是MySQL

MySql是一个小型关系数据库管理系统，与其他大型数据库管理系统（例如Oracle、DB2、SQL Server等）相比，MySQL规模小、功能有限，但是它体积小、速度快、成本低，且提供的功能对稍微复杂的应用来说已经够用，这些特性使得MySQL成为世界上最受欢迎的开源的数据库。

**MySql的优势：**

（1）速度：运行速度快

（2）价格：MySQL对多数个人来说是免费的

（3）容易使用：与其他大型数据库的设置和管理相比，其复杂程度较低，易于学习。

（4）可移植性：能够工作在众多不同的系统平台上

（5）丰富的接口：提供了用于C、C++、Java、Perl、PHP、Python、Ruby和Tcl等语言的Api

（6）支持查询语言：MySql可以利用标准SQL语法和支持ODBC（开放式数据库连接）的应用程序。

（7）安全性和连接性：十分灵活和安全的权限和密码系统，允许基于主机的验证。连接到服务器时，所有的密码传输均采用加密形式，从而保证了密码的安全。并且由于MySQL是网络化的，因此可以在因特网上的任何地方访问，提高数据共享的效率。

#### 2.  数据库的基本操作

##### 2.1 创建数据库

在MySql安装完成之后，将会在其data目录下自动创建几个必需的数据库，我们可以直接使用

``` mysql
SHOW DATABASES;
```

这条命令来进行查看所有的数据库。

> 注： 根据数据库标准要求我们写的数据库的关键字要大写，每条语句结束后要带有英文分号。

我们可以使用下面的语句来创建我们的第一个自己的数据库

``` mysql
CREATE DATABASE 数据库名字;
```

##### 2.2 删除数据库

``` mysql
DROP DATABASE 数据库名字;
```



## 三. PostgreSQL

















## 四. Redis

### 1. 简介

Redis是一个开源的高性能**键值对**数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，并借助许多高层级的接口使其可以胜任如：缓存、队列系统等不同的角色。

**特色：**

作为一款个人开发的数据库，它具有如下特性：

(1) 存储结构

Redis采用的是字节结构存储数据，并允许其他应用通过TCP协议读写字典中的内容。同大多数脚本语言中的字典一样，Redis字典中的键值除了可以是字符串，还可以是其他的数据类型。

到目前位置Redis支持的键值数据类型如下：

* 字符串类型
* 散列类型
* 列表类型
* 集合类型
* 有序集合类型

> Redis是REmote DIctionary Server的缩写。

(2)  内存存储与持久化

Redis数据库中的所有数据都存储在内存中。由于内存的读写速度远快于硬盘，因此Redis在性能上对其他基于硬盘存储的数据库有非常明显的优势，在一台普通的笔记本电脑上Redis可以在一秒内读写超过十万个键值。

我们在将数据存储到内存当中也会有问题，例如：当我们重启电脑的时候，内存中的数据会丢失。不过Redis提供了对持久化的支持，即将可以内存中的数据异步写入到硬盘当中，同时不影响继续提供服务。

(3) 功能丰富

Redis虽然是作为数据库开发的，但由于其提供了丰富的功能，越来越多的人将其作为缓存、队列系统等。

Redis可以为每个键设置生存时间,生存时间到期后键会自动被删除。这一功能配合出色的性能让Redis可以作为缓存系统来使用，而且由于Redis支持持久化和丰富的数据类型，使其成为了另一个非常流行的缓存系统Memcached的有力竞争者。

(4) 简单稳定

即使功能再丰富，如果使用起来太复杂也很难吸引人。Redis直观的存储结构使得通过程序与Redis交互十分简单。在Redis中使用命令来读写数据，命令语句之于Redis就相当于SQL语言之于关系数据库。

### 2. 准备

#### 2.1 安装Redis

安装Redis使开始Redis学习之旅的第一步，在安装Redis之前需要了解Redis的版本规则以选择最适合自己的版本，Redis约定次版本号(即第一个小数点后的数字)为偶数的版本是稳定版，奇数版本是非稳定版，推荐使用稳定版进行开发和在生产环境中使用。



### 3. 数据类型与基本命令



### 4. .Net 6 操作 Redis

#### 1. 添加引用

我们想要在.net 6 当中操作Redis必须先去添加StackExchange.Redis这个引用。

![](imgs/62.png)

#### 2. 创建连接

``` c#
ConnectionMultiplexer redis = ConnectionMultiplexer.Connect("localhost");
var database = redis.GetDatabase();
```

#### 3. 根据不同的数据类型实现操作

##### 3.1 String

``` c#
var nameString = "name";
if (await database.StringSetAsync(nameString, "lulu"))
{
    var nameStringValue = await database.StringGetAsync(nameString);
    Console.WriteLine($"{nameString}的值为{nameStringValue}");

    //设置没有时间限制的key
    await database.KeyIdleTimeAsync(nameString);
    await CheckIfKeyExist(database, nameString);

    //设置5秒后超时的key
    await database.KeyExpireAsync(nameString, DateTime.Now.AddSeconds(5));
    await CheckIfKeyExist(database, nameString);

    await Task.Delay(5000);
    await CheckIfKeyExist(database, nameString);
}

var name_not_exist = await database.StringGetAsync("name_not_exist");
if (name_not_exist.IsNull || name_not_exist.IsNullOrEmpty)
{
    Console.WriteLine($"{nameof(name_not_exist)}为空");
}

```

##### 3.2 HashSet

``` C#
string usersInfoHash = "usersInfo";
await database.HashSetAsync(usersInfoHash, new HashEntry[]
{
    new HashEntry ("number","1"),
    new HashEntry ("name","lulu"),
    new HashEntry ("sex","woman")
});
if (await database.HashExistsAsync(usersInfoHash, "name"))
{
    var count = database.HashLength(usersInfoHash);
    var nameValue = database.HashGet(usersInfoHash, "name");
    var keys = database.HashKeys(usersInfoHash);
    var values = await database.HashValuesAsync("usersInfo");

    await database.HashSetAsync(usersInfoHash, new HashEntry[] { new HashEntry("number", "2") });
    await database.HashSetAsync(usersInfoHash, new HashEntry[] { new HashEntry("age", "99") });
    count = database.HashLength(usersInfoHash);

    //key为HashIncrementTest的value，从1开始递增，调用一次HashIncrement+1
    var hashIncrementTestKey = "HashIncrementTest";
    for (int i = 0; i < 3; i++)
        await database.HashIncrementAsync(usersInfoHash, hashIncrementTestKey);

    //每次调用递减1
    for (int i = 0; i < 5; i++)
        await database.HashDecrementAsync(usersInfoHash, hashIncrementTestKey);

    if (await database.HashDeleteAsync(usersInfoHash, "name"))
    {
        Console.WriteLine($"删除{usersInfoHash}中的name Field成功");
    }
    long deleteCount = await database.HashDeleteAsync(usersInfoHash, new RedisValue[] { "name", "number", "sex" });
    Console.WriteLine($"删除{usersInfoHash}中的name/number/sex Field中的{deleteCount}个");

}

//重命名
if (await database.KeyExistsAsync(usersInfoHash))
    await database.KeyRenameAsync(usersInfoHash, $"rename_{usersInfoHash}");

```

##### 3.3 List

``` C#
//push插入数据
var listKey = "ListKey1";
if (await database.KeyExistsAsync(listKey))
    await database.KeyDeleteAsync(listKey);

database.ListLeftPush(listKey, "Value1");
database.ListLeftPush(listKey, 2);
database.ListLeftPush(listKey, 3.33);

//指定数据后插入数据
await database.ListInsertAfterAsync(listKey, 2, 4);

//指定数据前插入数据
await database.ListInsertBeforeAsync(listKey, 2, 5);

//可以从队列两边取出数据
//取ID最小的值
var leftPopValue = await database.ListLeftPopAsync(listKey);
//取ID最大的值
var rightPopValue = await database.ListRightPopAsync(listKey);

//可以从队列两边插入数据
//ID最小
await database.ListLeftPushAsync(listKey, 6);
await database.ListLeftPushAsync(listKey, 8);
//ID最大
await database.ListRightPushAsync(listKey, 7.77);
//小数数字不精确
var val_7_77 = await database.ListGetByIndexAsync(listKey, 5);
await database.ListRightPushAsync(listKey, "9.99");


//修改指定位置value
Console.WriteLine($"{ await database.ListGetByIndexAsync(listKey, 1)}");
database.ListSetByIndex(listKey, 1, 999);
Console.WriteLine($"{ await database.ListGetByIndexAsync(listKey, 1)}");

var values = database.ListRange(listKey, 1, 10);
Console.WriteLine($"{JsonConvert.SerializeObject(values)}");

var length = database.ListLengthAsync(listKey);

//根据值移除数据
var deleteCount1 = await database.ListRemoveAsync(listKey, 999);

//根据位置移除数据
await database.ListTrimAsync(listKey, 0, 3);

//List允许加入重复值
database.ListLeftPush(listKey, "Value1");
database.ListLeftPush(listKey, "Value1");
database.ListLeftPush(listKey, "Value1");

```

##### 3.4 Set

``` C#
var setKey = "SetKey1";
var setKey2 = "SetKey2";
if (await database.KeyExistsAsync(setKey))
    await database.KeyDeleteAsync(setKey);
if (await database.KeyExistsAsync(setKey2))
    await database.KeyDeleteAsync(setKey2);

await database.SetAddAsync(setKey, "1.223");
await database.SetAddAsync(setKey, "2");
for (decimal i = 0; i < 10;)
{
    await database.SetAddAsync(setKey, i.ToString());
    i = i + (decimal)0.5;
}
if (await database.SetContainsAsync(setKey, 1))
    Console.WriteLine($"{setKey}包含value：1");
else
    Console.WriteLine($"{setKey}不包含value：1");
if (await database.SetContainsAsync(setKey, "2"))
    Console.WriteLine($"{setKey}包含value：2");
else
    Console.WriteLine($"{setKey}不包含value：2");

var length = await database.SetLengthAsync(setKey);
var values = await database.SetMembersAsync(setKey);
Console.WriteLine($"{JsonConvert.SerializeObject(values)}");

//取出数据，数据被移除
var val = await database.SetPopAsync(setKey);

//随机取出一个数据，数据不被移除
var randomValue = await database.SetRandomMemberAsync(setKey);
//随机取出n个数据，数据不被移除
var randomValues = await database.SetRandomMembersAsync(setKey, 5);

//set不允许插入相同数据
if (await database.SetAddAsync(setKey, "999"))
    Console.WriteLine($"{setKey}插入数据999：成功");
else
    Console.WriteLine($"{setKey}插入数据999：失败");
if (await database.SetAddAsync(setKey, "999"))
    Console.WriteLine($"{setKey}插入数据999：成功");
else
    Console.WriteLine($"{setKey}插入数据999：失败");

var scan1Result = database.SetScan(setKey, "2", 100, 0, 0);
foreach (var redisValue in scan1Result)
{
    Console.WriteLine($"{redisValue}");
}
await database.SetRemoveAsync(setKey, "999");

if (database.SetMove(setKey, setKey2, "2"))
    Console.WriteLine($"将2从{setKey}迁移到{setKey2}：成功(在{setKey}中2被移除)");
else
    Console.WriteLine($"将2从{setKey}迁移到{setKey2}：失败");

```

##### 3.5 SortSet

``` C#
var sortSetKey = "SortSetKey1";
if (await database.KeyExistsAsync(sortSetKey))
    await database.KeyDeleteAsync(sortSetKey);

await database.SortedSetAddAsync(sortSetKey, 111, 111);
for (double i = 0; i < 10;)
{
    await database.SortedSetAddAsync(sortSetKey, i.ToString(), i);
    i = i + (double)0.5;
}

var sortSetValues = await database.SortAsync(sortSetKey);
Console.WriteLine($"{JsonConvert.SerializeObject(sortSetValues)}");


if (await database.SortedSetAddAsync(sortSetKey, "999", 999))
    Console.WriteLine($"{sortSetKey}插入数据999(分数999)：成功");
else
    Console.WriteLine($"{sortSetKey}插入数据999(分数999)：失败");
//失败
if (await database.SortedSetAddAsync(sortSetKey, "999", 999))
    Console.WriteLine($"{sortSetKey}插入数据999(分数999)：成功");
else
    Console.WriteLine($"{sortSetKey}插入数据999(分数999)：失败");
//成功 可以加入同分数不同值的数据
if (await database.SortedSetAddAsync(sortSetKey, "888", 999))
    Console.WriteLine($"{sortSetKey}插入数据888(分数999)：成功");
else
    Console.WriteLine($"{sortSetKey}插入数据888(分数999)：失败");
//失败
if (await database.SortedSetAddAsync(sortSetKey, "999", 888))
    Console.WriteLine($"{sortSetKey}插入数据999(分数888)：成功");
else
    Console.WriteLine($"{sortSetKey}插入数据999(分数888)：失败");

var length = await database.SortedSetLengthAsync(sortSetKey);

//根据排名条件读取value
var rankValues = await database.SortedSetRangeByRankAsync(sortSetKey, start: 0, stop: 10, order: Order.Descending);
Console.WriteLine($"{JsonConvert.SerializeObject(rankValues)}");

//条件同上，读取value+scroe
var rankWithScoresValues = await database.SortedSetRangeByRankWithScoresAsync(sortSetKey, start: 0, stop: 10, order: Order.Descending);
Console.WriteLine($"{JsonConvert.SerializeObject(rankWithScoresValues)}");

//降序读取分数在0-10之间的数据value
var scoreValues = await database.SortedSetRangeByScoreAsync(sortSetKey, start: 0, stop: 10, order: Order.Descending);
Console.WriteLine($"{JsonConvert.SerializeObject(scoreValues)}");

//条件同上，读取value+scroe
var scoreWithScoresValues = database.SortedSetRangeByScoreWithScoresAsync(sortSetKey, start: 0, stop: 10, order: Order.Descending);
Console.WriteLine($"{JsonConvert.SerializeObject(scoreWithScoresValues)}");

//根据value筛选
var rangeByValues = await database.SortedSetRangeByValueAsync(sortSetKey, 0, 998);
Console.WriteLine($"{JsonConvert.SerializeObject(rangeByValues)}");

//返回排名，默认从低到高，从0开始
var rank1 = await database.SortedSetRankAsync(sortSetKey, "888");
//不存在，返回null
var rank2 = await database.SortedSetRankAsync(sortSetKey, "325435435");


if (await database.SortedSetRemoveAsync(sortSetKey, "888"))
{
    Console.WriteLine($"删除888:成功");
}
else
{
    Console.WriteLine($"删除888:失败");
}

//递增2
var testMember = "testMember";
for (int i = 0; i < 10; i++)
    await database.SortedSetIncrementAsync(sortSetKey, testMember, 2);

for (int i = 0; i < 10; i++)
    await database.SortedSetDecrementAsync(sortSetKey, testMember, 3.6);

```











## 五. MongoDB

### 1. MongoDB简介

MongoDB是由C++开发的一个基于分布式文件存储的开源数据库系统.

MongoDB的主旨**为了Web应用提供可扩展的高性能数据库存储解决方案**

MongoDB讲数据库存储为一个文档,其中的结构以键值对的形式构成.我们观察的时候,里面内容都是类似于json文件的格式

### 2. MongoDB的安装

<img src="imgs/67.png" style="zoom:50%;" />



<img src="imgs/68.png" style="zoom:50%;" />



## 六. Sqlite

1. 去官网下载数据库压缩包以及数据库工具包https://www.sqlite.org/download.html

![](imgs/69.png)

2. 把数据库文件与工具文件解压到一起,并且拖放到我们常用的软件安装位置,例如:D:\Software\Sqlite

3. 配置环境变量,把我们文件保存的位置放入Path环境下
4. 在cmd窗口当中输入Sqlite3进入到数据库,之后通过.open 数据库名称.db 来创建数据库文件



# 4. 操作系统

## A. 程序员需要掌握的系统都有哪些?

Windows ,  Linux  , Windows Server (这个是只针对于服务器的系统) IIS

## Linux系统

Linux 是 1991年 Linus(林纳斯)研发出来的一个开源的,免费的操作系统.

之前Linux主要指的是 系统的核心,现在 泛指操作系统

它存在着多个发布版本(大部分的功能都是程序员或者黑客进行完善的)

(1) Red Hat(红帽子) 唯一个系统软件收费的

(2) Deepin  这个是国内开发的一个版本 界面特别的好看,存在着大量的预装软件

这个系统只是在Ubuntu系统上做了层"皮肤"

(3) Ubuntu  这个是最贴近于Windows的系统

(4) CentOS 这个是国内使用量最大的Linux发布版本,国内基本所有的服务器采用的

都是这个系统

(5) Debian  这个是国外服务器上架设 VPS系统的主流系统

> vpn与vps 之间的区别: 
>
> vpn 在国内架设一个虚拟服务器,通过这个让我们能够访问外网,现在是违法的
>
> 不要碰
>
> vps 这个是系统的一种类型,主要用于客户端与服务器之间的数据交互,它也能
>
> 实现访问外网,但是有个要求,你必须拥有一个国外的服务器

(6) Kali Linux  这个系统主要是做渗透用的,之前黑客在大量的使用. 

## 虚拟机

CentOS  系统镜像  4.4GB

VMware 虚拟机      500MB 

虚拟机官网: [VMware 中国 - 交付面向企业的数字化基础 | CN](https://www.vmware.com/cn.html)

我们需要下载的是VMware WorkStation  16  Pro   , 这个虚拟机是收费的,激活

如果我们电脑是Win10或者Win11,想要安装这个内容需要把电脑的Hyper-V 关闭了

Hyper-v : Windows 当中用于设置容器的

> 如何查看自己电脑Hyper-v是否关闭
>
> (1) win+r ,之后输入 control 回车 
>
> (2) 点击程序
>
> (3) 启动或者关闭应用程序
>
> (4) 查看Hyper-v前面是否存在对号,有就点掉

虚拟机安装步骤(略)

**什么是虚拟机**

在自己当前系统当中模拟出另一个系统,模拟出来的系统与我们现在原本的系统无关

> 两种系统镜像的扩展名: .iso , .img

CentOS(略)

系统安装完成之后,我们需要在电脑桌面打开终端

输入下面的指令,这个指令需要我们联网

``` shell
sudo yum -y update 
```

这是使用管理员权限更新系统所有配置

(1) 添加微软的信用包,让CentOS支持微软的内容

``` shell
sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm
```

(2) 安装SDK

``` shell
sudo yum install dotnet-sdk-6.0
```

sudo 用于使用管理员权限操作后面的命令

yum 这个是CentOS 当中系统操作的命令,更新或者安装软件都需要使用它

(3) 安装运行时

``` shell
sudo yum install aspnetcore-runtime-6.0
```

> 如果我们通过sudo命令提示账号...不在sudoers文件夹里的,我们使用下面的\
>
> 命令进行切换用户(高级管理员)
>
> ``` shell
> su root
> ```

## Linux 基础命令

### 1. 查看当前目录下所有文件

``` shell
ls
```

上面的命令并不会查看隐藏文件

**查看所有文件包含隐藏文件**

``` shell
ls -a
```

隐藏文件是以.为开头的,我们观察到所有内容当中包含2种颜色,黑色代表的是文件,

蓝色代表的是文件夹

我们现在有个要求:要求列表形式展示显示文件

``` shell
ls -l
```

展示效果如下:

![](imgs/20.png)

​     权限                           包含文件个数  创建用户  修改用户    日期       文件名 



我们现在要求以列表形式展示所有数据

``` shell
ls -la
```

### 2. 创建文件夹命令

``` shell
mkdir 文件夹名
```

### 3. 进入某个路径

``` shell
cd 对应路径
```

### 4. VI编辑器

这个是我们最近要经常用的一个内容,就是windows当中的记事本,能够编译任何文件,

这个编辑器是以控制台形式运行的

VI编辑器的工作模式:

VI编辑器包含三种模式: 命令模式 , 插入模式 , 底行模式

命令模式是我们刚打开VI编辑器的模式,主要是让我们进行命令操作

插入模式是让我们编辑文件的

底行模式是让我们对这个文件进行保存退出,或者强制退出操作的

命令切换插入: 按 i 键

插入切换命令: 按esc

命令切换底行: 按冒号:

底行切换命令: 按esc

---

## 扩展

## 一. Python

### 1. 数据类型

Python当中的数据类型有：int , float , str , boolean , list , dict , tuple 

int 用于存储整数

float 用于存储小数

str    用于存储字符串

list    列表

dict   字典

tuple 元组

#### a. 列表

列表的声明：

``` python
列表名 = [值1,值2]
```

> 声明一个空的列表怎么声明
>
> 列表名 = [ ]

我们可以通过下标找到列表当中的每个位置上的值

> 我们该如何得到列表的长度
>
> 我们可以通过len函数来得到这个长度值

列表的存值

``` python
列表名.append(值);
```

列表插入值

``` python
列表.insert(索引,值)
```

切片

``` python
列表名[startIndex : endIndex]
```

删除

``` python
列表名.remove(要删除的值);
```

``` python
列表名.pop() #pop是用于删除当前列表的最后一个值的 
```

pop()函数一般我们用于扔出某个列表的最后一个值，扔出之后会在列表当中直接删掉这个值

#### b. 元组

元组也是让我们存储一个连续多个值的数据类型，这个内容与列表的使用不同，**元组当中的数据是不允许改变的**

语法：

``` python
元组名 = (元组值)
```

> 我们现在想要声明一个空的元组，该如何声明
>
> 元组名=()
>
> 如果元组当中只存在一个值
>
> 元组名=(值,)

阅读代码说结果

``` python
t = (1,2,3,['张三','李四'])
t[3].insert(1,'猿师傅')
print(t)
```

#### c. 字典

python当中的字典，其实与我们之前学的Json字符串类似。

``` python
字典名 = {key:value,...}
```

字典存值

``` python
字典名[key] = value
```

字典删除值

``` python
字典名.pop(key)
```

``` python
字典名.clear() 
```

### 2. 函数

语法：

``` python
def 函数名([参数列表]):
    [return]代码块
```

### 3. 面向对象编程

Python是一门面对对象编程语言，对面向对象语言编码的过程叫做面向对象编程。

我们在学习面向对象的时候需要了解如下内容：

* 类：用来描述具有相同属性和方法的对象的集合。类定义了集合中每个对象公寓欧的属性和方法。对象是类的实例。
* 类变量（属性）:类变量在整个实例化的对象中是公用的。类变量定义在类中，且在方法之外。类变量通常不作为实例变量使用。类变量也称作属性。
* 数据成员：类变量或实例变量用于处理类及其实例对象的相关数据。
* 方法重写：如果从父类继承的方法不能满足子类的需求，就可以对其进改写，这个过程称为方法的覆盖（Override）,也称为方法的重写。
* 实例变量：定义在方法中的变量只作用于当前实例的类。
* 多态(Polymorphism)：对不同类的对象使用同样的操作。
* 封装(Encapsulation)：对外部世界隐藏对象的工作细节
* 继承(Inheritance)：即一个派生类(derived class)继承基类(base class)的字段和方法。继承允许把一个派生类的对象作为一个基类对象对待，以普通类为基础建立专门的类对象
* 实例化(Instance)：创建一个类的实例、类的具体对象。
* 方法：类中定义的函数。
* 对象：通过类定义的数据结构实例。对象包括两个数据成员(类变量和实例变量)和方法。

和其他编程语言相比，Python在尽可能不增加新语法和语义的情况下加入了类机制。

#### 3.1 类的定义与使用

我们可以直接在Python文件当中书写如下代码来创建类：

``` python
class 类名[(object)]:
    代码块
```

我们可以看到类名的后面可以加上一个(object)该内容表示的是当前类继承于object类，于我们之前学习的C#一样。如果该类不需要继承其他类内容，那么这个类默认会继承Object类。

当我们创建完类之后如果想要使用这个类，那么我们只需要实例化进行调用即可。

实例化语法：

``` python
对象名 = 类名()
```

#### 3.2 构造函数

在我们之前学习的C#当中每个类都会带有构造函数，那么Python当中也是存在构造函数的，但是它的写法与C#不同。

``` python
class 类名:
    def __init__(self,property,..):
        self.property = property    
```

上面的写法就是Python当中的带参构造。其中第一个参数self代表自己本身，要求必带。

> 在类当中声明的函数第一个参数也一定要写self，如：
>
> ``` python
> def show(self,args1,args2):
>     代码块
> ```
>
> 如果该函数没有参数，那么self参数也必须要写

在Python当中，\__init__方法时一个特殊方法，在对象实例化时会被调用。\_\_init\_\_的意思是初始化，是initialzation的简写。

这个方法的书写方式是:先输入两个下划线，后面接着init，再接着两个下划线，最后加上小括号。这个方法也叫构造方法。

#### 3.3 类的访问权限

在类内部有属性和方法，外部代码可以通过直接调用实例变量的方法操作数据，这样就隐藏了内部的复杂逻辑。

当我们想要让内部属性不被外部访问，我们可以在属性名称前面加两个下划线。在Python中，实例的变量名如果以__开头，就会变成私有变量(private)，只有内部可以访问，外部不能访问。

#### 3.4 继承

面对对象编程带来的好处之一是代码的重用，实现重用的方法之一是通过继承机制。继承完全可以理解成类之间类型和子类型的关系。

在面向对象程序设计中，当我们定义一个class时，可以从某个现有的class继承，定义的新class称为子类(Subclass)，而被继承的class称为基类、父类或超类(Base class、Super class),语法如下：

``` python
class SubClassName(BaseClassName):
    代码块
```

在Python中，继承有以下特点:

(1) 在继承中，基类的构造方法(\__init__方法)不会被自动调用，需要在子类的构造方法中专门调用。

(2) 在调用基类的方法时需要加上基类的类名前缀，并带上self参数变量。区别于在类中调用普通函数时不需要带self参数。

(3) 在Python中，首先查找对应类型的方法，如果在子类中找不到对应的方法，才到基类中逐个查找。

> python 是支持多继承的，语法如下
>
> ``` python
> class SubClassName(Base1,Base2,Base3,...):
>     代码块
> ```
>
> 





#### 3.5 多态

多态来自于希腊语，意思是多种形式。多态意味着即使不知道变量所引用的对象类型是什么，也能对对象进行操作，多态会根据对象(或者类)的不同而表现出不同的行为。

#### 3.6 封装

封装是全局作用域中其他区域隐藏多余信息的原则。听起来有些像多态，使用对象而不用知道其内部细节。它们都是抽象原则，都会帮忙处理程序组件而不用过多关心细节，就像函数一样。

封装并不等同于多态。多态可以让用户对不知道类(或对象类型)的对象进行方法调用，而封装可以不用关心对象是如何构建的，直接使用即可。

### 4. 异常

异常是一个事件，该事件会在程序执行过程中发生，影响程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生异常。异常是Python的对象，表示一个错误。当Python脚本发生异常时，我们需要捕获并处理异常，否则程序会终止执行。

每个异常都是一些类的实例，这些实例可以被引用，并且可以用很多种方法进行捕捉，使得错误可以被处理，而不是让整个程序失败。

捕捉异常的语法如下：

``` python
try:
    可能发生异常的代码块
except 异常名称:
    处理异常的代码块
```

例如：

``` python
def calc(a,b):
    try:
        c = a/b
        print('c=',c)
        return c
    except Exception:
        print('程序出现异常，异常信息为：被除数为0')
        
calc(2,0)        
```

运行上面的代码，结果是“程序出现异常，异常信息为：被除数为0”

### 5. 爬虫（BeautifulSoup）

我们之前说的需要先去导入一个模块 requests,我们需要通过这个模块进行模拟浏览器访问网站

``` python
import requests
```

我们之后进行调用requests的get方法里面用于存储要访问的网址路径。

``` python
requests.get('https://www.baidu.com')
```

但是有的网站带有反爬效果，我们需要在浏览器当中找到用户的参数（User-Agent），之后进行设定

``` python
headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.10.5060.114 Safari/537.36 Edg/103.10.1264.62'}
requests.get(url,headers=headers)
```

通过get函数我们可以得到当前这个页面的数据对象

我们可以通过get函数得到的这个对象带有的content属性拿到网站代码，但是有可能出现乱码

``` python
html = requests.get(url,headers=headers)
html.encoding = 'UTF-8'
print(html.content)
```

当我们得到网站内容之后，需要进行数据筛选

(1) xpath : 这种是通过正则表达式进行的筛选，对代码的要求较高，尤其必须精通正则表达式

(2) BeatifulSoup ： 这个是第三方库文件，需要我们额外的进行安装，它是通过lxml进行筛选的

案例： 爬取百度网页上的全部图片

``` python
from bs4 import BeautifulSoup
import requests

headers = {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.10.5060.114 Safari/537.36 Edg/103.10.1264.62'
}

html = requests.get('http://baidu.com',headers=headers)
html.encoding = 'UTF-8'

soup = BeautifulSoup(html.content,'lxml')
lists = soup.select('img')
index = 1
for item in lists:
    url = item.get('src')
    if(url.startswith('https:') == False):
        url = 'https:' + url
    fileName = str(index) + '.' + url.split('.')[-1]
    path = 'C:\\Users\\haha\\Desktop\\2022.07.25\\images\\' + fileName
    img_content = requests.get(url)
    with open(path, 'wb') as f:
        f.write(img_content.content)
        f.close();
    index += 1

print('完成')
```

### 6. 正则表达式

正则表达式是用于对字符串进行匹配操作，符合正则表达式逻辑的字符能被匹配并提取出来。Python内置的re模块可以处理正则表达式。

正则表达式由一些特定的字符串组成，每个字符有不同的含义。

#### 6.1 re模块

##### 6.1.1 re.match函数

一般使用re的步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果，最后使用match函数获得信息，进行其他操作。

re.match函数尝试从字符串的起始位置匹配一个模式，该函数语法如下：

``` python
re.match(pattern,string,flags=0)
```





#### 7. Pandas模块

Pandas模块是数据结构和数据处理的工具,它在处理Python中进行的数据清洗与数据分析非常快捷. pandas经常是和其他数值计算的工具,例如: Numpy和SciPy,以及数据可视化工具比如:matplotlib一起使用.

**Pandas支持大部分NumPy语言风格的数组计算,尤其是数组函数以及没有for循环的各种数据处理**

##### 7.1 安装

``` shell
pip install pandas
```

##### 7.2 使用

(1) 需要我们对pandas进行导入

``` python
import pandas as pd
```

我们除了对上面pandas的引用以外还可以添加对本地命名空间的导入 Series 和 DataFrame,这两个都是我们常用的类

``` python
from pandas import Series,DataFrame
```

(2) 进行使用

###### 7.2.1 Series

Series是一种一维的数组型对象,它包含了一个值序列(*与NumPy的类型相似*),并且包含了一个数据标签,称为index(索引).最简单的序列可以是一个数组组成,例如:

``` python
import pandas as pd
from pandas import Series,DataFrame

names = ['电月画','石某源','猿师傅']

obj = pd.Series(names)

print(obj)
```

打印效果如下:

![](imgs/63.png)

##### 7.2.2 DataFrame

DataFrame表示的是矩阵的数据表,它包含已排序的列集合,每一列可以是不同的值类型(数值,字符串,布尔值等等). DataFrame 既有行索引,它又有列索引,它可以被视为一个共享相同索引的Series字典.在DataFrame中,数据被存在一个以二维数组当中,而不是列表,字典或者其他的以为数组的集合当中.

``` python
import pandas as pd
from pandas import Series,DataFrame
data ={
    'names':['电月画','石某源','猿师傅'],
    'scores':[65,80,50],
    'bornTime':['1999-03-17','2004-07-08','2006-12-12']
}
frame = pd.DataFrame(data) # 把我们上面的数据转换为对应的数据表格形式,这个表格是带有索引的
```

我们以后需要对上面的数据进行持久化存储, 把内容直接存入的Excel,我们可以调用DataFrame()带有的to_excel()函数

``` python
frame.to_excel('转换excel测试.xlsx',index=False)
```

第一个参数值代表是我们要存入的excel文档的路径,第二个参数的含义代表不带有索引列

#### 8. 自动化处理电子邮件

##### 8.1 自动发送电子邮件

常见的电子邮件: 网易邮箱,QQ邮箱,新浪邮箱等等. **我们上课只会讲QQ邮箱**

###### 8.1.1 获取SMTP授权码

SMTP授权码,这个不是邮箱的登入密码,而是我们通过程序实现自动发送邮件所需要的授权码.

(1) 打开登入QQ邮箱之后,点击设置,之后选择账户选项卡

(2) 找到下面开启服务中的"POP3/SMTP服务",点击右侧开启按钮

###### 8.1.2 自动发送文本格式的电子邮件

我们需要使用一个新的模块 smtplib,之后我们可以按照下面的代码进行书写

``` python
import smtplib
from email.mime.text import MIMEText

user = 'XXXXXX@qq.com' # 这个是我们自己要发送的账号
code  = 'XXXXXXXX' # 这个是授权码
toUser = 'XXXXXX@qq.com'  # 这个是接收的账号

# 我们下面开始设定要发送的邮件格式
message = MIMEText('Hello') # 这个里面存放的是发送邮件的正文内容
message['Subject'] = 'this is a Test Email'    # 这个是让我们进行设定邮件的主题内容
message['From'] = user  # 这个是让我们设定从哪个账号进行发送
message['To'] = toUser  # 这个是让我们设定哪个账号进行接收

# 下面的内容是进行配置邮件发送
server = smtplib.SMTP_SSL('smtp.qq.com',465) # 这个里面我们需要存储2个参数,第一个参数代表QQ邮箱的SMTP服务器的地址,第二个参数代表的是
# QQ邮箱SMTP服务器的端口 
server.login(user,code)  # 设定登入我们要发送的邮箱

server.send_message(message) # 设定发送的信息

server.quit() # 关闭服务
print('发送成功')
```

###### 8.1.3 自动发送HTML格式的电子邮件

这种格式的内容,一般存在于以后的账号验证信息,点击之后进行页面跳转的超链接,HTML格式的电子邮件是允许我们在内容当中输入正常的HTML代码的

``` python
import smtplib
from email.mime.text import MIMEText

user = 'XXXXXX@qq.com' # 这个是我们自己要发送的账号
code  = 'XXXXXX' # 这个是授权码
toUser = 'XXXXXX@qq.com'  # 这个是接收的账号

# 我们下面开始设定要发送的邮件格式

msg = '''
    <h2>这个是html格式的邮件</h2>
    <p>
        <a href="https://www.jd.com">包含跳转的路径信息</a>
    </p>
'''

message = MIMEText(msg,'html','utf-8') # 这个里面存放的是发送邮件的正文内容
message['Subject'] = 'this is a Validate Email'    # 这个是让我们进行设定邮件的主题内容
message['From'] = user  # 这个是让我们设定从哪个账号进行发送
message['To'] = toUser  # 这个是让我们设定哪个账号进行接收

# 下面的内容是进行配置邮件发送
server = smtplib.SMTP_SSL('smtp.qq.com',465) # 这个里面我们需要存储2个参数,第一个参数代表QQ邮箱的SMTP服务器的地址,第二个参数代表的是
# QQ邮箱SMTP服务器的端口 
server.login(user,code)  # 设定登入我们要发送的邮箱

server.send_message(message) # 设定发送的信息

server.quit() # 关闭服务
print('发送成功')
```

###### 8.1.4 自动发送带有附件的电子邮件

``` python
from fileinput import filename
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

user = 'xxxxxx@qq.com' # 这个是我们自己要发送的账号
code  = 'xxxxxx' # 这个是授权码
toUser = 'xxxxx@qq.com'  # 这个是接收的账号

# 我们下面开始设定要发送的邮件格式

msg = '''
    <h2>这个是html格式的邮件</h2>
    <p>
        <a href="https://www.jd.com">包含跳转的路径信息</a>
    </p>
'''

message = MIMEMultipart()
message.attach(MIMEText(msg,'html','utf-8')) # 这个是带有附件邮件的正文内容

fj = MIMEText(open('C:\\Users\\feng2\\Desktop\\2022.09.01\\转换excel测试.xlsx','rb').read(),'base64','utf-8') 
# 上面代码代表我们读取指定路径的文件,并且把它用字节进行读取,读取的格式为base64,字节编码为utf-8
fj['Content-Type'] = 'application/octet-stream'  # 设置附件的内容类型,内容类型是固定
fj.add_header('Content-Disposition','attachment',filename=('utf-8','','测试表格.xlsx')) # 对附件信息的头部信息进行设定
message.attach(fj)  # 设定附件信息
 

message['Subject'] = 'this is a Validate Email'    # 这个是让我们进行设定邮件的主题内容
message['From'] = user  # 这个是让我们设定从哪个账号进行发送
message['To'] = toUser  # 这个是让我们设定哪个账号进行接收

# 下面的内容是进行配置邮件发送
server = smtplib.SMTP_SSL('smtp.qq.com',465) # 这个里面我们需要存储2个参数,第一个参数代表QQ邮箱的SMTP服务器的地址,第二个参数代表的是
# QQ邮箱SMTP服务器的端口 
server.login(user,code)  # 设定登入我们要发送的邮箱

server.send_message(message) # 设定发送的信息

server.quit() # 关闭服务
print('发送成功')
```

###### 8.1.5 批量发送邮件

``` python
import pandas as pd
import smtplib
from email.mime.text import MIMEText
'''
    1. 要求把我们要发送的人的账号信息存入到excel
    2. 通过pandas进行读取excel文件
'''
data = pd.read_excel('联系人.xlsx',sheet_name=0) # 读取联系人excel当中默认第一个表
e_mail = data['联系人邮箱'].tolist() # 在得到的表数据当中获取联系人邮箱那个列的数据,并且转换为列表格式

to = ','.join(e_mail)  # 发送的目标
user = 'xxxxx@qq.com' # 这个是我们自己要发送的账号
code  = 'xxxxxxx' # 这个是授权码 

# 我们下面开始设定要发送的邮件格式
message = MIMEText('Hello') # 这个里面存放的是发送邮件的正文内容
message['Subject'] = 'this is a Test Email'    # 这个是让我们进行设定邮件的主题内容
message['From'] = user  # 这个是让我们设定从哪个账号进行发送
message['To'] = to  # 这个是让我们设定哪个账号进行接收

# 下面的内容是进行配置邮件发送
server = smtplib.SMTP_SSL('smtp.qq.com',465) # 这个里面我们需要存储2个参数,第一个参数代表QQ邮箱的SMTP服务器的地址,第二个参数代表的是
# QQ邮箱SMTP服务器的端口 
server.login(user,code)  # 设定登入我们要发送的邮箱

server.send_message(message) # 设定发送的信息

server.quit() # 关闭服务
print('发送成功')
```

###### 8.1.6 定时发送电子邮件

(1) 使用 while True 语句

(2) 使用Schedule模块

**(1) 利用while True循环实现定时发送电子邮件**

这种发送方式需要我们与time模块进行连用

``` python
import time
while True:
    # 这个地方来进行书写邮件发送的代码
    time.sleep(3600) # 这个代表等待3600秒之后,进入下一次循环
```

这种写法是带有缺点:因为程序的运行也需要一定的时间,所以发送邮件的间隔时间不是精确3600秒,这种方法适用于对时间精度要求不高的场景.

**(2) 利用Schedule模块实现定时发送电子邮件**

(1) 安装Schedule模块

``` shell
pip install Schedule
```

(2) 代码实现

``` python
import schedule
import time

def e_mail():
    print('该发邮件了') # 以后这个地方我们需要存放的是发送邮件的代码

schedule.every().day.at('17:30').do(e_mail)  # 这个是通过schedule模块设定每天下午17点半去执行e_mail的方法
# schedule.every().hour.do(e_mail)   这个代表是每小时执行一次
# schedule.every(5).minutes.do(e_mail) 这个代表的是每分钟执行一次
# schedule.every().monday.at('时间').do(e_mail)   每个星期一在指定的时间上进行执行

while True:
    schedule.run_pending() # 这个是让我们来执行上面的设置(我们可以通过run_pending()来运行所有可以运行的schedule任务)
    time.sleep(10) # 这个是代码每隔10秒来进行检测是否有可以运行的任务

```



## 二.  微信小程序

### 1. 简介

小程序是一种不需要下载安装即可使用的应用，它实现了应用"触手可及"的梦想，用户扫一扫或者搜索一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载。

### 2. 环境搭建与开发工具介绍

小程序的开发工具官方名称为:"微信Web开发者工具"，其下载路径是:https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html。

官方提供了3个版本的开发工具安装包：Windows 64位，Windows 32位和Mac。我们需要根据我们自己的开发环境进行下载。

> 当我们安装完成之后，点击打开的时候，如果是第一次打开或者长时间未使用，开发工具会弹出一个二维码，这个是让我们用自己的微信扫码进行登录的。
>
> 当我们登录完成之后，首选页面一共有2个工具，分别是“本地小程序项目”和“公众号网页开发”。
>
> “本地小程序项目”是用来开发，调试，发布微信小程序的。当我们点击“本地小程序项目”，将会出现项目创建的界面。这个页面中需要我们输入“AppID”，“项目名称”，“项目目录”3个选项。
>
> 其中AppID代表微信小程序的ID号，必须拥有微信小程序账号才可以申请这个ID号。
>
> 我们可以去https://mp.weixin.qq.com这个网址进行申请。

### 3. 创建第一个微信小程序



## 三. GoLang

### 1. 简介

​	Go语言是一个开源的编程语言,它能让构造简单,可靠高效的软件变得容易.

​	Go语言是从2007年末由Robert ,Ken , 主持开发,并且于2009年11月开源.在2012年早些时候发布了Go 1稳定版本.

​	**Go语言特色**

    * 简介,快速,安全
    * 并行,有趣,开源
    * 内存管理,数组安全,编译迅速

   Go语言的代码源文件是以.go为扩展名的文件,我们想要电脑能够执行go语言文件,需要去安装其运行环境.

### 2. 运行环境

我们可以去官网下载go语言的安装包.官网的网址https://golang.google.cn/dl/ ,我们进入官网选择windows版本下载安装即可.

当我们安装完成之后,go语言会默认安装在C盘的根目录下,我需要把go语言安装目录下的bin文件夹的路径配置到环境变量当中.

在Go语言1.12版本之后,开始使用go mod模式来管理依赖环境了,由于国内访问不到默认的GOPROXY配置链接,所以我们需要换一个PROXY,https://goproxy.io或https://goproxy.cn

``` shell
go env -w GOPROXY=https://goproxy.cn,direct
```

**GO MOD 设置**

要启用go module支持首先需要设置环境变量GO111MODULE,通过它可以开启或者关闭模块支持,它有三个可选值:off , on , auto, 默认值是auto

``` shell
go env -w GO111MODULE=on
```

通过上面的命令我们启用模块支持,之后就可以使用go module模式新建项目了,

### 3. 新建项目

在cmd当中,我们进入要创建项目的文件夹,之后进行下面的命令输出,用于创建项目

``` shell
go mod init 项目名称
```

通过这个命令我们会在对应的目录下创建出一个go.mod文件,这个文件是go项目的依赖项文件,以后这个项目当中所有的依赖内容都会添加到这个文件里.

我们还需要使用下面的命令去初始化我们当前项目的依赖项,把所需要的依赖项添加进行,并且不需要的依赖项删除掉

``` shell
go mod tidy
```

**上面的这命令一般是我们在新建完项目之后,书写完代码之后,运行之前使用,或者把其他人的项目引入想要运行的时候**

#### 新建第一个Go文件

Go编程语言的代码文件都是以.go为扩展名的文件

``` go
package main // 这个是让我们声明当前的包为main
import "fmt" // 这个是导入允许Go在控制台输出的包,相当于C#当中的Console

func main() { //这个是Go的主方法

	fmt.Println("Hello World") //这个是让我们在控制台当中输出Hello World
}

```

想要运行上面你得代码我们可以使用下面的命令

``` shell
go run 文件名.扩展名
```

**关键字**

| break    | default     | func   | interface | select |
| -------- | ----------- | ------ | --------- | ------ |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

**预定义标识符**

| append  | bool    | byte    | cap  | close | complex | complex64 | complex128 | unit16  | copy  |
| ------- | ------- | ------- | ---- | ----- | ------- | --------- | ---------- | ------- | ----- |
| false   | float32 | float64 | imag | int   | int8    | int16     | unit32     | int32   | int64 |
| iota    | len     | make    | new  | nil   | panic   | unit64    | print      | println | real  |
| recover | string  | true    | unit | unit8 | unitptr |           |            |         |       |

特殊符号:  .   ,    ;    : 和 ...

### 4. 数据类型

go语言当中数据类型一共分为4大类：

(1) 布尔型：bool

(2) 数字类型：整型 int 和浮点型 float ,go还支持复数，其中位的运算采用补码

(3) 字符串类型: go语言采用的是UTF-8编码

(4) 派生类型: 

	* 指针类型(Pointer)
	* 数组类型
	* 结构体类型(struct)
	* 联合体类型(union)
	* 函数类型
	* 切片类型
	* 接口类型(interface)
	* Map类型
	* Channel类型

### 5. 变量

变量的声明：

（1） 先声明后赋值

``` go
var 变量名 变量类型
变量名 = 值
```

（2）在声明的同时直接赋值

``` go
var 变量名 = 值
```

根据值的数据类型，来指定变量是哪种数据类型

（3）省略var关键字进行声明

``` go
变量名 := 值
```

> := 符号左边的变量必须是没有被声明过的变量，如果这个变量在其他地方已经声明过了，代码会报错

### 6. 常量

``` go
const 常量名 [数据类型] = 值
```

> 通过声明变量和常量计算以下，半径为5的圆的面积和周长分别是多少
>
> 面积 Πr[^2]   周长  2Πr

**Go语言要求必须是同种数据类型的内容才允许运算**

%d   %c   %f   %lf   %s

### 7. 选择条件语句

if语句  switch语句  select语句

#### 1. if语句

简单if , 多重if , if嵌套

#### 2. switch语句

``` go
switch 要进行对比的变量{
    case 
}
```













## 四. WPF

### 1.  XAML

XAML全称是Extensible Application Markup Language,中文解释为可扩展应用程序标记语言.它在桌面开发及富媒体网络应用程序的开发中扮演了HTML+CSS+JavaScript的角色

XAML优点:

* XAML可以设计出专业的UI和动画 ---> 好用
* XAML不需要专业的编程知识,特别易懂,代码结构清晰 ---> 易学
* XAML使设计师能够直接参与到软件项目的开发当中,随时沟通.无需二次转化 ---> 高效

现在的Wpf共有2个版本,一个是针对于.Net Framework  另一个是针对于.net 6,我们现在创建的是.net framework版本.

我们去新建一个Wpf Application(.Net Framework)的项目,项目的结构如下:

![](imgs/66.png)

Properties: 里面的主要内容是程序要用到的一些资源(如 图片,静态的字符串)和配置信息

References: 这个是然我们来引用其他项目或者类库的

App.xaml : 程序的主体.Windows系统当中要求:一个程序就是一个进程,一个GUI进程需要有一个窗体作为主窗体.

App.xaml作用就是声明了程序的进程会是哪个,同时制定了程序的主窗体是谁.App.xaml.cs这个文件是App.xaml文件的后台代码.

MainWindow.xaml 这个文件就是当前项目的主窗体



### 2. 解析最简单的XAML代码

``` xml
<Window x:Class="WpfApp1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp1"
        mc:Ignorable="d"
        Title="第一个wpf界面" Height="450" Width="800">
    <Grid>
        
    </Grid>
</Window>

```

Window是窗体当中的根节点,并且xaml文件里面的语法书写需要符合xml文件的规则,**每个文件当中只能存在一个根节点**

Window节点下我们需要知道3个属性:

Title : 这个属性是用于更改窗体的标题

Height: 这个属性是用于更改窗体的高度的

Width: 这个属性是用于更改窗体的宽度的

---

Grid标签:这个标签是代表Window窗体当中的内容



我们现在所要学习的XAML是一种"声明"式语言,当我们见到一个标签,就意味着声明了一个对象,对象之间的层级关系要么是并列,要么是包含,全部体现到标签的关系上.

**XAML语法比较类似于Winform,我们可以在工具箱当中拖出想要的控件**

我们在拖动控件的时候,这个控件并不会带有winform当中的id属性,我们需要手动添加一个,xaml当中使用的

x:Name 通过这个属性来进行识别标签

### 3. x名称空间

"x名称空间"的这个x是映射XML名称空间时给它取的名字.x名称空间里的成员(x:Class,x:Name)是专门写给XAML编译器看的,用来引导XAML编译器把XAML代码编译成CLR代码.

XAML也有自己的编译器,它可以被解析和编译.

x名称空间所包含的工具:

| 名称            | 分类         |
| --------------- | ------------ |
| x:Array         | 标签扩展     |
| x:Class         | Attribute    |
| x:ClassModifier | Attribute    |
| x:Code          | XAML指令元素 |
| x:FieldModifier | Attribute    |
| x:Key           | Attribute    |
| x:Name          | Attribute    |
| x:Null          | 标签扩展     |
| x:Shared        | Attribute    |
| x:Static        | 标签扩展     |
| x:Subclass      | Attribute    |
| x:Type          | 标签扩展     |
| x:TypeArguments | Attribute    |
| x:Uid           | Attribute    |
| x:XData         | XAML指令元素 |

#### x名称空间的Attribute

Attribute与Property是两个层面的东西.Attribute是语言层面的东西,是给编译器看的,Property是面向对象层次的东西,是给编程逻辑用的.

**一个XAML标签的Attribute里面大部分都对应着对象的Property**

##### (1) x:Class

这个Attribute的作用是告诉XAML编译器将XAML标签的编译结果与后台代码指定的类合并.

想要使用x:Class需要遵守下面的要求:

* 这个Attribute只能用于根节点
* 使用x:Class的根节点的类型要与x:Class的值的类型保持一致
* x:Class的值所指示的类型在声明的时候必须使用partial关键字
* x:Class这个Attribute用于指明所对应的类的命名控件

##### (2) x:ClassModifier

这个Attribute的作用是告诉XAML编译器由标签生成的类具有什么样的访问控制级别

public  , protected ,internal ,private

##### (3) x:Name

这个Attribute是给控件起名的,通过这个名字我们可以实现在代码页面进行调用这个控件内容,x:Name当中的值一定不能出现重复项

##### (4) x:FieldModifier

它是让我们设定在XAML里改变引用变量访问级别的

``` xml
<TextBox x:Name="txtName" x:FieldModifier="public" ></TextBox>
```

这个属性的默认值是internal

##### (5) x:Key

这个Attribute主要的作用是给控件添加一个key,我们可以通过这个key,来遍历这些标签内容

``` xml
<Window x:Class="WpfApp1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp1"
        mc:Ignorable="d"
        Title="第一个wpf界面" Height="450" Width="800">
    <Grid>
       <Window.Resource>
        	<sys:String x:Key="myString">Hello World</sys:String>
        </Window.Resource>
        <StackPanel background="lightblue">
        	<TextBox Text="{StaticResource ResourceKey=myString}"></TextBox>
        </StackPanel>
    </Grid>
</Window>
```

##### (6) x:Shared

x:Shared必须与x:Key配合使用,.如果我们设定x:Shared当中的值为true,代表每次我们检索到对象的时候,我们得到的是同一个对象,如果我们设定x:Shared当中的值为false,代表每次我们检索到对象的时候我们得到的对象是完全新的一个对象

#### x名称空间中的标签扩展

英文是Markup Extension

##### (1) x:Type

这个是让我们用于设定一个数据类型.

例如: 我们去创建一个Button的派生类

``` C#
class MyButton : Button
{
    public Type UserWindowType{ get;set; }
    protected override void OnClick()
    {
        base.OnClick(); //激发Click事件
        Window win = Activator.CreateInstance(this.UserWindowType) as Window;
        if(win != null)
            win.ShowDialog();
    }
}
```

上面代码主要的作用是当我们点击按钮的时候,触发click事件,把我们使用UserWindowType的实体类用窗体显示出来.

``` xml
<Window x:Class="WpfApp1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp1"
        mc:Ignorable="d"
        Title="第一个wpf界面" Height="450" Width="800">
    <Grid>
        <StackPanel background="lightblue">
        	<TextBox x:Name="textBox1"></TextBox>
        	<TextBox x:Name="textBox2"></TextBox>
        	<TextBox x:Name="textBox3"></TextBox>
            <Button Content="Ok"></Button>
        </StackPanel>
    </Grid>
</Window>
```

上面的代码是我们主窗体的界面代码,我们还需要额外的创建一个窗体,用于把UserWindowType的值赋值Button属性

``` xml
<Window x:Class="WpfApp1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp1"
        mc:Ignorable="d"
        Title="第一个wpf界面" Height="450" Width="800">
    <Grid>
        <StackPanel background="lightblue">
        	<local:MyButton Content="Show" UserWindowType="{x:Type TypeName=local:MyWindow}"></local:MyButton>
        </StackPanel>
    </Grid>
</Window>
```

这个效果相当于我们页面跳转

##### (2) x:Null

这个是给某个属性赋予一个空值

##### (3) x:Array

这个属性是让我们通过它的Items属性项使用者暴露一个类型已知的ArrayList实例.

我们假如想要给ListBox控件绑定多个值

``` xml
<ListBox Margin="5" ItemsSource="{x:Array Type=sys:String Items=XXX}"/>
```

我们不建议安装上面的写法进行书写

``` xml
<ListBox Margin="5">
	<ListBox.ItemsSource>
    	<x:Array Type="sys:String">
        	<sys:String>LOL</sys:String>
        	<sys:String>DNF</sys:String>
        	<sys:String>WOW</sys:String>
        </x:Array>
    </ListBox.ItemsSource>
</ListBox>
```

##### (4) x:Static

x:Static是一个很常用的标记扩展,它的功能是在XAML文档中使用数据类型的static成员.在使用的时候我们需要在代码也当中添加对应的static修饰的属性并且带有属性值,例如:

``` C#
public partial class MyWindow:Window
{
    public static string msg = "xxx";
    public MyWindow()
    {
        InitializeComponent();
    }
    
}
```

剩下我们需要在xaml语言当中引入我们的静态成员

``` xml
<Window x:Class="WpfApp2.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp2"
        mc:Ignorable="d"
        Title="MyWindow" Height="450" Width="800">
    <Grid>
        <StackPanel>
            <TextBlock FontSize="20" Text="{x:Static local:MainWindow.msg}"></TextBlock>
        </StackPanel>
    </Grid>
</Window>
```

#### XAML指令元素

XAML的指令元素只有两个:

* x:Code : 这个标签的含义是让我们在设计界面当中书写一些本应该在后面代码当中的代码,这个内容用的不是特多
* x:XData: 它是一个专用标签,帮助某些标签来进行绑定数据源

​    例如: 现在我们使用一个数据提供者(Data Provider)的XmlDataProvider进行XML化数据

``` xml
<Window.Resources>
	<XmlDataProvider x:Key="InventoryData" XPath="BookData/Books">
    	<x:XData>
        	<Supermarkets xmlns="">
            	<Fruits>
                	<Fruits Name="Peach"></Fruits>
                	<Fruits Name="Banana"></Fruits>
                	<Fruits Name="Orange"></Fruits>
                </Fruits>
            </Supermarkets>
        </x:XData>
    </XmlDataProvider>
</Window.Resources>
```

### 4. 控件

#### 4.1 控件的分类

wpf当中控件的分类有6种:

(1) 布局控件: 用于容纳多个控件或者嵌套在其他布局控件当中,用于在UI上组织和排列控件.Grid,StackPanel,DockPanel等等

(2) 内容控件:  只能容纳一个其他控件或者布局控件作为它的内容.如: Window,Button等等

(3) 带有标题的内容控件: 相当于一个内容控件,但是可以加一个标题,标题部分也可以容纳一个其他控件或者布局控件. GroupBox,TabItem等等,它们共同的父类是HeaderedContentControl

(4) 条目控件: 可以显示一列数据,一般情况下这列数据的数据类型相同.例如: ListBox,ComboBox等等.它们的共同父类是ItemsControl

(5) 带有标题的条目控件: 相当于一个条目控件加上一个标题显示区.例如:TreeViewItem,MenuItem等等.它们的共同父类是HeaderedItemsControl

(6) 特殊内容控件: 例如: TextBox , TextBlock , Image

#### 4.2 WPF的内容模型

Wpf的UI元素类型

| 名称                   | 说明                             |
| ---------------------- | -------------------------------- |
| ContentControl         | 单一内容控件                     |
| HeaderedContentControl | 带有标题的单一内容控件           |
| ItemsControl           | 以条目集合为内容的控件           |
| HeaderedItemsControl   | 带有标题的以条目集合为内容的控件 |
| Decorator              | 控件装饰元素                     |
| Panel                  | 面板类元素                       |
| Adorner                | 文字点缀元素                     |
| Flow Text              | 流式文本元素                     |
| TextBox                | 文本输入框                       |
| TextBlock              | 静态文字                         |
| Shape                  | 图形元素                         |

> ContentControl族包含的控件有:
>
> | Button         | ButtonBase   | CheckBox              | ComboBoxItem     |
> | -------------- | ------------ | --------------------- | ---------------- |
> | ContentControl | Frame        | GrideViewColumnHeader | CroupItem        |
> | Label          | ListBoxItem  | ListViewItem          | NavigationWindow |
> | RadioButton    | RepeatButton | ScrollViewer          | StatusBarItem    |
> | ToggleButton   | ToolTip      | UserControl           | Window           |



> HeaderedContentControl族
>
> | Expander | GroupBox | HeaderedContentControl | TabItem |
> | -------- | -------- | ---------------------- | ------- |



> ItemsControl 族
>
> | Menu         | MenuBase | ContextMenu | ComboBox   |
> | ------------ | -------- | ----------- | ---------- |
> | ItemsControl | ListBox  | ListView    | TabControl |
> | TreeView     | Selector | StatusBar   |            |



> Shape族元素
>
> 这种元素用来在UI绘制图形一类元素,他们包含如下特点:
>
> * 均派生自Shape类
> * 用于2D图形绘制
> * 无内容属性
> * 使用Fill属性设置填充,使用Stroke属性设置边线

>Panel族元素
>
>所有的UI布局元素都是这一族的
>
>它们包含如下特点:
>
>* 均派生自Panel抽象类
>* 主要功能是控制UI布局
>* 内容属性为Children
>* 内容可以是多个元素,Panel元素将控制他们的布局
>
>| Canvas               | DockPanel              | Grid         | TabPanel    |
>| -------------------- | ---------------------- | ------------ | ----------- |
>| ToolBarOverflowPanel | StackPanel             | ToolBarPanel | UniformGrid |
>| VirtualizingPanel    | VirtualizingStackPanel | WrapPanel    |             |



## 五. Furion框架

### 1. 简介

该框架是百小僧开发出来的一个.net 框架,主要是让我们写项目能够更简介,更快的去完成任务

**框架特点:**

* 全新面貌: 基于 .Net5+ 平台,没有历史包袱
* 极少依赖: 框架只依赖两个第三方包
* 极易入门: 只需要一个 Inject() 即可完成配置
* 极其灵活: 轻松面对多变复杂的需求
* 极易维护: 采用独特的架构思想,职位长久维护设计
* 完整文档: 提供完善的开发文档
* **跨全平台: 支持所有主流操作系统及 .Net 全部项目类型**



**功能模块:**

<img src="imgs/75.png" style="zoom: 67%;" />

**环境要求:**

* Visual Studio 2019 16.8+
* .Net 5 SDK+
* .Net Standard 2.1+



**支持平台**

* 运行环境
  * Windows
  * Linux
  * MacOS/MacOS M1 CPU
  * Docker/K8S/K3S/Rancher
  * Xamarin/MAUI
* 数据库
  * Sql Server
  * MySql
  * Sqlite
  * Azure Cosmos
  * MariaDB
  * PostgreSQL
  * InMemoryDatabase
  * Oracle
  * Firebird
  * 达梦数据库
  * MongoDB
* 应用部署
  * Kestrel
  * Nginx
  * Jexus
  * IIS
  * Apache
  * PM2
  * SuperVisor
  * 独立发布/单文件
  * 容器(Docker/K8S/K3S/Rancher/PodMan)

**Furion遵循MIT开源协议	**

### 2. 架构说明

#### 2.1 示例架构

示例地址: https://gitee.com/dotnetchina/Furion/tree/v4/samples 

源码仓库中的samples示例采用多层分层设计,主要设计是 *自动抽象工厂* 和 *DDD 领域驱动设计相结合*

Furion示例项目结构如下:

* Furion : 框架核心层
* Furion.Application : 业务应用层(业务代码主要编写层)
* Furion.Core : 核心层(实体,仓储,其他核心代码)
* Furion.Database.Migrations :  EF Core 架构迁移文件层
* Furion.EntityFramework.Core : EF Core 配置层
* Furion.Web.Core : Web核心层(存放Web公共代码,如: 过滤器,中间件和 Web Helpers等)
* Furion.Web.Entry : Web入口层/启动层



各层的依赖关系如下:

> YourName 为自己的项目名称

* YourName.Application : 添加 YourName.Core 引用
* **YourName.Core** : **添加 Furion 引用 , SqlSugar版本添加Furion.Pure**
* YourName.DataBase.Migrations : 添加 YourName.EntityFramework.Core 引用
* YourName.EntityFramework.Core : 添加 YourName.Core 引用 
* YourName.Web.Core : 添加 YourName.Application ,  YourName.DataBase.Migrations 引用
* **YourName.Web.Entry** : **添加 YourName.Web.Core 引用和 Microsoft.EntityFrameworkCore.Tools包** 

> 如果采用EF Core 以外的ORM框架,如 SqlSugar , 那么无需创建 YourName.Database.Migrations 和 YourName.EntityFramework.Core层
>
> 另外 YourName.Web.Entry 无需引用 Microsoft.EntityFrameworkCore.Tools包



### 3. 官方脚手架

> 注意: 脚手架不是安装在项目中的!!!!   它是通过我们在命令提示符(cmd)或者PowerShell 安装到操作系统中的.

Furion 官方提供了多种 Web 应用类型的脚手架,方便快速创建多层架构项目.

#### 3.1 Furion + EF Core

| 模板类型 | 名称                             | 版本   | 关键词          | 描述                  |
| -------- | -------------------------------- | ------ | --------------- | --------------------- |
| NuGet    | Furion.Template.Mvc              | v4.6.5 | furionmvc       | Mvc模板               |
| NuGet    | Furion.Template.Api              | v4.6.5 | furionapi       | WebApi模板            |
| NuGet    | Furion.Template.App              | v4.6.5 | furionapp       | Mvc/WebApi模板        |
| NuGet    | Furion.Template.Razor            | v4.6.5 | furionrazor     | RazorPages 模板       |
| NuGet    | Furion.Template.RazorWithWebApi  | v4.6.5 | furionrazorapi  | RazorPages/WebApi模板 |
| NuGet    | Furion.Template.Blazor           | v4.6.5 | furionblazor    | Blazor模板            |
| NuGet    | Furion.Template.BlazorWithWebApi | v4.6.5 | furionblazorapi | Blazor/WebApi模板     |

#### 3.2 Furion + SqlSugar

> SqlSugar 优点:
>
> 弥补 EF Core 上手难度: 支持线程安全, 支持多库事务,多库兼容,多库查询和多库切换

| 模板类型 | 名称                                      | 版本   | 关键词      | 描述                  |
| -------- | ----------------------------------------- | ------ | ----------- | --------------------- |
| NuGet    | Furion.SqlSugar.Template.Mvc              | v4.6.5 | fsmvc       | Mvc模板               |
| NuGet    | Furion.SqlSugar.Template.Api              | v4.6.5 | fsapi       | WebApi模板            |
| NuGet    | Furion.SqlSugar.Template.App              | v4.6.5 | fsapp       | Mvc/WebApi模板        |
| NuGet    | Furion.SqlSugar.Template.Razor            | v4.6.5 | fsazor      | RazorPages 模板       |
| NuGet    | Furion.SqlSugar.Template.RazorWithWebApi  | v4.6.5 | fsrazorapi  | RazorPages/WebApi模板 |
| NuGet    | Furion.SqlSugar.Template.Blazor           | v4.6.5 | fsblazor    | Blazor模板            |
| NuGet    | Furion.SqlSugar.Template.BlazorWithWebApi | v4.6.5 | fsblazorapi | Blazor/WebApi模板     |

#### 3.3 安装脚手架

打开 cmd 或者 powershell 执行模板安装命令 

``` shell
dotnet new --install 模板名称::版本号
```

例如: 

(1) 安装EF Core Mvc

``` shell
dotnet new --install Furion.Template.Mvc::4.6.5
```

(2) 安装SqlSugar Mvc

``` shell
dotnet new --install Furion.SqlSugar.Template.Mvc::4.6.5
```



> 脚手架基本使用:
>
> 在 SqlSugar脚手架中,Core 层包含一个 DbContext 类, 可以通过DbContext.Instance 就可以获取到 SqlSugar对象
>
> 数据库连接字符串在启动层 appsetting.json 文件的 **ConnectionConfigs** 节点中配置, 对应的是 SqlSugar中的 **ConnectionConfig[]** 对象



#### 3.4 使用脚手架

我们可以通过下面的命令来通过脚手架创建项目:

``` shell
dotnet new 关键字 -n 项目名称
```

这样就可以生成项目代码了, **生成之后推荐将所有的nuget包更新到最新版本**

> 注意: 通过脚手架生成的项目名称不能包含 短横线 等特殊字符,如果有该需求,可在生成后通过 visual studio 进行手动修改

> 关键字上我们上面表格当中的关键字,我们也可以通过 dotnet new --list 查看.



#### 3.5 Visual Studio 集成

除了通过上面的命令创建项目以外,我们还可以使用 visual studio 可视化方式创建.

> 注意: 需要vs 升级到最新版

<img src="imgs/76.png" style="zoom:67%;" />



**关于MVC添加区域错误问题**

由于Furion底层依赖了 Microsoft.CodeAnalysis.CSharp 包, 所以可能通过 Visual Studio 的界面添加 Area 区域时会出现错误,这时候只需要在 Web.Entry 层下安装 下面几个包即可:

* Microsoft.CodeAnalysis.CSharp.Features
* Microsoft.CodeAnalysis.CSharp.Scripting
* Microsoft.CodeAnalysis.VisualBasic.Features
* Microsoft.CodeAnalysis.Workspaces.MSBuild
* Microsoft.VisualStudio.Web.CodeGeneration.Design



  项目搭建好之后,集成 Furion 框架只需要在 Program.css中添加 Inject() 方法即可

``` C#
var builder = WebApplication.CreateBuilder(args).Inject();

builder.Services.AddControllers().Inject();

var app = builder.Build();

app.UseHttpsRedirection();

app.UseAuthorization();

app.UseInject();

app.MapControllers();

app.Run();
```

### 4. 动态 WebApi

> 注意: 动态WebApi 实际上就是将普通的类变成 Controller , 也就是说动态WebApi 就是控制器,支持控制器一切功能.

#### 4.1 什么是控制器

简单来说,控制器是一个承上启下的作用,根据用户输入,执行相应的行为(action),同时在行为中调用模型的业务逻辑,返回给用户结果(如:视图,数据等).

> 这个地方的控制器其实就是我们之前学习.net 6 mvc, webapi 的控制器

![](imgs/77.png)

#### 4.2 Mvc控制器 约定和缺点

##### 4.2.1 WebApi 约定

在 Asp.Net Core 应用中, 一个 WebApi 控制器需遵循以下约定:

* 控制器类**必须继承** ControllerBase 或者间接继承
* action**必须贴有[HttpMethod]特性,如: HttpGet**
* 控制器或动作方法**至少有一个配置[Route]特性**
* 生成 WebApi 路由地址时会自动去掉控制器名称 Controller 后缀, 同时也会去掉动作方法匹配的 HttpVerb 谓词,如: GET , POST , DELETE , PUT 等.
* **不支持返回非IEnumerable\<T> 泛型对象**
* **不支持类类型参数在GET,HEAD 请求下生成 Query 参数**

还有就是 WebApi 路由地址 **基本靠手工完成**, 不利于书写,不利于维护

##### 4.2.2 .Net Core WebApi 缺点

.Net Core WebApi 有以下缺点: 

* 路由地址基本靠手工完成
* 在现在移动为王的时代,不利于进行多版本控制
* 对接 Swagger 文档分组比较复杂
* 实现 Policy 策略授权也比较复杂
* 不支持控制器热插拔插件化
* 难以实现复杂自定义的 RESTful Api 风格

#### 4.3 动态WebApi控制器

针对以上 Asp.Net Core 提供 WebApi 必须遵循的约定和补课避免的缺点, Furion 框架创造出一种更加灵活创建 WebApi 控制器的方式.

这种方式在继承了 Asp.Net Core WebApi 所有优点, 同时进行了大量拓展和优化. 优化后的WebApi 具有以下优点:

* 具备原有的 ControllerBase 所有功能
* 支持 **任意公开 非静态 非抽象 非泛型类**转换控制器
* 提供更加灵活方便的 IDynamicApiController 空接口 或 DynamicApiController 特性替代 ControllerBase 抽象类
* 无需手动配置 [HttpMethod] 特性, 同时支持一个动作方法多个 HttpVerb
* 无需手动配置 [Route] 特性, 支持更加灵活的配置及自动路由生成
* 支持返回泛型接口,泛型类
* 和Swagger 深度结合, 提供极其方便的创建Swagger分组配置
* 支持 Basic Auth , Jwt , ApiKey 等多种权限灵活配置
* 支持控制器,动作方法**版本控制**功能
* 支持 GET , HEAD 请求自动转换 类类型参数
* 支持生成 OAS3 接口规范



## 六. RBAC权限设计

### 1. 简介

RBAC权限设计(Role-Base Access Control: 基于角色的权限控制)是根据RBAC模型演化而来的权限设计框架，我们之前所做的后台权限设计属于基础权限管理系统，这种系统结构简单清晰，但是无法承载复杂的需求。基础的权限设计一般都是【用户 - 权限】这两个纬度开始的，管理员需要为每一个用户单独定义权限。如果系统中用户在十几个上下，权限变动也不太多时，这种【用户 - 权限】的权限管理国际简单清晰，很好用。但当系统中用户开始增多，达到上千、上万时此种管理方法的局限性就暴露出来了。

RBAC的核心是引入角色的概念，用角色作为中间介质，使用户与权限配置更加灵活。

### 2. 基于RBAC模型的权限设计 - 引入角色概念

当用户量达到一定规模后，管理员要修改一批用户的权限时，在【用户 - 权限】的模型中，几乎不可能手动完成。这时，我们在**用户**和**权限**之间引入**角色**这个概念。将用户与权限直接对应的关系，改为用户关联角色，角色关联权限的方式来赋予用户权限，即【用户 - 角色 - 权限】。

引入角色的好处是将抽象的权限具象化，我们仅需要思考每个角色应该赋予什么样的权限，再将对应的用户指向角色，即可完成账号授权。

**RBAC权限模型的优势：**

（1）将抽象的权限具象化，分配权限时不用再思考抽象问题。

> 举例： 新入职的初级销售小张管理员开账号，管理员不用纠结到底要不要给小张开【查看部门销量】的权限，只需要把小张的账号指向[初级销售]的角色即可，这个角色有怎样的权限，早已经被定义好了。

（2）批量调整权限

> 举例： 有时公司上新业务模块，管理员要授权某一属性的用户查看该模块数据。比如公司新上直播功能，需要运营组可以操作直播后台，那么管理员只需要修改【运营】这个角色的权限即可修改所有运营组成员的账号权限。

### 3. RBAC权限模型的多个应用场景

RBAC权限模型清晰简单的管理逻辑非常好的体现在实际应用中，下面通过案例来理解这种权限架构的逻辑思路。

#### 3. 1 RBAC 基本类型： 用户 - 角色 - 权限 

RBAC的基础性仅包含【用户 - 角色 - 权限】概念。在这个模型中，用户与角色，角色与权限是多堆垛的关系，用户的权限就是所属的全部角色拥有的权限之和。多数昌平的用户管理，使用RBAC基本型就可以完成很好的权限控制。

![](imgs/78.png)

